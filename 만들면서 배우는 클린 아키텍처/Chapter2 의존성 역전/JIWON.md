# 의존성 역전하기

## 단일 책임 원칙

우리가 아는 정의: **하나의 컴포넌트는 오로지 하나의 일만 해야 하고, 그것을 올바르게 수행해야 한다.**

실제 정의: **컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.**

**책임이라는 것을 변경할 이유로 해석해야 한다.**

## 의존성 역전 원칙

계층형 아키텍처에서 계층 간 의존성은 항상 다음 계층인 아래 방향을 가리킨다.

→ **단일 책임 원칙을 고수준에서 적용하면 상위 계층들이 하위 계층에 비해 변경할 이유가 더 많다.**

**영속성 계층을 변경할 때마다 잠재적으로 도메인 계층도 변경해야 한다.**

→ 도메인 코드는 application에서 제일 중요한 코드이다. → 영속성 코드가 바뀐다고 도메인 코드까지 바뀌면 안됨

이 경우 의존성 역전 원칙을 통해 의존성을 제거할 수 있다.

의존성 역전 원칙: **코드상의 어떤 의존성이든 그 방향을 바꿀 수 있다.**

도메인 코드와 영속성 코드 간의 의존성을 역전시켜서 **영속성 코드가 도메인 코드에 의존하고, 도메인 코드를 변경할 이유의 개수를 줄여야 한다.**

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/7f2b8496-355a-476d-919f-166ccc068f4a)

## 클린 아키텍처

로버트 마틴이 제안한 아키텍처

비즈니스 규칙은 프레임워크, DB, UI 기술, 그 밖의 외부 application, interface로부터 독립적일 수 있다.

→ 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 한다. 대신에 의존성 역전 원칙의 도움으로 모든 의존성이 도메인 코드를 향한다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/933a0bf7-4136-49c4-8054-025e003e2db5)

사진 출처: [https://velog.io/@devty/Clean-Architecture#clean-architecture-클린-아키텍처-돌아가는-로직은](https://velog.io/@devty/Clean-Architecture#clean-architecture-%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%8F%8C%EC%95%84%EA%B0%80%EB%8A%94-%EB%A1%9C%EC%A7%81%EC%9D%80) 

계층들이 동심원으로 둘러싸임

**가장 중요한 규칙은 의존성!! → 계층 간 모든 의존성이 안쪽으로 향해야 한다.**

**아키텍처의 코어에는 주변 유스케이스에서 접근하는 도메인 엔티티 존재**

유스케이스는 서비스라고 불렀던 것들 → 단일 책임을 위해 세분화 (넓은 서비스 문제 해결)

도메인 코드에서는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없다.

→ **비즈니스 규칙에만 집중할 수 있다. (ex. 도메인 주도 설계를 가장 순수한 형태로 적용 가능)**

도메인 계층이 영속성이나 UI와 같은 외부 계층과 철저히 분리돼야 하므로 application의 엔티티에 대한 모델을 각 계층에서 유지보수해야 한다.

→ ORM 프레임워크를 사용한다고 가정할 때 도메인 계층에서 사용하는 엔티티 클래스, 영속성 계층에서 사용하는 엔티티 클래스를 따로 만들어줘야 한다. → 두 엔티티를 서로 변환해야 한다

## 헥사고날 아키텍처

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/649d8894-ebd5-4860-8c98-a2b1a84f11f8)

육각형 내부에는 도메인 엔티티와 이와 상호작용을 하는 유스케이스 존재

**육각형 내부에서 외부로 향하는 의존성은 없다.**

**모든 의존성은 코어로 향한다.**

왼쪽에 있는 어댑터들은 애플리케이션 코어를 호출하기 때문에 애플리케이션을 주도하는 어댑터

오른쪽에 있는 어댑터들은 애플리케이션 코어에 의해 호출되기 때문에 애플리케이션에 의해 주도되는 어댑터

**코어와 어댑터들 간의 통신이 가능하려면 애플리케이션 코어가 각각의 포트를 제공해야 한다.**

주도하는 어댑터의 포트는 코어에 있는 **유스케이스 클래스들에 의해 구현**되고 호출되는 인터페이스

주도되는 어댑터의 포트는 **어댑터에 의해 구현**되고 코어에 의해 호출되는 인터페이스

이러한 아키텍처 스타일은 포트와 어댑터 아키텍처로도 알려져 있다.

## 유지보수가 가능한 소프트웨어가 될 수 있는 이유

의존성을 역전시켜 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 함으로써 영속성과 UI에 특화된 모든 문제로부터 도메인 로직 결합을 제거하기 때문에
