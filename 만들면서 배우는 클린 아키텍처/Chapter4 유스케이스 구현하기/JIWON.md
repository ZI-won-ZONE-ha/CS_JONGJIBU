# 유스케이스 구현하기

Application, Web, Persistence 계층이 느슨하게 결합되었기 때문에 **도메인 코드를 자유롭게 모델링할 수 있다.**

유스케이스를 구현하기 위한 방법에 대해 알아보자

## 도메인 모델 구현하기

한 계좌에서 다른 계좌로 송금하는 유스케이스를 구현해보자

→ 객체지향적으로 모델링하기 위해 Account 엔티티를 만들고 출금 계좌에서 돈을 출금해서 입금 계좌로 입금한다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/b6dd7037-321f-44b3-af1e-305ca758d2a6)

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/94f4e0a6-ad51-4de6-b60c-a6dcb50782b2)

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/0be50762-fd4d-4471-954e-28670992f6d7)

Account 엔티티는 현재 계좌의 스냅샷을 제공한다.

계좌의 모든 입출금 내역은 Activity 엔티티에 포함된다. 

→ 모든 Activity를 가져올 수 없으니 value object를 통해 특정 날짜 범위의 Activity들을 가져온다.

## 유스케이스 둘러보기

유스케이스가 실제로 하는 일은 다음과 같다.

1. 입력을 받는다.
2. 비즈니스 규칙을 검증한다.
3. 모델 상태를 조작한다.
4. 출력을 반환한다.

유스케이스 코드는 도메인 로직에 신경써야 한다. → 입력 유효성 검증으로 오염되면 안 된다.

유스케이스가 비즈니스 규칙을 검증할 책임을 가진다. + 도메인 엔티티와 책임을 공유

비즈니스 규칙을 충족하면 유스케이스는 입력을 기반으로 모델의 상태를 변경

→ 일반적으로 도메인 객체의 상태를 바꾸고 영속성 어댑터를 통해 구현된 포트로 이 상태를 전달해준다.

유스케이스는 여러 아웃고잉 어댑터를 호출할 수 있다.

마지막은 아웃고잉 어댑터에서 온 출력값을, **유스케이스를 호출한 어댑터로 반환할 출력 객체로 변환**한다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/584d33a7-cf9a-4cbd-84e7-2a5a6527c630)

서비스는 인커밍 포트 인터페이스인 `SendMoneyUseCase`를 구현

계좌를 불러오기 위해 아웃고잉 포트 인터페이스인 `LoadAccountPort` 호출

데이터베이스에 계좌 상태를 업데이트하기 위해 `UpdateAccountStatePort` 호출

이를 다이어그램으로 나타내면 다음과 같다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/efb65342-b94b-4662-984b-143512c385c4)

이제 todo를 채워보자

## 입력 유효성 검증

입력 유효성 검증은 유스케이스 클래스의 책임이 아니다. → **도메인 로직에 집중**해야되기 때문에

그렇다고 **어댑터에서 입력 검증을 하기에는 여러 어댑터에서 모든 입력 검증을 하면 코드 중복이 많아진다.**

→ 결국에는 **Application 계층에서 입력 유효성을 검증해야 된다!**

→ 입력 모델(input model)에서 입력 유효성 검증을 해야한다.

`SendMoneyCommand` 에서 객체를 생성할 때 입력에 대한 유효성 검증을 해야한다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/c0a4cc3c-6623-436d-8f01-6656389533fa)

`SendMoneyCommand`의 필드를 `final`로 두어 생성에 성공하면 잘못된 상태로 변경하지 못하게 막는다.

`SendMoneyCommand` 는 유스케이스 API의 일부이기 때문에 인커밍 포트에 패키지에 위치한다.

→ **유효성 검증이 Application의 코어(육각형 내부)에 존재하는 아쉬움은 있지만 제일 깨끗해야 되는 유스케이스 코드를 오염시키지는 않는다.**

유효성 검증은 Java Bean Validation API를 활용하여 검증한다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/bad809ea-5bde-4a7e-ad06-01ccb95e16ac)

입력 모델에 있는 **유효성 검증 코드를 통해 유스케이스 구현체 주위에 오류 방지 계층을 만들었다.**

→ 잘못된 입력을 호출자에게 돌려주는 유스케이스 보호막

## 생성자의 힘

SendMoneyCommand의 필드가 추가된다면 어떻게 해야할까?

→ 빌더 사용을 고려할 수 있다.

생성자를 private으로 숨기고 빌더의 build() 메서드가 이를 쓰면 된다.

→ **유효성 검증 로직을 생성자에 그대로 두기 때문에 빌더가 유효하지 않은 상태의 객체를 생성하지 못 하게 막을 수 있다.**

다만 이렇게 빌더를 사용하는 경우 필드가 추가되는 경우 이를 잊고 빌더에 추가하지 않을 수도 있다.

→ 생성자를 쓰면 컴파일 에러 발생시킬 수 있다.

이 부분은 뭘 쓰든 본인이 편한걸 쓰는게 좋을거같다.

## 유스케이스마다 다른 입력 모델

서로 다른 유스케이스에서 같은 입력 모델을 쓰고싶은 경우가 있을 수 있다.

절대 그러면 안된다. 안되는 이유는 다음과 같다.

- 필요한 필드가 다를 수 있음
- 서로 다른 유효성 검증 로직이 필요할 수 있음

→ **유스케이스마다 전용 입력 모델을 만들어 유스케이스를 명확하게 만들고 결합을 제거하는게 좋다.**

## 비즈니스 규칙 검증하기

**비즈니스 규칙 검증은 분명히 유스케이스 로직의 일부이다.**

→ Application의 핵심이기에 적절하게 잘 다뤄야 한다.

> 입력 유효성과 비즈니스 규칙의 차이
입력 유효성: 도메인 모델의 현재 상태에 진입할 필요가 없는 상황은 입력 유효성, 선언적 구현 가능
비즈니스 규칙: 모데인 모델의 현재 상태에 접근해야 한다. 유스케이스 맥락 속에서 의미적인 유효성 검증
> 

출금 계좌는 초과 출금이 되면 안 된다. → 모델의 현재 상태를 알아야 검증이 가능함 → 비즈니스 규칙 검증

송금되는 금액은 0보다 커야한다. → 모델의 상태를 몰라도 검증이 가능함 → 입력 유효성 검증

**비즈니스 규칙은 도메인 엔티티 내부에서 구현하는게 좋다.**

만약 **도메인 엔티티 내부에서 비즈니스 규칙을 검증하기 어렵다면 유스케이스 코드에서 검증해도 된다.**

**Validator 클래스를 생성하는 것도 방법!**

**비즈니스 규칙 검증을 위해 도메인 엔티티를 로드해야 한다면 도메인 엔티티 내에 비즈니스 규칙을 구현하면 된다.**

## 풍부한 도메인 모델 vs 빈약한 도메인 모델

헥사고날 아키텍처 스타일은 도메인 모델을 구현하는 방법에 대해서 열려 있다.

→ 마음대로 해도 된다.

DDD를 따르는 풍부한 도메인 모델, 빈약한 도메인 모델 뭐든 가능

각 도메인 모델의 특징에 대해서 알아보면

- 풍부한 도메인 모델
    - Application Core에 있는 **엔티티에 대해서 가능한 한 많은 도메인 로직이 구현**
    - 엔티티들은 상태를 변경하는 메서드를 제공 → 비즈니스 규칙에 맞는 유효한 변경만 허용
    - **유스케이스는 도메인 모델의 진입점(퍼사드 패턴)으로 사용된다.**
    - 유스케이스는 사용자의 의도를 표현하면서 도메인 메서드를 호출
- 빈약한 도메인 모델
    - 엔티티 자체가 굉장히 얇다
    - 상태 + getter/setter 포함
    - 유스케이스에 도메인 로직이 구현된다.
    - 유스케이스 → 비즈니스 규칙 검증, 엔티티 상태 변경, 아웃고잉 포트에 엔티티 전달 책임 보유
    - 유스케이스가 풍부한 모델

## 유스케이스마다 다른 출력 모델

유스케이스가 할 일을 마치면 출력을 제공해야 된다.

출력도 가능하면 유스케이스 맞게 구체적이면 좋다.

→ 출력은 호출자에게 꼭 필요한 데이터만 제공해야 한다.

유스케이스의 데이터 반환은 작게 하는게 좋다고 생각함

**출력 모델을 공유하게 되면 유스케이스끼리 강하게 결합됨**

→ **단일 책임 원칙을 적용하고 모델을 분리해서 유지하는게 좋음**

**엔티티를 출력 모델로 사용하면 안됨!**

## 읽기 전용 유스케이스

사용자에게 UI를 제공하는 경우 읽기 전용 유스케이스가 필요할 수 있다.

**Application Core 관점에서 이 작업은 데이터 쿼리이다.**

→ 실제 유스케이스와 구분하기 위해 Query로 표현 가능 (GetAccountBalanceQuery)

**쿼리를 위한 인커밍 포트 + 구현체로 읽기 전용 유스케이스 구현**

이런식으로 읽기 전용 쿼리를 구현하게 되면 CQS, CQRS와 같은 개념과 아주 잘 맞게 된다.

11장에서 클라이언트가 아웃 고잉 포트를 직접 호출하게 하는 지름길 방식 참고

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/ac531e01-0b48-4c83-a0d6-f547303f337a)

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/2787e982-feab-45b0-89a8-bae830332dbd)

## 유지보수가 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?

입출력 모델을 독립적으로 모델링한다면 원치 않는 부수효과를 피할 수 있다.

다만 작업이 느는 단점이 있다.

그래도 유스케이스를 명확하게 이해할 수 있고 장기적으로 유지보수가 쉬운 장점이 있다.

동시 작업도 원활하다. → 하나의 공통된 모델을 사용하는게 아니므로
