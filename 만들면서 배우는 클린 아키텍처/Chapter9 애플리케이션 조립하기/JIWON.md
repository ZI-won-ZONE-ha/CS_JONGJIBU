# 애플리케이션 조립하기

## 조립까지 신경쓰는 이유

코드 의존성이 올바른 방향을 가리키게 하기 위해서 조립까지 신경 써야 한다.

**모든 의존성은 안쪽으로 가지게 설계 (도메인 방향으로)**

유스케이스가 영속성 어댑터를 호출하고 스스로 인스턴스화 한다면 코드 의존성이 망가진 것

→ **유스케이스는 인터페이스만 알아야지 구현체를 알아서는 안된다.**

이렇게 의존성을 관리하기 위해 설정 컴포넌트가 필요하다.

→ 구현체를 주입해주는 역할을 담당한다.

설정 컴포넌트는 아래의 역할을 수행

- 웹 어댑터 인스턴스 생성
- HTTP 요청이 실제 웹 어댑터로 전달되도록 보장
- 유스케이스 인스턴스 생성
- 웹 어댑터에 유스케이스 인스턴스 제공
- 영속성 어댑터 인스턴스 생성
- 유스케이스에 영속성 어댑터 인스턴스 제공
- 영속성 어댑터가 실제로 DB에 접근할 수 있도록 보장

책임이 상당히 많다. → 단일 책임 원칙을 사실상 지키지 못함

## 평범한 코드로 조립하기

main 메서드를 만들고 해당 메서드에 인스턴스를 생성하고 직접 주입을 해주는 방식

단점으로는 주입할 대상이 많아지면 관리하기 어려운 단점, 클래스를 모두 public으로 열어야 하는 단점 존재

Spring을 활용하면 이러한 단점 없이 설정 정보를 관리할 수 있다.

## 스프링의 클래스 패스 스캐닝으로 조립하기

Application Context에 조립한 결과물을 담는 방식이다.

조립된 객체는 Bean이라는 이름으로 관리된다.

스프링은 클래스 패스 스캐닝을 통해 모든 클래스를 확인하면서 `@Component` 가 붙은 클래스를 찾아 빈으로 등록한다.

생성자 주입이 주로 활용된다.

**해당 방식을 활용하면 편리하게 객체를 조립할 수 있는 장점이 있다.**

커스텀 어노테이션을 생성해서 스캔 대상으로 만드는 방법도 있음 (커스텀 어노테이션 내부에 `@Component` 필수)

단점으로는 코드에 프레임워크 기술이 침투되는 단점이 존재

하지만 이 정도 침투는 용인할 수 있는 수준이다.

**다만 라이브러리나 프레임워크를 만들 때는 이렇게 외부 프레임워크 기술들이 침투되는 코드를 만들면 안 된다!**

→ 프레임워크, 라이브러리가 또 다른 프레임워크에 종속적이게 만들어지기 때문에

그리고 예상치 못 한 빈이 등록되는 단점이 있다. → 프로젝트 규모가 클수록 일일히 찾기 매우 어려움

## 스프링 Java Configuration으로 조립하기

Application Context에 추가할 빈을 생성하는 Java 클래스를 만드는 방식이다.

클래스에 `@Configuration`을 달아주면 된다.

메서드에 `@Bean`을 달아 어떤 빈을 등록할지 알려주면 된다.

Spring Data JPA의 경우 `@EnabledJpaRepositories` 를 달아주면 구현체가 알아서 생성되고 빈으로 등록된다.

해당 방식을 활용하면 애플리케이션 계층에 Spring 관련 코드가 붙지 않는 장점이 있다.

다만 access level을 public으로 열어야되는 단점이 있다.
