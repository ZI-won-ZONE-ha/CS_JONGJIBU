# Chapter 10. 이벤트

---

## 시스템 간 강결합 문제

---

환불 기능을 구현할 때 환불 기능을 실행하는 주체는 주문이다.

도메인 객체에서 환불 기능을 실행하려면 환불 기능을 제공하는 도메인 서비스를 파라미터로 전달받고 취소 도메인 기능에서 실행한다. 또는 응용 서비스에서 할수도 있다.

이 때 결제 시스템은 주로 외부에 존재하므로 외부 서비스에 이슈가 발생하면 우리 서비스에도 악영향을 미치게 된다. (외부 서비스가 정상이 아닌 경우, 외부 시스템 처리 속도가 오래 걸리는 경우 등)

또 다른 문제로는 **주문 로직에 결제 로직이 섞이는 점이다.**

→ 결제 관련 기능이 바뀔 때 주문 관련 로직도 변경해야 된다.

이렇게 **바운디드 컨텍스트가 강결합하게 되면 주문 바운디드 컨텍스트가 결제 바운디드 컨텍스트에 영향을 받을 수 밖에 없다.**

→ 이벤트를 활용하여 이러한 강한 결합을 없애야 한다.

## 이벤트 개요

---

Event: 과거에 벌어진 어떤 것

이벤트가 발생한다 → 상태가 변경되었다.

**이벤트가 발생하면 그 이벤트에 반응하여 원하는 동작을 수행하는 기능을 구현할 수 있다.**

### 이벤트 관련 구성요소

이벤트, 이벤트 생성 주체, 이벤트 디스패처(퍼블리셔), 이벤트 핸들러(구독자)로 구성된다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/a82b826b-bb24-477e-ac2b-984d159a7ff3)

이벤트 생성 주체: **엔티티, 밸류, 도메인 서비스와 같은 도메인 객체로 도메인 로직을 실행하여 상태가 바뀌면 관련 이벤트를 발행한다.**

이벤트 핸들러: **이벤트 생성 주체가 발행한 이벤트에 반응한다. 이벤트에 담긴 데이터를 이용해서 원하는 기능 실행**

이벤트 디스패처: 이벤트 생성 주체와 이벤트 핸들러를 연결, 구현 방식에 따라 동기 비동기 가능

### 이벤트의 구성

이벤트는 발행한 이벤트에 대한 정보를 담는다.

- 이벤트 종류: 클래스 이름으로 이벤트 종류 표현
- 이벤트 발생 시간
- 추가 데이터: 이벤트와 관련된 정보

**이벤트 네이밍은 과거 시제를 사용해서 만든다.**

이벤트는 **이벤트 핸들러가 작업을 수행하는 데 필요한 데이터를 담아야 한다.**

→ 필요한 데이터가 부족하면 DB나 관련 API를 호출하여 데이터를 직접 불러와야 한다.

→ 이벤트 내부에 필요한 데이터를 담아두자

### 이벤트 용도

1. 트리거

도메인의 상태가 바뀔 때 다른 후처리가 필요하면 후처리를 실행하기 위한 트리거로 이벤트 사용 가능

1. 서로 다른 시스템 간의 데이터 동기화

배송지 변경 시 외부 배송 서비스에도 바뀐 정보를 보내야 한다. 이 때 배송지 변경 이벤트를 활용하여 데이터 동기화 가능

### 이벤트 장점

서로 다른 도메인 로직이 섞이는 것을 방지할 수 있다.

구매 취소 로직에 구매 취소 이벤트를 발행하고 해당 이벤트를 환불 쪽에서 처리하면 서로 다른 도메인 로직이 분리된다.

또한 이벤트 핸들러를 활용하면 기능 확장도 편하다. 

→ 이메일 전송 로직을 만들고 싶다면 이벤트 발송을 처리하는 이벤트 핸들러 구현하면 됨

## 이벤트, 핸들러, 디스패처 구현

---

- 이벤트 클래스: 이벤트를 표현한다.
- 디스패처: 스프링이 제공하는 `ApplicationEventPublisher` 사용
- Events: 이벤트를 발행한다. 이벤트 발행을 위해 `ApplicationEventPublisher` 사용
- 이벤트 핸들러: 이벤트를 수신해서 처리한다. 스프링이 제공하는 기능을 사용

### 이벤트 클래스

이벤트 자체를 위한 상위 타입은 존재하지 않는다. 원하는 클래스를 이벤트로 사용하면 됨

네이밍은 과거 시제를 쓴다. (과거에 일어난 일에 대한 클래스기 때문에)

이름 뒤에 접미사로 Event를 붙여 이벤트라는걸 명시적으로 표현해도 된다.

**이벤트를 처리하는데 필요한 최소한의 데이터를 포함해야 한다.**

만약 모든 이벤트가 **공통으로 가지는 프로퍼티가 존재한다면 관련 상위 클래스를 만들어도 된다.**

### `Events` 클래스와 `ApplicationEventPublisher`

이벤트 발생과 출판을 위해 Spring이 제공하는 `ApplicationEventPublisher`를 사용한다.

`Events` 클래스는 `ApplicationEventPublisher`를 사용하여 이벤트를 발생시키도록 구현할 것이다.

```java
public class Events {

	private static ApplicationEventPublisher applicationEventPublisher;

	static void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {
		Events.applicationEventPublisher = applicationEventPublisher;
	}

	public static void raise(Object event) {
		if (applicationEventPublisher != null) {
			applicationEventPublisher.publishEvent(event);
		}
	}
}
```

```java
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class EventsConfiguration {

	@Autowired
	private ApplicationContext applicationContext;

	@Bean
	public InitializingBean eventsInitializer() {
		return () -> Events.setApplicationEventPublisher(applicationContext);
	}
}
```

`ApplicationContext`는 `ApplicationEventPublisher`를 상속하고 있으므로 `ApplicationContext`를 주입해준다.

### 이벤트 발생과 이벤트 핸들러

이벤트를 발생시킬 코드는 `Events.raise()` 메서드를 사용한다.

메인 로직을 수행한 뒤 `Events.raise()` 를 이용해서 관련 이벤트를 발생시킨다.

이벤트를 처리할 핸들러는 Spring이 제공하는 `@EventListener` Annotation을 사용해서 구현한다.

### 흐름 정리

이벤트 흐름은 다음과 같이 일어난다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/c8010bf2-6558-4474-af52-9ef634a04759)

1. 도메인 기능 실행
2. 도메인 기능은 `Events.raise()`를 이용해 이벤트 발생시킨다
3. `Events.raise()`는 스프링이 제공하는 `ApplicationEventPublisher`를 이용해 이벤트를 출판
4. `ApplicationEventPublisher`는 `@EventListener` 가 붙은 메서드를 찾아 실행

이 흐름은 응용 서비스와 동일한 트랜잭션 범위에서 이벤트 핸들러를 실행하고 있다.

→ **도메인 상태 변경과 이벤트 핸들러는 같은 트랜잭션 범위에서 발생한다.**

## 동기 이벤트 처리 문제

---

이벤트를 통해 강결합 문제는 해결됐지만 외부 서비스에 대한 영향은 해결되지 않았다.

외부 서비스의 속도가 느려진다면 우리 로직의 속도도 같이 느려지게 된다.

→ **외부 서비스의 성능 저하가 내 시스템의 성능 저하로 이어진다.**

그리고 예외가 발생한 경우도 문제가 발생할 수 있다.

→ 트랜잭션을 롤백할지 안할지도 결정해야 되고 고려할 사항이 많다.

이렇게 외부 시스템 연동을 동기로 처리할 때 발생하는 문제를 해소하기 위해 **이벤트를 비동기로 처리**하거나 **이벤트와 트랜잭션을 연계**하는 방법이 있다.

## 비동기 이벤트 처리

---

우리가 A를 하면 B를 하라의 요구 사항은 동기적으로 일어나지 않아도 된다.

→ A를 했을 때 최대 언제까지 B를 해야되는 경우가 많음 (일정 시간 내로만 하면 됨)

→ B를 실패했을 때 재시도를 하거나 수동 처리를 해도 상관 없는 경우도 있다.

이러한 경우 이벤트 처리를 비동기로 처리할 수 있다.

→ **A 이벤트가 발생하면 별도 Thread로 B를 수행하는 핸들러를 실행하는 방식으로 요구사항 구현 가능**

비동기 구현 방법은 다음과 같다.

- 로컬 핸들러를 비동기로 실행하기
- 메시지 큐 활용
- 이벤트 저장소와 이벤트 포워더 사용
- 이벤트 저장소와 이벤트 제공 API 사용

### 로컬 핸들러 비동기 실행

이벤트 핸들러를 별도의 Thread에서 실행하는 방법이다.

`@Async` Annotation을 활용하면 된다.

- `@EnableAsync` 를 사용하여 비동기 기능을 활성화한다.
- 이벤트 핸들러 메서드에 `@Async` Annotaion을 붙인다.

### 메시징 시스템을 이용한 비동기 구현

Kafka 또는 RabbitMQ와 같은 메시징 시스템을 이용해서 구현할 수 있다.

이벤트가 발생하면 이벤트 디스패처는 이벤트를 메시지 큐에 보낸다.

**메시지 큐는 이벤트를 메시지 리스너에게 전달하고, 메시지 리스너는 알맞은 이벤트 핸들러를 이용해서 이벤트를 처리한다.**

이벤트를 메시지 큐에 저장하는 과정과 메시지 큐에서 이벤트를 읽어와 처리하는 과정은 별도 Thread나 Process로 처리된다.

필요한 경우 이벤트를 발생시키는 도메인 기능과 메시지 큐에 이벤트를 저장하는 절차를 한 트랜잭션으로 묶어야 한다.

→ 글로벌 트랜잭션이 필요하다!

글로벌 트랜잭션을 사용하면 이벤트를 안전하게 메시지 큐에 전달할 수 있지만 성능이 떨어지는 단점이 존재한다.

**메시지 큐를 사용하면 보통 이벤트를 발행하는 주체와 이벤트 핸들러가 다른 JVM에서 동작한다.**

RabbitMQ의 경우 글로벌 트랜잭션, 클러스터, 고가용성을 지원하여 안정적이다.

Kafka는 글로벌 트랜잭션은 지원하지 않지만 성능이 우수하다. 

### 이벤트 저장소를 이용한 비동기 처리

- 포워더

이벤트를 우선 DB에 저장하고 별도 프로그램을 이용하여 이벤트 핸들러에 전달하는 방식이다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/fd31c46a-4428-406b-8bf8-0f903f160ce3)

이벤트가 발생하면 핸들러는 저장소에 이벤트를 저장

포워더는 주기적으로 이벤트 저장소에서 이벤트를 꺼내와 이벤트 핸들러 실행

**포워더가 별도의 Thread에서 실행되기 때문에 이벤트 발행과 처리가 비동기로 처리된다.**

**도메인 상태과 이벤트 저장소로 동일한 DB 사용**

→ 도메인 상태 변화와 이벤트 저장이 로컬 트랜잭션으로 처리된다.

→ 핸들러가 이벤트 처리에 실패하면 다시 이벤트 저장소에서 꺼내오면 된다.

- API

외부 핸들러가 API 서버를 통해 이벤트 목록을 가져오는 방식이다.

**포워더는 포워더가 이벤트를 어디까지 처리했는지 추적한다면 API 방식은 이벤트 목록을 요구하는 외부 핸들러가 자신이 어디까지 처리했는지 기억해야된다.**

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/79ff93b6-cc79-4930-8b83-4fdfe963e7af)

- 이벤트 저장소 구현

책 324p ~ 337p 구현 예시 참고하기

EventEntry, EventStore, JdbcEventStore, EventApi 등 구현

API 방식의 경우 클라이언트가 주기적으로 API 요청을 쏴야한다.

포워더의 경우 `@Scheduled` 를 통해 주기적으로 스케줄러 로직이 나가게 설계해주면 된다.

## 이벤트 적용 시 추가 고려 사항

---

1. 이벤트 소스를 EventEntry에 추가할지 여부
    1. 특정 도메인이 발생시킨 이벤트만 조회하기 기능이 필요하다면 이벤트에 발생 주체 정보를 포함해야 한다.
2. 포워더에게 전송 실패를 얼마나 허용할지 여부
    1. 포워더는 이벤트 전송에 실패하면 실패한 이벤트부터 다시 읽어와 전송한다. → 리미트를 걸어서 무한으로 다시 읽는 과정을 막아야한다.
    2. 실패한 이벤트를 따로 모아서 저장하기도 한다.
3. 이벤트 손실
    1. 로컬 핸들러를 사용하는 경우 이벤트를 비동기로 처리할 때 이벤트가 유실될 수 있다.
4. 이벤트 순서
    1. 이벤트 발생 순서대로 외부 시스템에 전달해야되는 경우 이벤트 저장소를 사용하는 것이 좋다.
5. 이벤트 재처리
    1. 동일한 이벤트를 다시 처리할 때 어떻게 할지 결정해야한다.
    2. 마지막으로 처리한 이벤트의 순번을 기억해 두었다가 무시하는 방법
    3. 멱등으로 처리하는 방법

> 멱등성
연산을 여러 번 적용해도 결과가 달라지지 않는 성질을 멱등성이라고 한다.
이벤트 처리도 동일한 이벤트를 한 번 적용하나 여러 번 적용하나 같은 상태가 되도록 구현할 수 있다.
이벤트 핸들러가 멱등성을 가진다면 이벤트 중복 발생이나 중복 처리에 대한 부담을 줄여준다.
> 

### 이벤트 처리와 DB 트랜잭션 고려

이벤트를 처리할 때 DB 트랜잭션을 함께 고려해야 한다.

이벤트 처리가 동기이든 비동기이든 이벤트 처리 실패와 트랜잭션 실패를 고려하면서 로직을 짜야한다.

트랜잭션 실패와 이벤트 실패를 모두 고려하면 복잡하므로 경우의 수를 줄이면 도움이 된다.

→ 트랜잭션이 성공했을 때 이벤트 핸들러를 실행하는 방법이 있다. (`@TransactionalEventListener` 에서 상태 지정해주면 된다.)

이벤트 저장소를 사용하는 경우도 트랜잭션 실패와 이벤트 실패가 동일한 경우가 되므로 경우의 수를 줄일 수 있다.
