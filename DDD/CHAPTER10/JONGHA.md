# 10장 이벤트

# 10.1 시스템 간 강결합 문제

- 환불 서비스 ?
    - 결제서비스는 외부에 존재하므로, 외부에 있는 결제 시스템이 제공하는 환불 서비스를 호출.
- 첫 번째 문제 : 외부서비스가 정상이 아닐 떄, 트랜젝션 처리는 어떻게?
    - 롤백? 커밋
    - 롤백하는 것이 맞아보이지만, 주문을 취소 상태로 변경하고, 환불만 나중에 시도할 수 있다.
- 두 번째 문제: 성능의 문제
    - 외부 시스템 응답 길어지면, 대기시간이 길어진다. → 외부 서비스 성능에 직접적인 영향 받음
- 세 번째 문제 : 주문 로직과 결제 로직이 섞인다.

```java
public class Order {

    public void cancel(RefundService refundService) {

        // 주문 로직
        verifyNotYetShopped();
        this.state = OrderState.CANCELED;

        // 결제 로직
        this.refundStatus = State.REFUND_STARTED;
        try {
            refundSvc.refund(getPaymentId());
            this.refundStatus = State.REFUND_COMPLETED;
        } catch(Exception e) {
            ...
        }

    }
}
```

- **주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트 간의 강 결합 때문**이다!!
- 주문과 결제가 강하게 결합되어 있어서 영향을 받는다.
- 해결법 : 이벤트를 사용한다. → 특히 비동기 이벤트

# 10.2 이벤트 개요

- 도메인 모델에서도 UI 컴포넌트와 유사하게 도메인의 상태 변경을 이벤트로 표현할 수 있다.

### 10.2.1 이벤트 관련 구성 요소

- 이벤트
- 이벤트 생성 주체
    - 엔티티 벨류, 도메인 서비스와 같은 도메인 객체이다.
    - 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생시킨다.
- 이벤트 디스패쳐 (퍼블리셔)
    - 생성 주체와 이벤트 핸들러를 연결해주는 것.
    - 디스패쳐에 이벤트 전달하고 , 해당 이벤트를 처리할 수 있는 핸들러에 이벤트 전파
    - 구현 방식에 따라 이벤트 생성과 처리를 동기나 비동기로
- 이벤트 핸들러 (구독자)
    - 생성 주체가 발생한 이벤트를 전달받아 이벤트에 담긴 데이터를 이용해서 원하는 기능을 실행한다.

예시)

- 이벤트는 현재 기준으로 과거에 벌어진 것을 표현하기 때문에 과거 시제('Changed') 사용함
- 발생 주체는 Order 애그리거트
- Events.raise()는 디스패처를 통해 이벤트 전파 기능 제공

```java
public class ShippingInfoChangedEvent {

    private String orderNumber;
    private long timestamp;
    private ShippingInfo newShippingInfo;

    // 생성자, getter
}
```

```java
public class Order {

  public void changeShippingInfo(ShippingInfo newShippingInfo) {
      verifyNotYetShipped();
      setShippingInfo(newShippingInfo);
      Events.raise(new ShippingInfoChangedEvent(number, newShippingInfo));
  }
  ...
}
```

- 이벤트는 데이터를 담아야 하지만, 이벤트 자체와 관련 없는 데이터를 포함할 필요는 없음.

### 10.2.3 이벤트 용도

- 트리거
    - 도메인 상태가 바뀔 때 후처리가 필요하면, 후처리를 실행하기 위한 트리거로 이벤트 사용
    - ex) 주문 취소하면 환불 처리해야한다. 주문취소 이벤트를 통해 환불 처리.
- 서로 다른 시스템 간의 데이터 동기화
    - ex) 배송지 변경하면, 배송지 변경 이벤트 외부 배송 서비스에 배송지 변경 정보를 동기화 한다.

### 10.2.4 이벤트 장점

- 서로 다른 도메인 로직 섞이는 것 방지.
    - 환불 실행 로직은 주문 취소 이벤트를 받는 이벤트 핸들러로 이동하게 된다.
    - 주문 도메인에서 결제 도메인으로 의존 제거.
- 기능 확장 용이
    - 기능을 확장해도 구매취소 로직은 수정할 필요가 없다.

# 10.3 이벤트, 핸들러, 디스패처 구현

- 이벤트 클래스 : 이벤트를 표현
- 디스패처 : 스프링이 제공하는 ApplicationEventPublisher 이용
- Events : 이벤트를 발행, 이벤트 발행을 위해 ApplicationEventPublisher 사용
- 이벤트 핸들러 : 이벤트를 수신해서 처리, 스프링이 제공하는 기능

## 이벤트 클래스

- 과저 시제만 사용
- 이벤트를 처리하는 데 필요한 최소한의 데이터 포함.

## 흐름

1. 도메인 기능을 실행한다. 
2. 도메인 기능은 Event.raise() 를 이용해서 이벤트를 발생시킨다. 
3. Event.raise()는 스프링이 제공하는 ApplicationEventPublisher를 이용해서 이벤트를 출판한다. 
4. ApplicationEventPublisher는 @EventListener(이벤트 타입.class) 에너테이션이 붙은 메서드를 찾아 실행한다. 

# 10. 4 동기 이벤트 처리 문제.

- 외부 서비스의 성능 저하가 바로 내 시스템의 성능 저하로 연결된다.
- 트랜젝션도 문제가 있다.
    - 환불이 실패했다고 해서, 구매취소도 실패하여햐 할까?
- → 외부 시스템과의 연동을 동기로 처리할 때 , 발생하는 성능과 트랜젝션 범위 문제를 해소하는 방법은 이벤트를 비동기로 처리하거나, 트랜잭션을 연계하는 것이다.

# 10. 5 비동기 이벤트 처리

- A하면, 최대 언제까지 B하라. → 이벤트의 비동기로 처리한다.
- 로컬 핸들러를 비동기로 실행하기
- 메세지 큐를 사용하기
- 이벤트 저장소와 이벤트 포워더 사용하기
- 이벤트 저장소와 이벤트 제공 API 사용하기

## 로컬 핸들러를 비동기로 실행

- 이벤트 핸들러를 별도 스레드로 실행한다.
- `@EnableAsync` 애노테이션을 사용해서, 비동기 기능을 활성화한다.
- 이벤트 핸들러 메서드에 `@Async` 애너테이션을 붙인다.

## 메세지 큐를 사용하기 (RabbitMQ, Kafka)

- 이벤트 발생 시 이벤트 디스패처가 이벤트를 메세지 큐에 보낸다.
- 메세지 큐는 이벤트를 이벤트 리스너에 전달하고, 메세지 리스너는 알맞은 이벤트 핸들러를 이용해 이벤트 처리.
- 이벤트를 메세지 큐에 저장하는 과정과 큐에서 이벤트 읽어서 처리하는 과정은 별도 스레드나 프로세스 처리.

- 이벤트를 발생시키는 도메인 기능과 메시지 큐에 이벤트를 저장하는 절차를 하나의 트랜젝션으로 한다면, 글로벌 트랜젝션이 필요하다.
    - 전체 성능이 떨어지고, 글로벌 트랜잭션을 지원하지 않는다.
- 메세지 큐를 사용하면, 보통 이벤트를 발생시키는 주체와 이벤트 핸들러가 별도 프로세스에서 동작.
    - 이벤트 발생 JVM과 이벤트 처리 JVM이 다르다.
    - 동일 JVM에서 비동기 처리 위해 메시지 큐 사용은 시스템을 복잡하게 만든다.
- 래빗 MQ와 같은 메시지 시스템은 글로벌 트랜젝션 지원과 함께 클러스터와 고가용성 지원을 통해 안정적으로 메세지를 전달.
- 다양한 개발 언어와 통신 프로토콜 지원한다.
- 카프카는 글로벌 트랜젝션을 지원하지 않지만, 높은 성능을 보여준다.

## 이벤트 저장소를 이용한 비동기 처리

### 1. 이벤트를 일단 디비에 저장하고, 별도 프로그램을 이용해 이벤트 핸들러에 전달.

- 핸들러는 스토리지에 이벤트 저장.
- 포워더는 주기적으로 이벤트 저장소에서 이벤트 가져와 이벤트 핸들러를 실행한다.
- 포워더는 별도 스레드를 이용하기 때문에 이벤트 발행과 처리가 비동기로 처리.
- 도메인 상태와 이벤트 저장소로 동일한 DB 지원?  도메인의 상태 변화 와 이벤트 저장이 로컬 트랜젝션으로 처리.
- 이벤트를 물리적 저장소에 보관하기 때문에 핸들러가 이벤트 처리에 실패할 경우, 포워더는 다시 이벤트 저장소에서 이벤트를 읽어와 핸들러 실행.

### 2. 이벤트를 외부에 제공하는 API를 사용

- 포워더와 차이점은 이벤트를 전달하는 방식.
    - 포워더는 이벤트를 외부에 전달.
    - API 방식은 API 서버를 통해 이벤트 목록을 가져감.
    - 이벤트를 어디까지 처리했는지 추적하는 역할이 포워더에 있다면, API는 이벤트 목록을 요구하는 외부 핸들러가 자신이 어디까지 이벤트를 처리했는지 기억.

### 3. 이벤트 저장소 구현.

- EventEntry : 이벤트 저장소에 보관할 데이터
- EventStore
- JdbcEventStore : JDBC를 이용한 EventStore 구현 클래스.
- EventApi : REST API를 이용해서 이벤트 목록을 제공하는 컨트롤러
- 과거의 데이터 이므로 수정 기능은 없이, 추가와 조회 기능만 있다.
- RestAPI 구현을 통해 get 호출하고, EventHandler 구현 클래스로 이벤트 객체를 저장한다.
    - 클라이언트 API 를  이용해 언제든지 원하는 이벤트를 가져올 수 있기 때문에 이벤트 처리에 실패하면, 다시 실패한 이벤트로 부터 읽어와 이벤트를 재처리 할 수 있다.
    - API 서버에 장애가 발생한 경우에도 주기적으로 재시도 하여 API 서버가 살아나면 이벤트를 처리가능.

### 4. 포워더 구현

- 일정 주기로 EventStore에서 이벤트를 읽어와 이벤트 핸들러에 전달하면 된다. 이벤트의 Offset을 기억해 두었다, 다음 조회 시점에 마지막으로 처리한 Offset부터 이벤트를 가져온다.
- 스프링의 @Scheduled 애너테이션을 사용하여, getAndSend() 메서드를 원하는 주기로 실행한다.
- OffsetStore를 구현한 클래스는 offset 값을 DB테이블에 저장하거나 로컬 파일로 보관해서, 마지막 offset 값을 물리적 저장소에 보관
- 

<aside>
💡 자동 증가 칼럼 주의 사항

</aside>

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/87687210/35656ac9-b57a-4c0f-bb27-5662c1e61c45)

- 실제 트랜잭션이 커밋될 떄 DB에 값이 반영되기 때문에 트랜잭션을 커밋하기 전에 조회하면, 증가한 값을 가진 레코드는 조회되지 않는다. 트랜잭션 격리 레벨을 높이거나 데이터 조회 시점과 최대 ID가 증가하는 시점에 차이를 둬야 한다. CDC(Change Data Capture)를 사용하는 방법도 있다.

https://javacan.tistory.com/entry/MYSQL-auto-inc-col-gotcha

# 이벤트 적용시 고려사항

- 이벤트 소스를 EventEntry에 추가할 지 여부
    - EventEntry는 발생 주체 대한 정보 X
    - 만일 필요하다면, 이벤트에 발생 주체 정보를 추가해야 한다.
- 포워더에서 전송 실패 얼마나 허용?
    - 전송 실패 때문에 나머지 이벤트 전송 못함
    - 재전송 횟수 제한 두어야 한다.
- 이벤트 손실
    - 이벤트 저장소 방식은 이벤트 발생과 저장을 하나의 트랜잭션으로 처리
    - 반면 로컬 핸들러를 이용해서 이벤트를 비동기로 처리할 때 이벤트 처리 실패하면, 이벤트 유실된다.
- 이벤트 순서
    - 이벤트 발생 순서대로 외부 시스템에 전달해야 할 때, 이벤트 저장소를 사용한다.
    - 이벤트 저장소는 저장소에 이벤트 발생 순서대로 저장하소 그 순서대로 이벤트 목록 제공하지만, 메시징 시스템은 사용기술에 따라 이벤트 발생 순서가 다를 수 있다.
- 이벤트 재처리
    - 이벤트 다시 처리할 때 이벤트를 어떻게 할지 결정해야 한다.
    - 이벤트의 순번을 기억해 두었다가, 이미 처리한 순번의 이벤트가 도착하면, 해당 이벤트를 처리하지 않고 무시한다.

<aside>
💡 멱등성 : 여러번 적용해도 결과가 달라지지 않는것.

</aside>

- 이벤트 처리도 동일 이벤트를 한번 적용하나 여러번 적용하나, 같은 상태가 되도록 핸들러를 구현할 수 있다.
- 이벤트 핸들러가 멱등성 가지면, 시스탬 장애로 인해 이벤트 중복 발생해도 동일 상태 이므로, 이벤트 중복 발생과 중복 처리에 대한 부담 줄여준다.

### 10.6.1 이벤트 처리와 DB 트랜잭션 고려

- 동기로 처리할 때 결제 취소 됐는데 디비 반영 할 때 실패된다면?
- 만약 비동기 이벤트 핸들러로 처리할 때 주문은 취소로 디비 반영됬는데 결제는 취소 안됐으면?

→ 트랜잭션이 성공할 때만 이벤트 핸들러를 실행한다. 

→ 스프링은 @TransactionEventHandler 를 지원. → 이를 통해 이벤트 처리 실패만 고민하면 된다. 이벤트 특성에 따라 재처리 방식 결정
