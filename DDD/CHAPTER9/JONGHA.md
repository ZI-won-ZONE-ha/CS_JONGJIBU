# 9장 도메인 모델과 Bounded Context

# 9.1 도메인 모델과 경계

- 실수 : 도메인을 완벽하게 표현하는 단일모델을 만드는 시도를 한다.
- 하지만, 한 도메인은 여러 하위 도메인으로 구분된다. 같은 용어라도 의미가 다르고, 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니다.
- ex) 같은 제품이라도 카탈로그 컨텍스트와 재고 컨텍스트에서 의미가 다르다.
- 하위 도메인 마다 사용하는 용어가 다르기 때문에 하위 도메인 마다 모델을 만들어야 한다.
- 바운디드 컨텍스트 : 모델은 특정한 컨텍스트 하에서 완전한 의미를 갖는다.

# 9.2 바운디드 컨텍스트

- 바운디드 컨텍스트는 모델의 경계를 결정하며, 한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖는다. 바운디드 컨텍스트는 용어를 기준으로 구분한다.
- 바운디드 컨텍스트와 하위 도메인은 일대일 관계가 아니다.
    - 주문 하위 도메인이라도 주문 처리팀과 결재 금액 로직 구현팀이 따로 있으면, 서로 다른 바운디드 컨텍스트가 존재한다.
    - 용어를 명확하게 구분하지 못하면, 두 하위 도메인을 하나의 바운디드 컨텍스트에서 구현하기도 한다.
    - 규모가 작은 기업은 전체 시스템을 한개 팀에서 구현할 수 있다. 즉 여러 하위 도메인을 한 개의 바운디드 컨텍스트에서 구현
    - 여러 하위 도메인을 하나의 바운디드 컨텍스트에서 개발할 때 주의할 점: 하위 도메인의 모델이 섞이지 않도록 한다.
    - 물리적인 바운디드 컨텍스트가 한 개 더라도 내부적으로 패키지를 활용해 논리적으로 바운디드 컨텍스트를 만든다.
- 바운디드 컨텍스트는 각자 구현하는 하위 도메인에 맞는 모델을 갖는다.
    - 멤버는 주문의 Orderer(value)이자, 회원의 애그리거트 루트이다.
    - 상품은 카탈로그에서는 category와 연관을 가지지만, 재고에서는 갖지 않는다.

# 9.3 바운디드 컨텍스트 구현

- 도메인 모델만 포함하는 것이 아니라, 표현영역, 응용서비스, 인프라스트럭처 영역을 모두 포함한다.
- 모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다.
    - 도메인 기능 자체가 간단하면, 서비스-DAO 로 구성된 CRUD방식을 사용해도 코드를 유지보수할 수 있다.
- 한 바운디드 컨텍스트에서 두 방식을 혼합할 수 있다. CQRS 패턴.
    - Command Query Responsiblity Segregation
    - 단일 바운디드 컨텍스트에 적용하면, 상태 변경과 관련된 기능은 도메인 모델 기반으로 구현, 조회 기능은 서비스 - DAO를 이용하여 구현할 수 있다.
- 각 바운디드 컨텍스트는 서로 다른 구현 기술을 써도 된다.
- 바운디드 컨텍스트가 반드시 사용자에게 보여지는 UI를 가지고 있어야 하는 것이 아니다. 각 바운디드 컨텍스트는 UI 서버를 통해 간접적으로 브라우저와 통신할 수 있다.

# 9.4 바운디드 컨텍스트 간 통합.

- 카탈로그 하위 도메인에 개인화 추천기능을 도입할 때, 추천시스템과 카탈로그 시스템 따로 개발한다면, 바운디드 컨텍스트가 나뉘어 지게 된다.
- 카탈로그 컨텍스트와 추천 컨텍스트 도메인 모델은 서로 다르다.
- RestAPI 를 통해 직접적으로 통합할 수 있다.
- 추천 시스템은 productID 를 이용하여 식별자를 표현하고 추천 순위와 같은 데이터를 담게 된다. 카탈로그 시스템에서는 추천 도메인 모델이 아닌, 카탈로그 모델을 기반으로 하는 도메인 서비스를 이용하여, 상품 추천 기능을 표현해야 한다.

```java
public interface ProductRecommendationService {
	List<Product> getRecommendationsOf(ProductId id);
}
```

- 도메인 서비스 구현한 것은 인프라 스트럭처 영역에 위치, 외부 연동을 위한 도메인 서비스 구현 클래스는 도메인 모델과 외부 시스템 간의 모델 변환을 처리한다.
- 변환 과정이 복잡하여, 별도 클래스를 만들고 변환 처리해도 된다.

---

- 간접적으로 메세지 큐를 이용해 통합할 수 있다.
- 카탈로그 바운디드 컨텍스트는 이력을 메세지 형식으로 큐에 추가하고, 추천 바운디드 컨텍스트는 큐에서 메세지를 가져와 추천을 계산한다. → 두 바운디드 컨텍스트가 사용할 메세지 데이터 구조를 맞춰야 한다.
    - 큐를 누가 제공하느냐에 따라 데이터 구조가 결정.

<aside>
💡 마이크로 서비스와 바운디드 컨텍스트

</aside>

개별 서비스를 독립된 프로세스로 실행하고, 각 서비스가 REST API 나 메시징을 이용해서 통신하는 구조이다. 

각 바운디드 컨텍스트는 모델의 경계를 형성하는데, 바운디드 컨텍스트를 마이크로 서비스로 구현하면, 자연스럽게 컨텍스트 별로 모델이 분리된다. 또한 이를 독립적으로 배포하고 모니터링하며 확장된다. 

# 9.5 바운디드 컨텍스트 간 관계

- 두 바운디드 컨텍스트는 다양한 방식으로 관계를 맺는다.
- 상류 컴포넌트는 일종의 서비스 공급자 역할을 하며, 하류 컴포넌트는 그 서비스를 사용하는 고객역할을한다.
- 공급자인 상류 팀이 마음대로 API를 변경하면, 하류 팀은 그에 따라 변경해야 한다. 따라서 이를 협의해야 한다.
- 상류 컴포넌트는 하류 컴포넌트가 사용할 수 있는 통신 프로토콜을 정의하고 이를 공개한다.
- 하류 팀이 다수 존재하면, 상류팀은 여러 하류 팀의 요구사항을 수용할 수 있는 API를 만들고, 이를 서비스 형태로 공개해서 서비스의 일관성을 유지할 수 있다.
    - 대표적인 예로 검색서비스가 존재한다. 검색을 위한 전용시스템을 구축하고, 이를 단일 API로 만들어 공개하고, 각 하류 팀은 API를 사용하여 검색 기능을 구현한다.
- 상류 컴포넌트의 서비스는 상류 바운디드 컨텍스트의 도메인 모델을 따른다. 따라서 하류 컴포넌트가 상류 서비스의 모델이 자신의 모델에 영향을 주지 않도록 완충지대를 만들어야 한다. (= 안티코럽션 계층)
- 두 바운디드 컨텍스트가 같은 모델을 공유하는 경우도 있다.
    - 공유커널이라 한다.
    - 장점: 중복을 줄여준다.
    - 단점: 임의로 모델을 변경해선 안되며, 두 팀이 밀접한 관계 형성→ 개발 지연.
- 독립 방식(Separate Way)
    - 두 바운디드 컨텍스트가 통합하지 않는 방식.
    - 두 컨텍스트의 통합은 수동으로 이루어진다.

# 9.6 컨텍스트 맵

- 바운디드 컨텍스트 간 관계를 표시한 맵.
- 전체 구조를 보여준다.
- 하위 도메인과 일치하지 않는 바운디드 컨텍스트를 찾아 도메인에 맞게 바운디드 컨텍스트를 조절하고 핵심 도메인을 위해 조직 역량을 어떤 바운디드 컨텍스트에 집중할지 파악하는데 도움을 준다.
