# 애그리거트 도입 이유

- 상위 수준에서 모델을 정리하면, 도메인 모델의 복잡한 관계를 이해하는 데 도움이 된다.
- 반대로, 개별 객체 수준에서 모델을 바라보면 상위수준에서 관계를 파악하기 어렵다.  → 전반적인 구조나 큰 수준에서, 도메인 간의 관계를 파악하기 어려워진다.
    - 도메인 요소 간의 관계를 파악하기 어렵다. → 코드를 변경하고 확장하는 것이 어렵다.
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만드려면 상위 수준에서 모델을 조망할 수 있어야 하는데, 그 방법이 바로 **애그리거트**이다. → 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/87687210/f2677601-f275-410c-a984-c73b66d46cb2)

# 애그리거트

- 모델을 이해하는 데 도움을 주고, 일관성을 관리하는 기준도 된다.
- 복잡한 도메인을 단순한 구조로 만들어 준다.
- 도메인 기능을 확장하고 변경하는데 노력이 준다.
- 애그리거트에 속한 객체는 유사하거나, 동일한 라이프 사이클을 갖는다.
- 애그리거트는 독립된 객체 군이며, 각 애그리거트는  다른 애그리거트를 관리하지 않는다.
- 반드시 A가 B를 갖는다는 요구사항이 한 애그리거트에 속한다는 것을 보장하지 않는다.
- ex) 리뷰와 Product는 영향을 주지 않는다.
- 도메인 규칙을 이해할 수록 애그리거트의 실제 크기는 줄어든다.

## 애그리거트 루트

- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리 거트 전체를 관리할 주체가 필요하다.  → 루트 엔티티가 책임을 진다.
- 루트 앤티티는 대표 엔티티. 나머지 객체는 루트 엔티티에 직접 또는 간접적으로 속한다.
- 루트의 핵심 역할 : **애그리거트의 일관성이 깨지지 않도록한다.** → 애그리거트가 제공해 할 도메인 기능을 구현한다.
- **애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경해서는 안된다.  모델의 일관성이 깨는 원인이 된다.**

> 애그리 거트 루트를 통해서만 도메인 로직을 구현하게 만들려면, 도메인 모델에 대해 다음의 두가지를 습관적으로 적용한다.
> 
- 단순히 필드를 변경하는 set 메서드를 공개 범위로 만들지 않는다.
- 밸류 타입은 불변으로 구현한다. → 내부 상태를 변경하려면 애그리거트 루트를 통해서만 가능하다.

### 애그리루트의 기능 구현

- 애그리거트 내부 다른 객체를 조합하여 기능을 완성한다.
    - 구성 요소 상태 참조
    - 기능 실행 위임
        - 만약 일급 컬렉션을 getter를 둔다면..?  불변으로 구현하던가, 제약으로 불변으로 구현을 못한다면 패키지(default) 나 protected 범위로 한정하여, 외부에서 실행할 수 없도록 한다.
        - 애그리거트는 보통 한 패키지에 속하므로, 애그리거트 외부에서 상태 변경 기능을 실행하는 것을 방지할 수 있다.

### 트랜젝션 범위

- 잠금 대상이 많아지는 것은 동시에 처리할 수 있는 트랜젝션 개수가 줄어든다. → 전체적인 성능을 떨어뜨린다.
- 한 트랜젝션에서는 하나의 애그리거트만 수정해야 한다. → 다른 애그리거트를 수정하면 트랜젝션 충돌이 발생할 가능성이 높아짐.  → 전체 처리량 떨어진다.
- 애그리거트가 다른 애그리거트의 상태까지 관리하기 떄문에, 의존적이게 된다. → 애그리 거트 간 결합도가 높아진다. 향후 수정비용이 증가하므로, 애그리거트에서 다른 애그리거트의 상태를 변경하면 안된다.
- 만약 하나의 트랜젝션에서 두개 이상의 애그리거트를 수정할 경우에, **응용서비스에서 두 애그리거트를 수정하도록 구현한다.  (어떤 응용 서비스가 하는게 맞을지 ?)**
- 도메인 이벤트를 사용하면 한 트랜잭션에서 한 개의 애그리거트를 수정하면서, 동기나 비동기로 다른 애그리거트의 상태를 변경할 수 있다. (나중에!)

## 리포지토리와 애그리거트

객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다. 물리적으로 각각 별도의 디비 테이블에 저장한다고 해서 order 와 orderLine을 위한 리포지토리를 각각 만들지 않는다. 

애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화 한다. 

애그리거트를 구하는 레포지토리 메서드는 완전한 애그리거트를 제공하여야 하고, 모든 구성요소를 포함하여야 한다. 

애그리거트를 영속화할 저장소로 무엇을 사용하든 간에 애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영하여야 한다. 

## ID를 이용한 애그리거트 참조

- 필드를 이용한 **애그리거트 참조(직접 참조)**

다음과 같은 문제가 발생한다. 

- 편한 탐색 오용
    - 구현이 쉬워 지기에, 다른 애그리거트 상태를 변경할 수 있다는 유혹
    - 애그리거트 간의 의존 결합도를 높여서, 애그리거트의 변경을 어렵게한다.
- 성능에 대한 고민
    - 직접참조를 할 때, 지연로딩과 즉시로딩에 대한 고민. 연관매핑과 JPQL, Criteria 쿼리의 로딩 전략이 필요
- 확장 어려움
    - 하위 도메인 마다 서로 다른 DBMS를 사용할 수 있다.
    - 다른 애그리 거트 루트를 참조하기 위해, JPA와 같은 단일 기술을 사용할 수 없다.
- id 참조
    - 애그리거트에 속한 객체들만 참조로 연결된다.
    - 애그리 거트의 경계를 명확히 하고, 애그리거트 간 물리적인 연결을 제거하여 모델의 복잡도 낮춤
    - 애그리거트 간 의존을 제거하여, 응집도를 높여준다.
    - 구현 복잡도가 낮아진다. 참조를 지연 또는 즉시 로딩으로 할지 고민하지 않아도 된다. 필요할 때 로딩하면 된다.
    - 리포지토리마다 다른 저장소를 사용하도록 구현할 때 확장 용이

### ID를 이용한 참조와 조회 성능

- ID를 이용한 애그리거트 참조는 지연 로딩과 같은 효과를 만들지만, 지연로딩과 관련된 대표적인 문제인 **N+1** 문제를 일으킨다.
    - 주문수가 열 개이면, 주문 마다 상품 정보를 읽어와야 하는 쿼리를 실행한다.

→ 이를 위해 **조회 전용 쿼리**를 사용하면 된다. → 데이터 조회를 위한 별도 DAO를 만들고, DAO의 조회 메서드에 조인을 이용해 한번의 쿼리로 필요한 데이터를 로딩한다.  

- 애그리거트 당 다른 저장소를 사용하면, 한번의 쿼리로 관련 애그리 거트를 조회할 수 없으므로, **조회전용 저장소나 캐시를 적용한다. → 시스템의 처리량을 높일 수 있다.**

## 애그리거트 간 집합 연관

1-N, M-N 연관은 컬랙션을 써서 구현할 수 있다.

### 애그리거트 간 1-N 연관

Set과 같은 컬렉션을 써서 구현할 수 있다. 

```java
public class Category {
	private Set<Product> products;
} 
```

- 하지만 페이징과 같은 경우 카테고리에 속한 모든 프로덕트를 가져와서, 페이징을 하게 되면, 성능에 심각한 문제가 생긴다. 따라서 실제로 1-N연관을 실제 구현에 반영하지 않는다.
- 대신 다음과 같이 N-1 관계로 풀어낸다.

```java
public clss Product {
	private CategoryId categoryId;
}
```

### 애그리거트 간 M-N 연관

- 특정 카테고리에 속한 상품 목록을 보여줄 때, 목록 화면에서 각 상품이 속한 모든 카테고리를 상품 정보에 표시하지 않는다.
- 개념적으로 양방향 M-N 연관이 존재하지만, 실제 구현에서는 상품에서 카테고리로의 단방향 M-N만 적용

```java
public class Product {
	private Set<CategoryId> categoryIds;
}
```

- 특정 카테고리에 속한 Product목록 가져오기

```java
select p from Product p 
[where :catId member of p.categoryIds](https://www.notion.so/8-4d64772b4aa1485293b2c28eb28a4f56?pvs=21) 
order by p.id.id desc
```

## 애그리거트를 팩토리로 사용하기

- Store 애그리거트에 Product 애그리거트를 생성하는 팩토리 역할을 한다. → 응용 서비스 단계에서 더이상 Store의 상태를 확인하지 않는다.
    - 응용 서비스 영향을 받지 않는다.
    - 도메인의 응집도가 높아진다.
    - → 애그리 거트를 팩토리로 사용할 수 있을 때 장점
    - 애그리 거트가 갖는 데이터를 이용해서 다른 애그리 거트를 생성할 때, 애그리 거트 팩토리 메서드를 고려하자.
    - 단, 다른 애그리거트를 생성할 때 많은 정보를 알아야 한다면 Store 애그리거트에서 Product 애그리거트를 직접 생성하지 않고, 다른 팩토리에 위임한다.
    
    <aside>
    💡 이런식으로 코드 짜면은 애그리거트간 의존도가 높아지지 않나??? mapper 로 해결해야 겠다
    
    </aside>
