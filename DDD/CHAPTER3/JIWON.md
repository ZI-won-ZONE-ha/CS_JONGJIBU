## 애그리거트

---

어떠한 시스템을 개발할 때 상위 수준의 개념을 이용해서 전체 모델을 정리하면 전반적인 관계를 이해하는데 도움이 된다.

**복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만드는 방법이 바로 애그리거트이다.**

**애그리거트는 모델을 이해하는데 도움을 주고 일관성을 관리하는 기준이 된다!**

애그리거트는 복잡한 도메인을 단순한 구조로 만들어준다.

→ 도메인 기능을 확장하고 변경하는데 필요한 노력도 줄어든다.

**애그리거트는 관련된 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 가진다.**

애그리거트는 경계를 가진다.

→ 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항!

**도메인 규칙에 따라 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다!**

A가 B를 가진다고하더라도 한 애그리거트에 속한다고 생각하면 안된다. ex) 제품과 리뷰

## 애그리거트 루트

---

애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이면 안된다.

애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요하다.

→ 루트 엔티티가 이를 담당한다. 애그리거트에 속한 객체는 루트 엔티티에 직접 또는 간접적으로 속하게 된다.

### 도메인 규칙과 일관성

**애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것**

→ 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.

애그리거트 루트를 통해서만 도메인 로직을 구현하려면 아래의 두 가지 습관을 가져야 한다.

- set 메서드는 public으로 열지 않기 or **setter 안만들기**(추천)
- 밸류 타입은 불변으로 구현하기

**애그리거트 루트가 도메인 규칙을 올바르게만 구현하면 애그리거트 전체의 일관성을 올바르게 유지할 수 있다!**

### 애그리거트 루트의 기능 구현

애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.

애그리거트 루트가 구성요소의 상태만 참조하는 것이 아닌 기능 실행을 위임하기도 한다

구성 요소들은 외부에서 접근하지 못하게 막아야하고 불변으로 두거나 구성 요소의 메서드를 `default`, `protected`로 설정해주는게 좋다.

### 트랜잭션 범위

트랜잭션의 범위는 작을수록 좋다.

→ **한 트랜잭션에서 한 개의 애그리거트만 수정해야 한다.** → 애그리거트가 다른 애그리거트를 변경하지 않는다.

한 트랜잭션에서 2개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 커진다.

**만약에 한 트랜잭션에서 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 여러 애그리거트를 수정하도록 구현해야 한다.**

도메인 **이벤트를 활용**하면 한 트랜잭션에서 한 개의 애그리거트를 수정하면서 동기나 비동기로 다른 애그리거트의 상태를 변경하는 코드를 작성할 수 있다!

## 레포지토리와 애그리거트

---

객체의 영속성을 처리하는 레포지토리는 애그리거트 단위로 존재한다.

레포지토리는 다음의 두 메서드를 기본적으로 제공해야 한다.

- save
- findById

레포지토리 구현 기술에 따라 애그리거트의 구현도 영향을 받는다.

애그리거트는 개념적으로 하나이므로 **레포지토리는 애그리거트 전체를 저장소에 영속화 해야 한다.**

애그리거트를 구하는 메서드는 **완전한 애그리거트를 제공해야 한다.**

## ID를 이용한 애그리거트 참조

---

애그리거트도 다른 애그리거트를 참조한다.

→ 애그리거트 루트가 다른 애그리거트 루트를 참조한다.

필드를 통한 애그리거트 참조는 다음 문제를 야기한다.

- 편한 탐색 오용
    - 다른 애그리거트의 상태를 쉽게 변경할 수 있다.
    - → 애그리거트 간의 의존 결합도를 높인다.
- 성능에 대한 고민
    - 지연 로딩, 즉시 로딩 어떤걸 선택할지 고민해야 된다.
- 확장 어려움
    - 도메인 별로 시스템을 분리할 때 깊게 참조되어 분리가 어려워질 수 있다.

이런 문제를 해결하기 위해 ID를 이용한 참조 방법을 활용할 수 있다.

- 애그리거트의 경계를 명확히 하고 물리적인 연결을 제거하여 모델의 복잡도를 낮춰준다.
- 구현 복잡도도 낮아진다: 참조하는 애그리거트가 필요하면 응용 서비스에서 가져오면 된다.
- 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 방지할 수 있다.

### ID를 이용한 참조와 조회 성능

ID를 참조하여 여러 애그리거트를 읽을 때 조회 성능 이슈가 발생할 수 있다.

→ 필요한 모든 데이터를 조인하지 않고 일일히 가져오기 때문에 N + 1 문제가 발생할 수 있음

**이 문제를 해결하기 위해 조회 전용 쿼리를 사용할 수 있다!!**

**조회 전용 저장소를 따로 구성하면 코드가 복잡해질 수 있지만, 시스템 처리량을 높일 수 있는 장점이 있다!**

## 애그리거트 간 집합 연관

---

애그리거트간 1:N, N:M 연관이 있을 수 있다.

애그리거트간 1:N 관계는 Set과 같은 컬렉션을 이용하여 표현할 수 있다.

→ 성능 이슈가 발생할 수 있다 (책 122p)

**1:N 연관이 있더라도 애그리거트 간의 연관을 실제 구현에 반영하지 말고 N:1로 연관지어 구현하는게 낫다.**

N:M 연관도 마찬가지로 실제 구현에 반영하지 않고 **단방향만 N:M 연관을 실제로 구현하는게 좋다.**

`@ElementCollection`, `@CollectionTable` 활용

## 애그리거트를 팩토리로 활용하기

---

애그리거트가 가지고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려.

→ 도메인 영역에 이런 생성 로직이 들어가므로 도메인의 응집도가 높아진다.

`Mapper`, `Validator`
