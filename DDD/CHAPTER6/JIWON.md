# Chapter 6. 응용 서비스와 표현 영역

---

## 표현 영역과 응용 영역

---

도메인이 제 기능을 하려면 사용자와 도메인을 연결해 주는 매개체가 필요하다.

→ **응용 영역과 표현 영역이 사용자와 도메인을 연결해 주는 매개체 역할을 수행한다.**

표현 영역은 사용자 요청을 해석하여 사용자가 실행하고 싶은 기능을 판별하고 응용 서비스를 실행한다.

응용 영역의 응용 서비스는 실제 사용자가 원하는 기능을 제공해준다. 

응용 서비스는 표현 영역에 의존하지 않고 단지 기능 실행에 필요한 값을 받고 실행 결과만 리턴한다.

## 응용 서비스의 역할

---

응용 서비스는 사용자가 요청한 기능을 실행한다.

사용자 요청을 처리하기 위해 리포지토리에서 도메인 객체를 가져와 사용한다.

**사용자 입장에서 봤을 때 응용 서비스는 도메인 영역과 표현 영역을 연결해 주는 역할을 한다.**

응용 서비스는 **도메인 객체 간의 흐름을 제어하기 때문에 다음과 같이 단순한 형태를 가진다.**

```java
@Transactional
public CartItem addCartItem(final CartItemAddRequest request, final Long memberId) {
	// 리포지토리에서 애그리거트를 구한다.
	CartItem cartItem = cartItemRepository.findCartItemByMemberIdAndProductId(memberId, request.getProductId())
		.orElse(CartItem.of(memberId, request.getProductId()));

	// 애그리거트의 도메인 기능을 수행한다.
	cartItem.addQuantity(Quantity.from(request.getQuantity()), cartItemValidator);

	// 결과를 리턴한다.
	return cartItemRepository.save(cartItem);
}
```

만약 **응용 서비스가 복잡하다면 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 있다.**

→ 응용 서비스가 도메인 로직을 구현하지 않게 설계하자! (코드 중복, 로직 분산)

응용 서비스는 **트랜잭션 처리**도 담당한다.

응용 서비스의 주요 역할로 접근 제어와 이벤트 처리가 있다.

### 도메인 로직 넣지 않기

도메인 로직은 도메인 영역에 위치하고 응용 서비스는 도메인 로직을 구현하지 않는다고 했다.

**도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 문제가 발생한다.**

1. 코드의 응집성이 떨어진다. → 로직이 서로 다른 영역에 위치하여 여러 영역을 분석해야 함
2. 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다.

도메인이 제공하는 기능을 사용하여 이런 코드 품질에 문제가 발생하지 않게 해야된다.

**도메인 로직이 응용 서비스에 출현하면서 발생하는 두 가지 문제는 코드 변경을 어렵게 만든다.**

도메인 로직을 꼭 도메인 영역에 모으자!!

## 응용 서비스의 구현

---

응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 수행하는데 이는 디자인 패턴에서 파사드와 같은 역할을 수행한다.

> 파사드 패턴
Gof(Gang of Four)에 따르면 Facade 패턴은 "하위 시스템을 보다 쉽게 사용할 수 있게 해주는 고급 인터페이스"로 정의되어 있다.
클라이언트가 하나의 기능을 수행하기 위해 여러 인터페이스를 호출하지 않고 하나의 통합된 인터페이스를 통해 호출 할 수 있게 해준다.
[https://ko.wikipedia.org/wiki/퍼사드_패턴](https://ko.wikipedia.org/wiki/%ED%8D%BC%EC%82%AC%EB%93%9C_%ED%8C%A8%ED%84%B4)
> 

응용 서비스 자체는 복잡한 로직을 수행하지 않기 때문에 응용 서비스의 구현은 어렵지 않다.

### 응용 서비스의 크기

응용 서비스 자체는 구현이 어렵지 않지만 고려할 사항이 있다.

응용 서비스의 크기를 고려해야 된다.

회원 도메인의 응용 서비스를 만든다고 할 때 응용 서비스는 회원 가입, 탈퇴, 암호 변경, 비밀번호 초기화 등 기능을 구현해야 한다.

이 때 응용 서비스는 2가지 방법 중 하나의 방식으로 구현한다.

1. 한 응용 서비스에서 회원 도메인의 모든 기능 구현하기
2. 구분되는 기능별로 응용 서비스 클래스 따로 두기

하나의 응용 서비스 클래스에서 모든 기능을 구현했을 때 장점은 **하나의 도메인과 관련된 기능을 구현한 코드가 한 클래스에 위치하므로 각 기능에서 동일 로직에 대한 코드 중복을 제거할 수 있다는 장점이 있다.**

대신에 모든 기능이 하나의 클래스에 모여있어 **클래스의 크기가 커지는 단점이 있다.** 클래스 크기가 커진다면 **연관성이 적은 코드가 한 클래스에 위치할 가능성이 높아지고 이는 코드를 이해하는데 방해 요소**로 작용한다.

구분되는 기능별로 서비스 클래스를 구현하는 방식은 한 응용 서비스 클래스에서 3개 이내의 기능을 구현한다.

이 방식은 클래스의 개수가 많아지는 단점이 있지만, 코드 품질을 일정 수준으로 유지하는 데 도움이 된다.

그리고 각 클래스 별로 필요한 의존 객체만 포함하므로 다른 기능을 구현한 코드에 영향을 받지 않는다.

만약 각 기능마다 동일한 로직을 구현해야 된다면 별도 클래스에 로직을 구현해서 코드가 중복되는 것을 방지할 수 있다.

```java
// 공통 로직 별도 클래스로 구현
public final class MemberHelper {
	
	public static Member findExistingMember(MemberRepository repo, String memberId) {
		Member member = repo.findById(memberId);
		if (member == null) {
			throw new NoMemberException();
		}
		return member;
	}
}

// 공통 로직을 제공하는 메서드를 응용 서비스에서 사용
public class ChangePasswordService {

	private final MemberRepository memberRepository;

	public void changePassword(String memberId, String curPw, String newPw) {
		Member member = MemberHelper.findExistingMember(memberRepository, memberId);
		member.changePassword(curPw, newPw);	
	}
}
```

### 응용 서비스의 인터페이스와 클래스

응용 서비스를 만들 때 인터페이스를 만들고 이를 구현한 클래스를 만들어야할까?

인터페이스가 필요한 몇가지 상황이 있다.

구현 클래스가 여러 개인 경우 인터페이스가 필요하지만 응용 서비스는 런타임 시점에 구현 클래스를 교체하는 경우가 거의 없고, 응용 서비스 구현체가 2개 이상인 경우도 드물다.

이런 이유로 **인터페이스와 구현 클래스를 따로 구현하는 것은 소스 코드만 많아지고 구현 클래스에 대한 간접 참조가 증가해 구조가 복잡해진다.**

진짜 **인터페이스가 필요한 경우가 생기기 전까지는 응용 서비스에 대한 인터페이스를 작성하는 것이 좋은 선택은 아니다.**

TDD를 즐겨하는 경우 가짜 객체를 위해 인터페이스가 필요한 경우가 있는데 이러한 경우도 **Mockito와 같은 라이브러리를 이용하면 클래스로도 테스트용 대역 객체를 만들 수 있기 때문에 응용 서비스에 대한 인터페이스가 없어도 테스트를 진행할 수 있다.**

결론: 진짜 인터페이스가 필요한 상황이 아니면 그냥 클래스로 만들자!

### 메서드 파라미터와 값 리턴

응용 서비스가 제공하는 메서드는 도메인을 이용해서 사용자가 요구한 기능을 실행하는 데 필요한 값을 파라미터로 전달 받는다.

이 때 파라미터를 하나하나 개별적으로 받을 수 있고, 별도의 데이터 클래스를 만들어 전달 받을 수 있다.

**Spring MVC에서는 요청 파라미터를 Java 객체로 변환하는 기능이 있기 때문에 응용 서비스로 데이터로 전달할 요청 파라미터가 2개 이상 존재하면 DTO 클래스를 쓰는 것이 편리하다!**

응용 서비스의 결과를 표현 영역에서 사용해야 하면 응용 서비스 메서드의 결과로 필요한 데이터를 리턴한다.

**다만 주의해야할 점은 응용 서비스에서 애그리거트 객체를 리턴하면 안된다!**

→ **도메인 로직 실행을 표현 영역에서 할 수 있게 되기 때문에 코드의 응집도가 떨어지게 된다!**

→ 의도치 않은 결과를 만들 수 있다!

### 표현 영역에 의존하지 않기

**응용 서비스의 파라미터 타입은 표현 영역과 관련된 타입을 사용하면 안된다!**

`HttpServletRequest`, `HttpSesssion` 등 컨트롤러에 사용되는 타입을 응용 서비스로 넘기면 안된다.

표현 영역이 변경될 때 응용 영역이 같이 변경되는 일이 발생할 수 있고, 응용 영역 자체 테스트가 어려워진다.

각 영역의 응집도를 위해 응용 서버스가 표현 영역과 관련된 타입을 안쓰도록 처리하자!

### 트랜잭션 처리

응용 서비스에서 하나의 기능을 수행하기 때문에 트랜잭션 관리는 중요한 역할이다.

Spring에서 제공하는 `@Transactional` 어노테이션을 적절하게 활용해 트랜잭션 관리를 해주자!

## 표현 영역

---

표현 영역의 책임은 다음과 같다.

1. 사용자가 시스템을 사용할 수 있는 흐름을 제공하고 제어
    1. 사용자가 요청한 내용을 응답으로 제공
    2. 사용자는 표현 영역이 제공한 폼에 맞춰 값을 입력하고 결과를 받는다.
2. 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 제공
    1. 화면을 보여주는데 필요한 데이터를 읽거나 도메인의 상태를 변경해야 할 때 응용 서비스를 사용
    2. 응용 서비스의 결과를 사용자에게 응답할 수 있는 형식으로 변환
3. 사용자 세션 관리
    1. 쿠키나 세션으로 관리되는 사용자 연결 상태를 관리한다.

## 값 검증

---

값 검증은 표현 영역과 응용 서비스 두 곳에서 모두 수행할 수 있다.

원칙적으로는 모든 값에 대한 검증은 응용 서비스에서 처리한다.

표현 영역은 잘못된 값이 존재하면 이를 사용자에게 알려주고 값을 다시 입력받아야 한다.

→ 응용 서비스에서 입력 값을 검증할 경우 Exception을 사용하게 되는데 각 값에 대해서 Exception을 처리하게 되면 사용자에게 안 좋은 경험을 준다.

물론 각 예외를 모아서 사용자에게 던져주는 방법도 있다.

Spring 같은 경우 값 검증을 위한 `Validator` 인터페이스를 제공하기 때문에 이를 구현하여 값 검증을 할 수 있다.

아니면 Spring의 `@valid` 를 통해 요청 값을 검증하는 방법도 존재한다.

표현 영역에서 필수 값과 형식을 검사하게 되면 응용 서비스는 논리적 오류만 검사하면 된다.

→ 표현 영역과 응용 영역이 역할을 나누어 검증 실행

이렇게 나눠서 검증할지, 응용 서비스에서 모두 처리할지는 스스로 잘 판단해서 하면 된다. 

## 권한 검사

---

권한 검사는 사용자 X가 기능 F를 실핼할 수 있는지 확인하는 것이다.

단순한 시스템의 경우 인증 여부만 검사하면 되지만 어떤 시스템은 관리자인지에 따라 사용할 수 있는 기능이 달라지기도 한다.

Spring Security는 다양한 상황에서 유연하고 확장 가능한 권한 검사를 도와주지만 복잡하다.

권한 검사는 세 곳에서 수행할 수 있다.

- 표현 영역
    - 인증된 사용자인지 아닌지 검사하는 것이다.
    - 서블릿 필터, 인터셉터 등으로 만들 수 있다.
    - 스프링 시큐리티는 응용 서비스 계층에서 AOP를 활용한 권한 검사를 실행할 수 있다.
- 응용 서비스
- 도메인

개별 도메인 객체 단위로 권한 검사를 해야 하는 경우는 구현이 복잡해진다.

→ 직접 권한 검사 로직을 구현해야 한다.

https://techblog.woowahan.com/7828/#toc-2

## 조회 전용 기능과 응용 서비스

---

서비스에서 만약 조회만 호출한다면 굳이 서비스를 만들 필요가 없고 표현 영역에서 바로 조회 전용 기능을 사용해도 무방하다.
