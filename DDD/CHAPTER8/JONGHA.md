# 8장 애그리거트 트랜젝션 관리

# 애그리거트와 트랜잭션

- 동시에 같은 애그리거트에 접근하면, 서로 다른 트랜잭션으로 인해, 데이터의 일관성이 깨진다.
- 이를 해결하는 방법은 선점 잠금과 비선점 잠금이 있다. (Pessimistic.Lock, Optimistic Lock)

# 선점 잠금

- 먼저 애그리 거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하지 못한다.
- 즉, 잠금이 해제 될때까지 blocking 한다.
- 선점 잠금은 DBMS가 제공하는 행단위 잠금을 사용해서 구현한다. Oracle을 비롯한 다수의 DBMS가 for update의 쿼리를 사용해서 특정 레코드에 한 커넥션만 접근하도록 한다.
- JPA 에서는 LockModeType.PESSIMISTIC_WRITE를 이용하여 적용 가능
- 문제점 : 사용자 수가 많을 때, 잠금 순서에 따른 교착 상태가 발생할 수 있다.
- 해결법 : 잠금을 구할 때 최대 대기 시간을 지정한다.
- 다음과 같은 힌트를 사용할 수 있다. 힌트를 사용할 때 DBMS 가 관련 기능을 지원하는지 확인하여야 한다.

```java
hints.put("javax.persistence.lock.timeout", 2000);
```

- 스프링 데이터 JPA는 @QueryHints 애너테이션을 사용하여 쿼리 힌트 지정

```java
@QueryHints({
@QueryHint(name = "javax.persistence.lock.timeout", value ="2000")
})
```

- DBMS에 따라 교착 상태에 빠진 커넥션 처리 방식이 다르다. (쿼리 별로, 커넥션 단위로만 대기 시간을 정할 수 있다.)

# 비선점 잠금

- 운영자가 주문 정보 조회하고 고객이 주문 배송을 바꾸고 운영자가 배송 상태 변경 하면 안됨.
    
    → 블로킹이 아닌 예외를 터트려야 함. 
    
    → 비선점 잠금
    
- 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부 확인
- 애그리거트 버전으로 타입 프로퍼티를 추가
    
    ```java
    UPDATE aggregate SET version = version +1, colx= ? , coly = ?
    WHERE aggid = ? and version = 현재 버전
    ```
    
    - 수정에 성공하면 버전 값을 1 증가 시킨다. 만약 다른 트랜잭션이 먼저 수정해서 버전값을 증가시키면 데이터 수정 실패
    - JPA 에서는 `@Version` 애너테이션으로 비선점 잠금 지원
    - 만약 트랜잭션이 충돌 나면, 트랜젝션 종료 시점에 익셉션 발생. (OptimisticLockingFailureException)
    - 애그리거트 버전이 동일한 경우에만 애그리 거트 수정 기능을 수행한다.
- 그리고 응용 서비스가 받는 데이터는 버전값을 포함하여야 한다.
    - 버전 값을 기록하기 위해 프론트에서는 hidden 타입 <input> 태그를 생성하여 폼 전송 시 버전 값이 서버에 함께 전달 되도록 한다.
    - 여러 트랜젝션에서의 전파도 고려해줘야 한다.
    
    ```java
    public class StartShippinRequest {
    	private long version;
    ...
    }
    ```
    
    - VersionConflictException과  OptimisticLockingFailureException
        - 트랜젝션이 다르기 때문에 version이 매치하는지 확인해주는 것도 추가해줘야 한다. (`VersionConflictException`을 뜻한다.)
        - 

### 강제 버전 증가

- 애그리거트 내의 어떤 구성요소 상태가 바뀌면, 루트 애그리거트 버전 값이 증가해야 비선점 잠금이 동작한다.
- 이를 위해, JPA는 find매서드로 엔티티를 구할 때 강제로 버전 값을 증가시키는 잠금 모드를 지원한다. 이는, 루트 엔티티가 아닌 다른 엔티티나 벨류과 변경되더라도, 버전 값을 증가시킨다.
- `LOCKModeType.OPTIMISTIC_FORCE_INCREMENT` : 트랜잭션 종료 시점에 변경 사오간없이, 버전 값 증가 처리를 한다.

# 오프라인 선점 잠금

- 컨플루언스는 충돌 여부를 알려주지만, 동시에 수정하는 것을 막지 않는다.  → 이는 선점과 비선점으로는 해결하지 못한다.
- 여러 트랜젝션에 걸쳐 동시 변경을 막는다. ↔ 단일 트랜젝션에서 동시 변경을 막는다.
- 수정은 폼을 조회하는 과정 그리고, 수정하는 과정으로 두가지 트랜젝션으로 구성된다.
    - 폼을 조회할 떄 잠금 선정, 그리고 수정할 때 잠금해제한다.
    - 만일 수정 요청을 수행하지 않고, 프로그램을 종료하면, 잠금을 해제 못한다. → 잠금 유효기간을 가져야 한다. → 적절한 유효기간이 필요하다.
- 오프라인 선점 잠금은 선점 시도, 잠금 확인, 잠금 해제, 잠금 유효시간 연장등 네가지 기능이 필요하다.
- tryLock(): 잠금을 식별할 때 사용할 lockId 리턴
- checkLock
    - 잠금 유효시간이 지났으면, 이미 다른 사용자가 잠금 선정한다.
    - 잠금을 선점하지 않은 사용자가 기능 실행했다면, 기능 실행을 막아야 한다.
- DB를 이용한 LockManager
- 흠.. 다시 읽자..ㅎㅎ
