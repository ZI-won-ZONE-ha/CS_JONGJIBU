# Chapter 8. 애그리거트 트랜잭션 관리

---

## 애그리거트와 트랜잭션

---

운영자는 배송 상태 변경, 사용자는 배송지 주소 변경이 동시에 발생한다면 어떻게 될까?

둘은 개념적으로는 동일한 애그리거트에 접근하지만 서로 가져오는 객체는 다르기 때문에 동시성 문제가 발생하고 일관성이 깨지게 된다.

→ 서로 각각의 트랜잭션을 커밋하면서 상대의 상태 변경은 무시되기 때문에 애그리거트의 일관성이 깨진다.

이럴 때는 아래의 두 가지 방법 중 하나를 선택해야 한다.

1. 운영자가 배송지 정보를 조회하고 상태 변경하는 동안 유저가 수정하지 못 하게 막는다.
2. 운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면 운영자가 다시 애그리거트를 조회한 뒤 수정하도록 한다.

1번 방식은 비관적 락(선점) 방식이고 2번 방식은 낙관적 락(비선점) 방식이다.

## 비관적 락 (선점 잠금)

---

비관적 락(선점 잠금)은 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하지 못하게 막는 방식이다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/f4b27e3b-ff87-43e5-b504-a44ba73d526f)

이런 식으로 먼저 들어간 스레드가 잠금을 해제하기 전까지 블로킹되는 방식이다.

**이 방법으로 트랜잭션을 관리하게 되면 애그리거트를 수정할 때 발생하는 데이터 충돌 문제를 해소할 수 있다**.

이러한 선점 잠금 방식은 DBMS가 제공하는 ROW 락을 사용하여 구현한다. → `for update`

→ 한 시점에서 하나의 레코드에 하나의 커넥션만 들어갈 수 있게해준다.

### Spring Data JPA에서 비관적 락

Spring Data JPA는 `@Lock(LockModeType.PESSIMISTIC_WRITE)` 를 사용하여 비관적 락을 사용할 수 있다.

### 비관적 락과 교착 상태

**비관적 락을 사용할 때는 락 순서에 따른 교착 상태가 발생하지 않도록 주의해야 한다.**

1. 스레드 a: A 애그리거트에 대한 선점 잠금 구함
2. 스레드 b: B 애그리거트에 대한 선점 잠금 구함
3. 스레드 a: B 애그리거트에 대한 선점 잠금 시도
4. 스레드 b: A 애그리거트에 대한 선점 잠금 시도

이런 순서로 락을 시도한다면 스레드 a와 스레드 b는 서로 요구하는 자원이 맞물려 영원히 선점 잠금을 시도할 수 없게 된다.

이러한 **교착 상태는 상대적으로 사용자 수가 많을 때 발생할 가능성이 높다!**

이런 문제를 피하기 위해 Spring Data JPA에서는

 `@QueryHints({@QueryHint(name = "javax.persistence.lock.timeout", value = 2000)})`

이런 방식으로 비관적 락에 타임 아웃을 두어 영원히 락을 거는 상황을 막을 수 있다.

**주의! 쿼리 힌트가 지원 안되는 DBMS일 수 있다**

## 낙관적 락 (비선점 잠금)

---

비관적 락으로 모든 트랜잭션 충돌 문제가 해결되지 않는다. 아래의 상황을 보자

1. 운영자가 배송을 위해 주문 정보를 조회한다. 시스템은 정보 제공
2. 고객이 배송지 변경을 위해 변경 폼을 요청한다. 시스템은 변경 폼을 제공
3. 고객이 새로운 배송지를 입력하고 폼을 전송하여 배송지를 변경
4. 운영자가 1번에서 조회한 주문 정보를 기준으로 배송지를 정하고 배송 상태 변경을 요청

운영자가 배송지 정보를 조회하고 배송 상태를 변경하는 사이에 고객이 배송지를 변경하는 게 문제이다.

고객이 자신이 원하는 배송지로 물건을 받을 수 없게 된다.

이 문제는 선점 방식으로 해결할 수 없고 비선점 잠금으로 해결할 수 있다.

**낙관적 락은 동시에 접근하는 것을 막지 않고 변경한 데이터가 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식이다.**

→ 애그리거트에 버전으로 사용할 숫자 타입 프로퍼티를 추가해야 한다.

애그리거트를 수정할 때마다 버전으로 사용할 프로퍼티 값이 1씩 증가하는데 이 때 다음과 같은 쿼리를 사용

```sql
update sample set version = version + 1
where pk = ? and version = `현재버전`
```

**버전 값이 바뀌게 되면 다른 트랜잭션이 먼저 해당 데이터를 수정한 상태라는 뜻이므로 데이터 수정에 실패하게 된다.**

### JPA의 낙관적 락

JPA는 버전을 이용한 낙관적 락을 지원한다.

`@Version` annotation을 통해 버전 정보를 관리할 칼럼을 설정할 수 있다.

엔티티가 변경되는 쿼리가 나갈 때 JPA가 알아서 `@Version` 필드에 대한 낙관적 락 쿼리를 진행하게 된다.

이 때 update 쿼리의 결과가 0이면 (버전이 바뀌어 수정되지 않았다면) `OptimisticLockingFailureException` 이 발생한다.

### 폼 데이터에서 버전

유저가 조회한 시점의 version 정보를 html 폼 내부에 숨겨둬야 한다.

→ 중간에 버전이 바뀔 수 있고 이 때 사용자에게 예외를 줘야하기 때문에

```java
@Transactional
public void startShipping(ShippingRequest request) {
	Order order = findOrderById(request.getId());
	if (!order.matchVersion(request.getVersion()) {
		throw new Exception();
	}
}
```

### 강제 버전 증가

**애그리거트에 애그리거트 루트 외에 다른 엔티티가 존재하고 해당 엔티티가 변경될 때 애그리거트 루트 엔티티의 버전을 바꿔줘야 한다.**

하지만 JPA는 애그리거트 루트 엔티티가 변경된 것이 아니기 때문에 버전 정보를 증가시키지 않는다!

→ 강제로 버전을 조정해줘야 한다.

**JPA에서는 이런 문제를 처리할 수 있도록 엔티티를 찾을 때 강제로 버전 정보를 증가시키는 잠금 모드를 지원한다!**

→ `LockModeType.OPTIMISTIC_FORCE_INCREMENT` 

## 오프라인 선점 잠금

---

https://www.baeldung.com/cs/offline-concurrency-control

오프라인 선점 잠금은 여러 트랜잭션에 걸쳐 동시 변경을 막는 방식이다.

첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해제하는 방식이다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/85b38995-1d2c-487b-a322-2e81cce1fea6)


만약 사용자가 오프라인 선점 잠금을 얻고 잠수타버리는 경우에는 잠금이 영원히 해제되지 않는 이슈가 발생할 수 있다.

→ **잠금 유효 시간을 반드시 가져야 한다! + 사용자가 오래 사용하는 경우가 있을 수 있으니 잠금 유효 시간 증가 로직도 필요**

### LockManager 인터페이스

잠금 선점 시도, 잠금 확인, 잠금 해제, 잠금 유효시간 연장 기능이 있는 인터페이스이다.

LockId 클래스를 만들어 고유한 식별자를 가지게 만든다.

구현은 책 265p ~ 268p 참고

### DB를 이용한 LockManager

잠금 정보를 저장할 테이블과 인덱스를 같이 생성하여 사용하면 된다.

구현은 책 268p ~ 273p 참고
