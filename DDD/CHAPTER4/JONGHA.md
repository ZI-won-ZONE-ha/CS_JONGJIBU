## 모듈 위치

- 리포지토리 인터페이스는 도메인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라 스트럭쳐 영역에 속한다.
- 가능하면 리포지터리 구현 클래스를 인프라 스트럭쳐 영역에 위치시켜서 인프라 스트럭쳐에 대한 의존을 낮춤

## 기본 기능 구현

인터페이스는 애그리거트 루트를 기준으로 작성한다. 

- ID 로 애그리 거트 조회
- 애그리거트 저장

```java
public interface OrderRepository {
	Order findById(OrderNo no);
	void save(Order order);
}
```

- 삭제 기능

실제로 삭제하는 경우가 많지 않다. 삭제 플래그를 이용해서, 데이터를 화면에 보여줄지 여부를 결정한다. 

cf) SQL Delete 

[[JPA] soft delete 자동으로 처리하기](https://velog.io/@max9106/JPA-soft-delete)

## 매핑 구현

### 엔티티와 밸류 기본 매핑 구현

- 밸류는 @Embeddable , 밸류 타입 프로퍼티는 @Embedded로 매핑 설정한다.

<aside>
💡 MemberId 클래스에 Serialize 붙이는 이유가 뭘까?

</aside>

- @AttributeOverrtides 애너테이션을 이용하여 칼럼 이름을 매핑되는 테이블 칼럼 이름으로 바꿀 수 있다.

### 기본 생성자

- JPA 에서 @Entity 와 @Embeddable 클래스로 매핑하려면, 기본 생성자를 제공하여야 한다.
    - DB에서 데이터를 읽어와 매핑된 객체를 생성할 때, 기본 생성자를 사용해서 객체를 생성하기 때문이다.

<aside>
💡 그때 면접 공부할 때 우리 여기서 NoArgument 붙여야 하고, 어디서 안붙여도 된다는 부분이 어디었더라? AOP 에서 그랬던거 같은데? 반대로얘는 왜 NoArgument붙여야 했더라?  기본 생성자 어디서는 private 로, 어디서는 protected로 설정하던데 그 이유는 무엇일까????

</aside>

> dto는 리플랙션으로 되서 private으로 해결 가능 반면에, 엔티티는 상속하여 프록시를 만들기 때문에 protected 된다.
> 

> embeddable 도 프록시를 만들어서 해결한다.
> 
- 기본 생성자는 JPA 프로바이더가 객체를 생성할 때만 사용.
    - 엔티티하고 임베더블 할 때 프록시로 만든다는 이야기인가? (찾아보기)
- 기본 생성자를 다른 코드에서 사용하면, 값이 없는 온전하지 못한 객체를 만든다. 따라서 다른 코드에서 이를 사용하지 못하게 하기 위해 `protected`로 선언한다.

### 필드 접근 방식 사용

- **필드**와 메서드 두가지 방식으로 매핑을 처리할 수 있다.
- 메서드 방식을 사용하기 위해선 프로퍼티를 위한 get/set 메서드를 구현하여야 한다.
    - 도메인의 의도가 사라지고, 외부에서 내부를 변경할 수 있어 캡슐화를 깰수 있다.
    - 객체가 제공할 기능 중심으로 엔티티 구현 유도하려면 JPA 매핑 처리를 프로퍼티 방식이 아닌 필드 방식으로 선택하여 불필요한 GET/SET 메서드를 구현하지 말아야 한다.
- 하이버네이트는 @Access를 이용해서 접근방식 지정하지 않을 시, **id나 embeddedId의 위치여부로 접근 방식을 결정한다.**
    - ID나 EmbeddedId가 필드에 위치하면 필드 접근 방식을, get 메서드에 위치하면 메서드 접근 방식을 선택한다.
    - 만약 id가 필드에 위치하더라도, 특정 메서드만 매핑하고 싶을 때에는 해당 메서드에 Access.Property를 해주면 된다. → 이때에도 property 메서드에는 getter/setter를 설정해주어야 한다.
    
    [[JPA] @Id 애노테이션 필드 또는 메서드에 적용시 동작 차이점](https://dololak.tistory.com/425)
    
    [[JAVAEE] 자바빈(JavaBean) 이란? 자바빈 규약에 대해](https://dololak.tistory.com/133)
    

### AttributeConverter를 이용한 밸류 매핑 처리

- 밸류 타입과 칼럼 데이터 간의 변환을 처리하기 위한 기능 정의
- 두 개 이상의 프로퍼티를 가진 밸류 타입을 한 개 칼럼에 매핑할 때 용이하다.
- autoApply 속성을 이용하여, 컨버터를 자동 지정 또는 수동 지정을 정할 수 있다. (기본 값 : false)

### 밸류 컬렉션 : 별도 테이블 매핑

- 벨류 컬렉션을 별도 테이블로 매핑할 때는 @ElementCollection과 @CollectionTable을 함께 사용한다.

```java
@Entity 
public class Order {
	@ElementCollection(fetch = FetchType.EAGER) 
	@CollectionTable(name="order_line", joinColumns = @JoinColumn(name="order_number"))
	@OrderColumn(name = "line_idx") 
}
```

- OrderColumn 은 인덱스 값을 저장하기 위함이고, 따로 OrderLine 클래스에 따로 프로퍼티를 안만든 이유는 List 타입 자체가 인덱스를 갖고 있기 때문에 지정한 칼럼에 리스트의 인덱스 값을 저장한다.
- joinColumn 을 이용해서, 외부키 목록을 지정한다.

<aside>
💡 왜 엔티티로 저장하지 않고, ElementCollection을 이용하지? 
→ 이는, 값타입의 컬렉션을 편리하게 저장할 수 있다는 이점이 있다.

</aside>

[만렙 개발자 키우기](https://www.nowwatersblog.com/jpa/ch14/14-1)

### 벨류 컬렉션 : 한 개 칼럼 매핑

- 새로운 타입 지정 (일급 컬렉션 처럼)
    - AttributeConverter로 변환 작업 진행

```java
public class EmailSet {
	private Set<Email> emails = new HashSet<>();
}

pulic String convertToDatabaseColumn(EmailSet attribute){
	return attribute.getEmails().stream()
	.map(email -> email.getAddress())
	.collect(Collectors.joining(","));
}
```

### 밸류를 이용한 ID 매핑

- 밸류 타입을 식별자로 매핑하면 EmbeddedId 애너테이션을 사용한다.
- JPA 작업에서 식별자 타입은 `Serializable` 이어야 하므로 , 식별자로 사용할 밸류 타입을 Serializable 인터페이스를 상속 받아야 한다.
- 내부적으로 엔티티 비교할 목적으로 equals와 해쉬코드 값을 사용하므로, **식별자를 사용할 밸류 타입은 두 메서드를 알맞게 구현해야한다.**

### 별도 테이블에 저장하는 밸류 매핑

- 애그리거트에서 루트 엔티티를 뺸 나머지 구성요소는 대부분 밸류.
- 엔티티가 확실하다면, 해당 엔티티가 다른 애그리거트가 아닌지 확인해야 한다. → 독자적 라이프 사이클을 갖는다면 구분되는 애그리거트일 가능성이 높다.
- ex) 상품과 리뷰를 보여준다.→ 상품 애그리거트에 리뷰포함되는가? → 함께 생성되고 변경되지 않고, 변경 주체가 다르므로, 다른 애그리거트이다.
- 애그리거트에 속한 객체가 밸류인지 엔티티인지 구분 방법
    - 고유 식별자를 가지는지 ?  매핑되는 테이블의 식별자를 애그리거트 구성요소의 식별자와 동일한 것으로 착각하면 안된다. 테이블에 pk가 있다고 해서 테이블과 매핑되는 애그리거트 구성요소가 항상 고유 식별자를 갖는 것은 아니기 때문.
- 밸류를 매핑한 테이블을 지정하는 방법
    - @SecondaryTable: 테이블을 조인해서 데이터를 조회한다. → 이 방식 이용하여, 카테고리 리팩토링 해야 겠다.
    - @AttributeOverride를 사용 : 벨류 데이터가 저장된 테이블 이름 지정.
    

### 밸류 컬렉션을 @Entity로 매핑하기

- 상속 구조로 인해 @Embeddable 대신 @Entity를 이용해서 상속 매핑으로 처리.
    - 식별자 매핑을 위한 필드
    - 구현 클래스 구분을 위한 타입 식별 칼럼 추가.
    - 상속 : inheritance, strategy=Single_table, DiscriminatorColmn 애너테이션 타입 구분용
    - 상속 받은 클래스는 @Entity와 @Discriminator를 이용하여 매핑을 설정
- 밸류는 독자적인 라이프 사이클 갖지 않으므로, cascade 속성을 지정한다. orphanRemoval도 true로!
    - Entity 삭제 할 때 clear는 select 하고 각각 삭제하므로, 성능상 문제가 있다.
    - 반면에 Embeddable 타입에서 컬렉션clear 하게 되면 객체를 로딩하지 않고, 한번의 delete 쿼리로 삭제 처릴 진행.
    - → 유지 보수와 성능의 두가지 측면 고려해야함.

### ID 참조와 조인 테이블을 이용한 단방향 M-N 매핑

- 애그리거트 간 집합 연관 성능상의 이유로 피해야한다.
- 하지만, 집합 연관을 사용하는게 요구사항을 구현할 떄 유리하면, id 참조를 이용한 단방향 집합 연관을 적용
    - 집합의 값에 밸류 대신 연관을 맺는 식별자가 온다.
- @ElementCollection을 이용하기 때문에 Product를 삭제할 때 매핑에 사용한 조인 테이블의 데이터도 삭제된다.
    - id 방식 참조를 이용해, 영속성 전파 또는 로딩 전략 고민안해도 된다.

# 애그리거트 로딩 전략

- 애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다.
- 애그리거트 루트에서 연관 매핑 조회 방식을 즉시 로딩으로 설정하면, 항상 좋은 것이 아님.
    - 엔티티, 컬렉션 즉시 로딩 시, 쿼리 결과에 중복을 발생
    - 조회 성능 문제 때문에, 즉시 로딩 방식을 사용하지만  성능(실행 빈도, 트래픽, 지연로딩 시 실행속도)등을 검토하여야 한다.
- 애그리거트는 개념적으로 하나여야 하지만, 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 모든 객체를 로딩하여야 하는 것은 아니다.
- 애그리거트 완전해야 하는 이유
    - 상태를 변경하는 기능을 실행할 떄,  애그리거트 상태가 완전해야한다. → 이거와 더 연관이 있다.
    - 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요. → 이는 조회 전용 기능과 모델을 구현하는 방식을 사용하는 것이 더 유리하다.

→ 상태 변경은 상태를 변경하는 시점에 필요한 구성요소만 로딩해도 된다. → 지연로딩

- 애그리거트에 맞게 즉시로딩과 지연로딩을 선택한다.
    - 지연로딩은 (entity와 embeddable 에 대해 다르게 동작하고, jpa 프로바이더에 따라 구현 방식이 다를 수 있는) 즉시로딩과 달리 동작방식 항상 동일
    - 하지만, 지연로딩은 즉시 로딩보다 쿼리 실행 횟수 많아질 가능성 높다.

# 애그리거트의 영속성 전파

- 애그리거트는 완전한 상태이다. → 조회 뿐 아니라 저장 또는 삭제 일때도 하나로 처리하여야 한다.
    - 저장 : 애그리 루트만 저장하면 안되고 애그리거트에 속한 모든객체 저장
    - 삭제 메서드는 애그리거트 루트 뿐만 아니라 애그리 거트에 속한 모든 객체 삭제해야 한다.
- @Embeddable 매핑 타입은 함께 저장되고 삭제 → cascade 속성을 따로 추가하지 않아도 된다.
- @Entity는 cascade 속성 사용하여 저장, 삭제시 함께 처리해야함.
    - oneToOne, OneToMany는 따로 cascade 속성 값으로 설정해야 함.

# 식별자 생성 기능

- 사용자 직접 생성
- 도메인 로직으로 생성
    - 식별자를 `별도 서비스`로 식별자 생성 기능을 분리하여야 함.
    - 식별자 생성 규칙은 도메인 규칙으로, 도메인 영역에 식별자 생성기능을 위치시킴
    - 응용서비스는 이 도메인 서비스를 이용해 식별자 구하고 엔티티 생성
    
    ```java
    public class ProductIdService {
    	public ProductId nextId() {
    	// 정해진 규칙으로 식별자 생성 
    	}
    }
    ```
    
    - 식별자 생성 기능을 리포지터리에 넣을 수도 있다.  인터페이스에 추가, 구현클래스에서 구현한다.
- DB를 이용한 일련 번호 사용
    - GeneratedValue 사용
    - 도메인 객체를 저장한 뒤에 식별자를 구할 수 있다.
    - 다른 JPA 식별자 생성 기능을 사용하는 경우도, 저장시점에 식별자 생성

# 도메인 구현과 DIP

- 리포지터리 DIP 원칙을 어기고 있다.
    - 도메인 모델이 영속성 구현 기술인 JPA를 의존
    - 리포지터리 인터페이스 또한 스프링 데이터 JPA 레포지터리 인터페이스를 상속한다. → 도메인이 인프라에 의존한다.
- DIP 사용 주된 이유
    - 저수준 구현이 바뀌더라도, 고수준이 영향 받지 않도록 하기 위함.
        - 변경이 거의 없는 상황에서 변경을 미리 대비하는 것은 과하다. (필자 생각)
- 나아가야 할 방향 : DIP를 지킬 떄 개발의 편의성, 실용성을 생각해야함.
