- 표현, 응용, 도메인, 인프라 스트럭쳐로 되어있다.

# 영역

## 표현

사용자의 요청을 받아 응용 영역에 전달, 그리고 처리 결과를 다시 사용자에게 보여준다. 

사용자는 웹 브라우저를 사용하는 사람일 수도, api 를 호출하는 외부 시스템일 수도 있다. 

## 응용

시스템이 사용자에게 제공해야할 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용한다. 로직을 직접 수행하기 보다, 도메인 모델에 로직 수행을 위임한다.  

## 도메인

도메인 모델은 도메인의 핵심 로직을 구현. 

## 인프라 스트럭쳐

구현 기술에 대한 것을 다룬다. ex) RDBMS 연동 메세징 큐, 몽고 DB, redis 데이터 연동 처리, SMTP, Http 클라이언트를 이용한 Rest API 호출 처리. 논리적인 개념 표현 보다는 실제 구현 다룬다. 

도메인, 응용, 표현 영역은 인프라영역에서 제공하는 기능을 사용해 필요한 기능을 개발.  

# 계층 구조 아키텍쳐

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ae1e2bd9-0e4c-4ad2-b116-2da18850663a/2c174f18-06b0-41a3-b4ac-7e0f28e9729e/Untitled.png)

- 표현 영역, 응용 영역 → 도메인 영역 사용 하고, 도메인 영역은 인프라 스트럭쳐를 사용한다.
- 상위 계층에서 하위 계층으로의 의존만 존재하고, 하위 계층은 상위 계층에 의존하지 않는다.
- 인프라 스트럭쳐에 의존하면, 테스트 어려움과 기능확장의 어려움 두가지 문제가 발생한다.

# DIP

- 고수준 모듈 : 의미있는 단일 기능을 제공하는 모듈 ( ex) CalculateDiscountService)
- 저수준 모듈 : 하위 기능을 실제로 구현한 것 (ex) 고객정보 읽어오기, 룰 실행하는 모듈)
- **고수준 모듈이 저수준 모듈을 사용하면, 구현 변경과 테스트가 어렵다는 문제 발생 → DIP 는 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다.   → interface 사용**
- **DIP : 의존 역전 원칙 → 저수준 모듈이 고수준 모듈을 의존한다.**
    - 장점 : 테스트는  고수준을 대역 객체를 생성하여 테스트 한다. 실제 구현 대신 스텁이나 모의 객체와 같은 테스트 목적의 대역을 사용하여, 거의 모든 상황을 테스트 할 수 있다.
    

## DIP 주의 사항

- 인터페이스와 구현 클래스 분리하는 정도가 아님
- DIP 의 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하는 것!
- 잘못된 예시 : RuleEngine 인터페이스는 고수준 모듈인 도메인 관점이 아니라, 룰 엔진이라는 저수준 모듈 관점에서 도출된다.
- 인터페이스는 고수준 모듈관점에서 도출해야 한다. ex) 할인 금액을 구하기 위해 룰 엔진 사용하는지, 직접 연산하는 지는 중요하지 않다. 단지 규칙에 따라 할인 금액을 계산하는 것이 중요하다.

### DIP와 아키텍쳐

- 인프라 영역은 저수준 모듈, 응용과 도메인은 고수준 모듈
- 아키텍쳐에 DIP를 적용하면, 인프라 스트럭쳐 영역이 응용과 도메인 의존하는 구조가 된다.
- DIP 를 적용하면 응용 영역과 도메임 영역에 영향 최소화 하며 구현체를 변경하거나 추가할 수 있다.

# 도메인 영역의 주요 구성 요소

## 엔**티티**

고유의 식별자를 갖는 객체로 자신의 라이프사이클을 갖는다. 도메인의 고유한 개념을 표현하며 해당 데이터와 관련된 기능을 함께 제공한다.

## **밸류**

고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나인 도메인 객체의 속성을 표현할 때 사용된다.

## **애그리거트**

애그리거트는 관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다. 예를 들어 주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 '주문' 애그리거트로 묶을 수 있다.

## **리포지터리**

도메인 모델의 영속성을 처리한다.

## **도메인 서비스**

특정 엔티티에 속하지 않은 도메인 로직을 제공한다. '할인 금액 계산'은 상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 이용해서 구현하게 되는데, 이렇게 도메인 로직이 여러 엔티티와 밸류를 필요로 할 경우 도메인 서비스에서 로직을 구혀한다.

## 엔티티와 밸류

- DB 엔티티와 도메인 엔티티는 다르다.
    - 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 제공한다. . 데이터를 담고 있는 데이터 구조라기 보다, 데이터와 함께 기능을 제공한다.
    - 도메인 모델의 엔티티는 밸류 타입을 이용하여 표현 가능하다. 반면에 DB 엔티티는 밸류 타입을 제대로 표현하기 힘들다.

## 애그리거트

- 도메인이 커질수록 도메인 모델도 커진다. 모델의 구성요소가 복잡해진다.
- 도메인 모델을 개별 객체 뿐만 아니라, 상위 수준에서 모델을 볼 수 있어야 전체 모델의 관계와 개별 모델을 이해할 수 있다.  ⇒ Aggregate
- 애그리거트 : 관련 객체를 하나로 묶은 군집
    - 장점 : 개별 객체가 아닌 관련 객체를 묶어서 객체 군집 단위로 모델을 이해하고 구현하게 되며, 큰틀에서 도메인 모델을 관리할 수 있다.
    - 방법 : 군집에 속한 객체를 관리하는 루트 앤티티를 찾는다. 애그리거트를 사용하는 코드는 루트의 기능을 실행하고, 루트를 통해 간접적으로 애그리커드 내의 다른 엔티티나 밸류 객체에 접근하도록 한다. (애그리거트 단위로 구현을 캡슐화한다.)
- 고려 사항
    - 어떻게 구성했느냐에 따라 트랜젝션 범위, 구현 복잡도 달라진다.
    - 선택한 구현 기술에 따라 애그리거트 구현에 제약이 생기기도 한다.

## 레포지토리

- 도메인 객체를 물리적으로 저장하는 저장소
- 리포지터리는 구현을 위한 도메인 모델 ↔ 엔티티와 밸류 (요구사항에서 도출되는 도메인 모델)
- 대상을 찾고 저장하는 단위가 애그리거트의 루트이다.
- 도메인 객체를 영속화 하는 데 필요한 기능을 추상화 한것으로 고수준 모듈아이다.
- 레포지토리 인터페이스는 도메인 모델 영역에 속하며, 실제 구현 클래스는 인프라영역에 속한다.

# 인프라 스트럭쳐

- 무조건 인프라 스트럭처에 대한 의존을 없앨 필요는 없다. (ex) transactional, jpa 와 같이)
- ex) jpa 전용 어노테이션을 도메인 모델 클래스에 사용
- 구현의 편리함과, DIP과 주는 다른 장점 고려 → DIP의 장점을 해치지 않는 범위에서, 응용 영역과 도메인 영역에서 구현 기술에 대한 의존 가져간다.
- 표현 영역은 항상 인프라 스트럭쳐 영역과 쌍을 이룬다.

# 참고 자료

[2장 아키텍처 개요](https://incheol-jung.gitbook.io/docs/study/ddd-start/2#undefined-2)
