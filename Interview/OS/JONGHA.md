
# 운영체제와 시스템 콜
### 운영체제란 무엇인지 설명해 주세요.

**운영체제의 역할**

컴퓨터 시스템의 자원을 효율적으로 관리하며, 그에 대한 역할은 리소스 매니저(효율적 관리), 가상화, concurrency를 해결한다. persistence를 가능하게 한다. 

### Process와 Thread의 차이를 설명해 주세요.

**프로세스** : 프로그램을 메모리 상에서 실행중인 작업

**스레드** : 프로세스 안에서 실행되는 작업의 단위 

프로세스 내에 여러 쓰레드 할당할 수 있다. 하나의 프로세스가 생성될 때, 기본적으로 하나의 스레드 같이 생성

**프로세스는 자신만의 고유 공간과 자원을 할당받아 사용**하는데 반해, **스레드는 다른 스레드와 공간, 자원을 공유하면서 사용**하는 차이가 존재함. 스레드는 Stack만 따로 할당 받고 나머지 영역은 서로 공유

**프로세스 메모리 구조**

- **Code** : 코드 자체를 구성하는 메모리 영역(프로그램 명령)
- **Data** : 전역변수, 정적변수, 배열 등
    - 초기화 된 데이터는 data 영역에 저장
    - 초기화 되지 않은 데이터는 bss 영역에 저장
- **Heap** : 동적 할당 시 사용 (new(), malloc() 등)
- **Stack** : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)

### Context Switching은 무엇인지 설명해 주세요.

CPU가 현재 작업 중인 프로세스에서 다른 프로세스로 넘어갈 때 지금까지의 프로세스의 상태를 저장하고, 새 프로세스의 저장된 상태를 다시 적재하는 작업을 Context Switch(문맥 교환)이라 한다. (프로세스의 정보는 PCB에 저장된다.)

### **언제 발생하는가?**

Context Switch가 발생하는 경우는 멀티태스킹, 인터럽트 핸들링, 사용자 모드와 커널 모드 간의 전환까지, 크게 3가지가 존재한다.

- 멀티태스킹(Multitasking)
    - 실행 가능한 프로세스들이 운영체제의 스케줄러에 의해 조금씩 번갈아가며 수행되는 것을 말한다.
    - 번갈아 가며 프로세스가 CPU를 할당 받는데 이때 Context Switching 한다.
    - 사용자가 체감하기 힘든 속도로 Context Switching되며 프로세스가 처리되기 때문에 동시에 처리되는 것처럼 느껴진다.
- 인터럽트 핸들링(Interrupt handling)
    - 인터럽트란 컴퓨터 시스템에서 예외 상황이 발생했을때 CPU에게 알려 처리할 수 있도록 하는 것을 말한다.
    - 인터럽트가 발생하면 Context Switching한다.
    - I/O request : 입출력 요청
    - time slice expired : CPU 사용시간이 만료
    - fork a child : 자식 프로세스 생성
    - wait for an interrupt : 인터럽트 처리 대기
- 사용자와 커널 모드 전환(User and kernel mode switching)
    - 사용자와 커널 모드 전환은 Context Switch가 필수는 아니지만 운영체제에 따라 발생할수 있다

### **Context Switching 과정**
1. 요청 발생: 인터럽트 또는 트랩에 의한 요청이 발생.(트랩은 소프트웨어 인터럽트)
2. PCB에 저장: 운영체제는 현재 실행중인 프로세스(P0)의 정보를 PCB에 저장.
3. CPU 할당: 운영체제는 다음 프로세스(P1)의 정보를 PCB에서 가져와 CPU를 할당.

위 과정을 반복적으로 수행한다. Context Switching하는 동안 CPU는 아무일도 하지않는 시간이 발생하는데 이를 오버헤드(Overhead)라 하고 오버헤드가 잦아지면 성능이 떨어질수 있다.

### PCB 과 뭔가요?

모든 프로세스가 생성이 되면, 해당 프로세스의 중요한 정보를 담고 있는 자료 구조가 생기는 데 이를 PCB라고 한다. Program counter, register, open file 에 대한 정보를 가지고 있다.  → 이는 커널의 데이터 구조에 생긴다.  

### **PCB가 왜 필요한가요?**

CPU에서는 프로세스의 상태에 따라 교체작업이 이루어진다. (interrupt가 발생해서 할당받은 프로세스가 waiting 상태가 되고 다른 프로세스를 running으로 바꿔 올릴 때) 이때, **앞으로 다시 수행할 대기 중인 프로세스에 관한 저장 값을 PCB에 저장해두는 것**이다.

### **PCB는 어떻게 관리되나요?**

Linked List 방식으로 관리된다.

PCB List Head에 PCB들이 생성될 때마다 붙게 된다. 주소값으로 연결이 이루어져 있는 연결리스트이기 때문에 삽입 삭제가 용이하다.

즉, 프로세스가 생성되면 해당 PCB가 생성되고 프로세스 완료 시 제거된다.

이렇게 수행 중인 프로세스를 변경할 때, CPU의 레지스터 정보가 변경되는 것을 Context Switching이라고 한다.

### 멀티 프로세스와 멀티 쓰레드 차이를 설명해 주세요.

### **멀티프로세스**

> 하나의 프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 병렬적으로 작업을 수행하는 것

**장점** : 안전성 (메모리 침범 문제를 OS 차원에서 해결)

**단점** : 각각 독립된 메모리 영역을 갖고 있어, 작업량 많을 수록 오버헤드 발생. Context Switching으로 인한 성능 저하

### **멀티 스레드**

> 하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것
> 

스레드들이 공유 메모리를 통해 다수의 작업을 동시에 처리하도록 해줌

**장점** : 독립적인 프로세스에 비해 공유 메모리만큼의 시간, 자원 손실이 감소 전역 변수와 정적 변수에 대한 자료 공유 가능

**단점** : 안전성 문제. 하나의 스레드가 데이터 공간 망가뜨리면, 모든 스레드가 작동 불능 상태 (공유 메모리를 갖기 때문) → 멀티스레드의 안전성에 대한 단점은 Critical Section 기법을 통해 대비함

### 동시성 - Concurrent vs Parallel

- **Concurrent** : 어떤 Job 여러 개가 동시에 처리된다는 개념 (멀티)
- **Parallel** : 어떤 하나의 Job을 쪼개서 여러 sub-job으로 나누고, 이를 물리적으로 분리된 구조에서 동시에 처리해서 완성하는 개념 (자동차 조립을 여러 사람이 동시에 하는 것, CPU의 Core 여러 개 표현)

따라서 parallelism 없이 concurrency를 가지는 것이 가능하다.

멀티 프로세서나 멀티 코어 구조가 발전하기 전에는 싱글 프로세서로 재빠르게 프로세스를 전환하여 concurrent하게 동작하지만 parallel하게 동작하는 것처럼 보이도록 하였다.

### 인터럽트(Interrupt)가 무엇인가요?

프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것. 즉 그러면 context switch 가 일어난다. 

지금 수행 중인 일보다 더 중요한 일(ex. 입출력, 우선 순위 연산 등)이 발생하면 그 일을 먼저 처리하고 나서 하던 일을 계속해야한다.

외부/내부 인터럽트는 CPU의 하드웨어 신호에 의해 발생, 소프트웨어 인터럽트는 명령어의 수행에 의해 발생

- **외부 인터럽트**
    
    입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 발생
    
    전원 이상, 기계 착오, 외부 신호, 입출력
    
- **내부 인터럽트**
    
    Trap이라고 부르며, 잘못된 명령이나 데이터를 사용할 때 발생
    
    > 0으로 나누기가 발생, 오버플로우, 명령어를 잘못 사용한 경우 (Exception)
    > 
- **소프트웨어 인터럽트**
    
    프로그램 처리 중 명령의 요청에 의해 발생한 것 (SVC 인터럽트)
    
    > 사용자가 프로그램을 실행시킬 때 발생
    > 
    > 
    > 소프트웨어 이용 중에 다른 프로세스를 실행시키면 시분할 처리를 위해 자원 할당 동작이 수행된다.
    > 

### 인터럽트 발생 시 처리 과정을 설명해 주세요.

인터룹트는 먼저 처리 되야되는 급한일이라고 생각하면 된다.  즉 그러면 컨텍스트 스위칭이 일어난다. 
1. 주 프로그램이 실행되다가 인터럽트가 발생했다.
2. 현재 수행 중인 프로그램을 멈추고, 상태 레지스터와 PC 등을 스택에 잠시 저장한 뒤에 인터럽트 서비스 루틴으로 간다. (잠시 저장하는 이유는, 인터럽트 서비스 루틴이 끝난 뒤 다시 원래 작업으로 돌아와야 하기 때문) 이는 커널에 저장이 된다.
3. 만약 **인터럽트 기능이 없었다면**, 컨트롤러는 특정한 어떤 일을 할 시기를 알기 위해 계속 체크를 해야 한다. (이를 폴링(Polling)이라고 한다. **폴링**을 하는 시간에는 원래 하던 일에 집중할 수가 없게 되어 많은 기능을 제대로 수행하지 못하는 단점이 있었다.)

### 데드락이 무엇인가요?

두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태

무한히 다음 자원을 기다리게 되는 상태를 말한다.

### 데드락 발생조건 4가지를 설명해 주세요.

1. **상호 배제(Mutual exclusion)**
    
    > 자원은 한번에 한 프로세스만 사용할 수 있음
    > 
2. **점유 대기(Hold and wait)**
    
    > 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함
    > 
3. **비선점(No preemption)**
    
    > 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
    > 
4. **순환 대기(Circular wait)**
    
    > 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함
    > 

### 데드락의 해결방법에 대해서 설명해 주세요.

**예방**은 데드락 발생 필요 조건 중 어느 하나가 만족되지 않도록 하는 것이다. 가장 많이 사용하는 것은 순환 대기 조건을 만족시키지 않는 것이다. 

- 참고
    
    교착 상태 발생 조건 중 하나를 제거하면서 해결한다 (자원 낭비 엄청 심함)
    
    상호배제 부정 : 여러 프로세스가 공유 자원 사용
    
    점유대기 부정 : 프로세스 실행전 모든 자원을 할당
    
    비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납
    
    순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구
    

**회피**는 실행환경에서 자원 요청에 대한 부가적인 정보를 이용해서 Deadlock의 가능성이 없는 경우에만 자원을 할당하는 것이다.  (*부가적인 정보 : 현재 사용 가능한 자원, 이미 할당된 자원, 앞으로 있을 자원 요청이나 반환 등*)

**탐지(Detection)**

자원 할당 그래프를 통해 교착 상태를 탐지함

자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함

**회복(Recovery)**

교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법

> 프로세스 종료 방법
> 
> - 교착 상태의 프로세스를 모두 중지
> - 교착 상태가 제거될 때까지 하나씩 프로세스 중지
> 
> **자원 선점 방법**
> 
> - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시킴)
> - 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점

### Race Condition은 무엇일까요?

공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태. 동시 접근 시 자료의 일관성을 해치는 결과가 나타남

### Race Condition(경쟁 상태)에 대하여 간단한 예시를 들어 설명해 주세요.

1. **커널 작업을 수행하는 중에 인터럽트 발생**
    - 문제점 : 커널모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우
    - 해결법 : 커널모드에서 작업을 수행하는 동안, 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하도록 한다.
2. **프로세스가 'System Call'을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때**
    - 문제점 : 프로세스1이 커널모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우 ( 프로세스2가 작업에 반영되지 않음 )
    - 해결법 : 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함
3. **멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때**
    - 문제점 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
    - 해결법 : 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 하는 방법

### 프로세스가 도중에 중지되는 경우, 그 원인과 다시 실행할 수 있는 방법은 무엇일까요?

- 인터럽트 혹은 시스템 콜 등에 의해 프로세스가 중지될 수 있다.
- 아니면 선점 방식의 스케줄링의 경우, 타임 퀀텀이 지나게 되면 중지가 될것이다.
- 다시 실행할 수 있는 방법
    - PCB 안에 해당 프로세스의 정보가 저장되어 있기 때문에 추후에 실행 가능한 상태가 되면 PCB를 통해 다시 실행할 수 있다.

### 스레딩과 멀티스레딩에 대해 설명해 주세요

- **스레드** : 할당 받은 자원을 이용한 프로세스의 실행 흐름의 단위이다.
- **멀티 스레드** : 한 프로세스 내에서 이러한 스레드가 여러 개 동작하는 방식을 의미한다.
- 멀티스레드의 장점 : 프로세스를 여러개 두는 방식에 비해 컨텍스트 스위칭 비용이 적게 들며 응답 시간이 빠르다는 장점이 있다.
- 멀티스레드의 단점 : 같은 프로세스 내의 자원을 다른 스레드들과 공유하므로 동기화 문제를 고려해야 한다. 또한 프로세스가 종료되면 내부 스레드들 역시 모두 종료되므로 한 스레드가 프로세스를 의도치 않게 종료했을 경우 나머지 스레드들도 모두 종료될 수 있다는 단점이 있다.
****

### Thread Safe이 무엇인지 설명해 주세요.

- 멀티 쓰레드 또는 멀티 프로세스 상에서, 동기화가 이루어지는 것.
- 공유되는 자원이 동시성으로 인한 변함 없음을 보장. 멀티 스레드 환경에서 여러 스레드가 동시에 공유 자원에 접근할 때, 의도한대로 동작하는 것을 말합니다.
- Thread-safe하기 위해서는 공유 자원에 접근하는 임계 영역을 Mutex, Semaphore 등의 동기화 기법으로 제어해줘야 합니다.

### 운영체제의 Dual Mode 에 대해 설명해 주세요, 커널의 역할이 무엇인지 설명해 주세요.

- 이중 동작 모드(Dual Mode Operation)은 OS가 이상한 프로그램(Application faults)으로 인해 잘못 동작하거나 망가지지 않게 하는 아주 중요한 핵심 동작 원리입니다.
- '듀얼'이라는 말처럼 OS는 User mode와 Kernel mode 두 가지 모드를 두고 동작하는데요. 유저모드에서는 어플리케이션이 동작하고 사용자가 컴퓨터와 상호작용하는 등의 일이 이루어집니다. 반면, 커널모드에서는 드라이버, CPU, 메모리 등에 접근하고 명령을 내리며 이러한 작업들이 이루어지기 위한 근본적인 작업들을 처리하죠.
- 이 때, 특정한 권한 명령(Privileged Instruction)들은 무조건 커널 모드에서만 수행되어야 합니다. 유저 마음대로 OS의 작동을 좌지우지 할 수 있다면 하드웨어 장치나 메모리가 오동작하거나 심지어는 공격을 받을 수 있기 때문이죠. 특권 명령에는 인터럽트 핸들링, 사용자 모드에서 커널 모드로 전환, 입출력 관리 등이 있다.
- 그러면 언제/어떻게 유저모드에서 커널모드로 전환될까요? 바로 위에서 살펴본 인터럽트(Interrupt)가 발생할 때입니다. 그리고 인터럽트는 유저가 적절한 시스템 콜을 통해서 OS에게 커널 모드로 가서 요청한 작업을 해달라는 메시지를 보낼 때 발생하게 되죠.

### 시스템 콜에 대해 설명해 주세요.

시스템 호출(system call)은 운영 체제의 커널이 제공하는 서비스에 대해, 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스이다.

프로세스 제어, 파일 조작, 디바이스 조작, 정보 유지, 통신, 보호가 있다.

****Q. 시스템 콜은 왜 필요할까요****

우리가 일반적으로 사용하는 프로그램은 '응용프로그램'이다.

유저레벨의 함수만으로는 많은 기능을 구현하기 힘들다. 따라서 커널의 도움이 필요하다.

**커널(kernel)에 관련된 것은 커널 모드로 전환한 후에야, 해당 작업을 수행할 권한이 생긴다.**

### **Q. 서로 다른 시스템 콜을 어떻게 구분하는지 설명해 주세요**

- 커널은 내부적으로 각각의 시스템 콜을 구분하기 위해 **기능별로 고유번호를 할당**하고 그 번호에 해당하는 제어루틴을 커널 내부에 정의
- 커널은 요청받은 시스템 콜에 대응하는 **기능번호를 확인 -> 그에 맞는 서비스 루틴 호출**

### 임계영역이 만족해야 하는 조건이 있나요? 임계 영역을 프로세스들이 같이 쓸 수 있는 전제 조건을 설명해주세요.

공유 데이터의 일관성을 보장하기 위해 하나의 프로세스/스레드만 진입해서 실행(mutual exclusion) 가능한 영역

- **mutual exclusion** (상호 배제)
    - 한 번에 하나의 프로세스/스레드가 critical section에서 실행할 수 있다.
- **progress** (진행)
    - 아무도 critical section에 있지 않을 때, 들어가고자 하는 프로세스가 있으면 critical section에 들어가게 해주어야 한다.
- **bounded waiting** (한정된 대기)
    - 하나의 프로세스/스레드가 critical section에 들어가기 위해서 무한정 기다리는 상황이 되면 안된다.
    - 다른 프로세스들의 기아(Starvation)을 막기 위해서

# 스케쥴링

### CPU 스케줄링의 목적은 무엇인가요?

프로세스 스케줄러는 **멀티 프로그래밍**과 **time sharing**의 목적을 달성하기 위해 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택해 실행한다. 

각 CPU 코어는 한번에 한 프로세스를 실행할 수 있다. 단일 CPU 코어 시스템에 반해 멀티 코어 시스템은 한 번에 여러 프로세스를 실행할 수 있다. 즉 이를 통해 컴퓨터 자원을 효율적으로 사용하게 한다. 

- 멀티 프로그래밍 (multiprogramming) : CPU 사용률을 최대화하기 위해 항상 프로세스를 실행하도록 한다. 어떤 프로세스가 CPU를 사용하다가 I/O 작업 등 CPU를 필요로 하지 않는 순간이 오면 다른 프로세스가 CPU를 사용할 수 있도록 한다.
    - CPU는 I/O burst 와 CPU burst를 연속적으로 반복하게 된다.
        - I/O burst: I/O 작업을 기다리는 시간
        - CPU burst: instruction 수행 시간
    - I/O burst 의 발생이 잦아지면서 CPU burst 가 짧아지게 되면서 CPU 효율성을 위해 스케줄링이 필요
    - CPU 와 I/O 장치 등 시스템 자원을 골고루 효율적으로 사용할 수 있음
    - 프로세스는 특성에 따라 다음 두 가지로 나눔
        - 1.I/O-bound process : CPU를 잡고 계산하는 시간보다 I/O에 많은 시간이 필요한 job (대부분 CPU burst가 매우 짧음)
        - 2.CPU-bound process : 계산 위주의 job(보통 CPU burst가 매우 긺)
- 시분할 (time sharing) : 각 프로그램이 실행되는 동안 사용자들이 상호작용할 수 있도록 프로세스 간 CPU 코어를 자주 전환하는 것이다. CPU가 하나의 프로그램을 수행하는 시간을 매우 짧은 시간(ms)으로 제한하여 프로그램을 번갈아 수행하도록 하면 CPU가 하나인 환경에서도 여러 사용자가 동시에 사용하는 듯한 효과를 가져올 수 있다.

### CPU 선점 방식과 비선점 방식의 차이점. 각 방식의 대표적인 알고리즘 이름

**선점 / 비선점 스케줄링**

- 선점 (preemptive) : OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우 (처리시간 예측 어려움)
- 비선점 (nonpreemptive) : 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장 (처리시간 예측 용이함)

### FCFS (First-Come, First-Served) Scheduling
- **비선점 스케줄링**
- 먼저 CPU를 요청하는 프로세스에 먼저 CPU가 할당된다.
- FIFO queue 를 사용해 쉽게 구현할 수 있다.
- 문제점) **convoy effect** : 먼저 들어온 어떤 프로세스의 CPU 처리 시간이 길 경우 다른 모든 프로세스들이 기다림으로서 더 짧은 프로세스가 먼저 진행될 수 있는 경우보다 CPU 및 장치 사용률이 낮아지는 현상

### SJF (Shortest-Job-First) Scheduling
- **비선점 스케줄링 방식** : CPU burst time이 가장 작은 프로세스에게 먼저 CPU를 할당한다. 만일 CPU burst time이 같다면, FCFS 방식을 적용한다.
- **선점 스케줄링 방식 (SRTF (Shortest-Remaining-Time-First) Scheduling)** : 새로 들어온 프로세스의 CPU burst time이 현재 실행 중인 프로세스의 남은 burst time 보다 작다면 현재 실행 중인 프로세스를 새로 들어온 프로세스가 선점한다.
- Priority Scheduling의 한 예이다. (우선순위 = CPU burst time)
- 주어진 프로세스 집합에 대해 **최소 평균 대기 시간**을 제공한다는 점에서 최적의 알고리즘이다. 하지만 CPU burst time을 알 수 있는 방법이 없기 때문에 CPU 스케줄링 수준에서 구현할 수 없다. 이에 대한 한 가지 접근 방식은 SJF 스케줄링을 근사화하는 것이며, 이전 CPU burst time 지수 평균으로 예측할 수 있다.
- 문제점) **starvation** : CPU 처리 시간이 긴 프로세스는 계속 Ready Queue의 뒤로 밀려나기 때문에 무한정 기다리는 상황이 발생할 수 있다.
- FCFS 보다 평균 대기 시간 감소, 짧은 작업에 유리
- HRN (Hightest Response-ratio Next)
    - 우선순위를 계산하여 점유 불평등을 보완한 방법(SJF의 단점 보완)
    - 우선순위 = (대기시간 + 실행시간) / (실행시간)

### RR (Round-Robin) Scheduling
- **선점 스케줄링**
- FCFS에 의해 프로세스들이 보내지면 각 프로세스는 동일한 시간의 `Time Quantum` 만큼 CPU를 할달 받음
    - `Time Quantum` or `Time Slice` : 실행의 최소 단위 시간
- 할당 시간(`Time Quantum`)이 크면 FCFS와 같게 되고, 작으면 문맥 교환 (Context Switching) 잦아져서 오버헤드 증가
- 각 프로세스는 **time quantum (or time slice)** 이라는 작은 시간 단위(10-100ms)를 갖게 된다. 프로세스는 1 time quantum 동안 스케줄러에 의해 CPU를 할당 받고, 시간이 끝나면 interrupt를 받아 Ready Queue의 tail에 배치된다.
- Ready Queue는 Circular FIFO queue 형태이다.
- RR의 평균 대기 시간은 긴 편이다. 하지만 공정하다. `n`개의 프로세스가 있고 time quantum이 `q`일 때, 어떤 프로세스도 `(n-1) x q` 시간 단위 이상 기다리지 않는다.

**Time quantum 설정 시 주의할 점**

- Time quantum이 너무 크다면 : FCFS와 같아진다.
- Time quantum이 너무 작다면 : Context Switching이 너무 빈번하게 일어나 overhead가 발생한다.

위와 같이 RR 알고리즘의 성능은 time quantum의 크기에 좌우될 수 있으므로 적절히 선정해야 하며 이는 context-switch time보다 큰 것이 좋지만 또 너무 커서는 안 된다. (경험적으로 CPU burst의 80프로는 time quantum보다 짧은게 좋다고 함)

### Priority Scheduling

- 정수로 표현된 우선순위가 더 높은 프로세스에게 CPU를 할당하는 스케줄링이다. 우선순위는 내부적/외부적으로 정의할 수 있다.
    - 내부적 : 시간 제한, 메모리 요구 사항, 열린 파일 수, 평균 I/O burst 대 평균 CPU burst 비율 등 측정 가능한 수량 사용해 계산
    - 외부적 : 프로세스의 중요성, 컴퓨터 사용에 대해 지불되는 자금의 유형 및 금액, 작업을 후원하는 부서, 기타 정치적 요인 등
- **선점 / 비선점 스케줄링** 모두 가능하다.
    - 선점 방식 : 새로 도착한 프로세스의 우선 순위가 현재 실행 중인 프로세스의 우선 순위보다 높으면 CPU 선점
    - 비선점 방식 : 같은 경우 단순히 새 프로세스를 Ready Queue의 맨 앞에 둔다.
- 문제점) **indefinite blocking**, **starvation**
    - 실행할 준비가 되었으나 CPU를 기다리는 프로세스는 block된 것으로 간주될 수 있다.
    - 우선 순위가 낮은 일부 프로세스는 무기한 대기 상태가 될 수 있다.
- 해결 방안) **Aging**, **Round-Robin과 결합**
    - Aging : 오랫동안 대기하는 프로세스의 우선순위를 점진적으로 높이는 방식으로 문제점을 해결할 수 있다. 예를 들어 대기 중인 프로세스의 우선순위를 매초 늘리는 것이다.
    - RR+PS : 우선순위가 가장 높은 프로세스를 실행하는데, 동일한 우선순위의 프로세스에 대해서는 Round-Robin 스케줄링을 적용한다.
- 정적/동적으로 우선순위를 부여하여 우선순위가 높은 순서대로 처리
- 우선 순위가 낮은 프로세스가 무한정 기다리는 Starvation 이 생길 수 있음
- Aging 방법으로 Starvation 문제 해결 가능

### Multilevel-Queue (다단계 큐)

- 작업들을 여러 종류의 그룹으로 나누어 여러 개의 큐를 이용하는 기법
- 우선순위가 낮은 큐들이 실행 못하는 걸 방지하고자 각 큐마다 다른 `Time Quantum`을 설정 해주는 방식 사용
- 우선순위가 높은 큐는 작은 `Time Quantum` 할당. 우선순위가 낮은 큐는 큰 `Time Quantum` 할당.    

### Multilevel-Feedback-Queue (다단계 피드백 큐)

- 다단계 큐에서 자신의 `Time Quantum`을 다 채운 프로세스는 밑으로 내려가고 자신의 `Time Quantum`을 다 채우지 못한 프로세스는 원래 큐 그대로
    - Time Quantum을 다 채운 프로세스는 CPU burst 프로세스로 판단하기 때문
- 짧은 작업에 유리, 입출력 위주(Interrupt가 잦은) 작업에 우선권을 줌
- 처리 시간이 짧은 프로세스를 먼저 처리하기 때문에 Turnaround 평균 시간을 줄여줌

### **SJF를 preemptive(선점)한 방식으로 구현하기 위해서는 ready queue에 새로운 프로세스가 도착할 때마다 CPU에게 interrupt를 걸어야하나요?**

preemptive SJF는 새로운 프로세스가 도착하면, 도착한 프로세스의 CPU 시간(버스트 크기)과 현재 실행 중인 프로세스의 남은 CPU 시간을 비교하여 더 짧은 CPU 시간을 가진 프로세스를 수행 시킨다.

즉, **도착한 프로세스가 더 짧다면 CPU에 interrupt를 걸고, 아니라면 계속 진행**한다. ( 인터럽트 → 현재 작업 중단 → 커널을 깨워 인터럽트 처리 → 원래의 작업으로 복귀 )

- **Q-1. 어떻게 새로운 프로세스가 도착했음을 알고, 그것이 더 짧은 프로세스임을 알고, CPU 제어권을 넘기는가요?**
    
    CPU 시간(버스트 크기)의 정확한 값을  사전에 아는 것은 사실상 불가능에 가깝다. 그렇기 때문에 **예측(지수 평균)**을 통해 진행한다. 새로운 프로세스가 더 짧은 프로세스일 경우, **Dispatcher를 통해** CPU 스케줄러에 의해 선택된 프로세스에게 **CPU의 제어권을** 넘겨준다.
      
### **multilevel queue에서 우선순위 높은 queue의 프로세스가 끝나서 두번째 queue의 프로세스를 처리하던 중 첫번째 queue에 프로세스가 채워지면 preemptive하게 작동하는가?**

두번째 queue가 실행되려면 앞의 queue들이 다 비어있어야한다. 그렇기 때문에 두번째 queue를 처리하던 중 첫번째 queue가 채워지면 두번째는 잠시 뒤로 물러나고 우선순위가 높은 프로세스가 실행된다.(preemptive 방식)

### Round Robin 스케줄링 방식에서 time quantum 설정에 따른 결과를 설명해보세요. 오버헤드가 어떤건가요

time Quantom이 커지면, 결과적으로 FCFS, 그리고 작다면 context switch 비용이 있기 때문에 사이에 적절하게 조절하는게 필요하다. 

### **multilevel queue time slice방식에서 각 queue에 CPU time을 비율로 할당한다는 것의 의미는 무엇인가요? 어떤 것에 대한 비율인가요?** 별개의 Queue를 두는 방식이 왜 load sharing과 관련이 있는가?

**각각의 큐에 다른 time quantum을 설정해주는 것**을 의미한다.

예시로는 foreground queue의 RR에 20%를, background queue의 FCFS에 80%를 할당하는 것이 있다.

time quantum이 길어질수록 FCFS방식의 성격을 띄기 때문에 결국 우선순위가 낮은 background 프로세스에 상대적으로 더 긴 time quantum을 할당하여 FCFS 느낌이 된다.

### FCFS 스케줄링을 개선한 스케줄링 방식에 대하여 설명해보세요.
라운드 로빈 → time Quantom + FCFS 이다. 
