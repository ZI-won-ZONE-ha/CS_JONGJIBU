### **VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.**

**장점**

- **플랫폼 독립성**
    - VM은 하드웨어와 운영 체제의 세부 사항을 추상화하여, 같은 프로그램을 다양한 시스템에서 동일하게 실행할 수 있게 합니다. 예를 들어, Java Virtual Machine(JVM)은 Java 프로그램을 모든 JVM이 설치된 플랫폼에서 실행할 수 있게 해줍니다.
- **보안**
    - VM은 일반적으로 실행 중인 프로그램을 호스트 시스템으로부터 격리합니다. 이로 인해, 잠재적으로 위험한 코드가 시스템 전체에 영향을 미치는 것을 방지할 수 있습니다.
- **메모리 관리와 최적화**
    - VM은 자동 메모리 관리와 가비지 컬렉션 기능을 제공합니다. 또한, VM은 Just-In-Time 컴파일과 같은 기술을 통해 프로그램의 실행 속도를 최적화할 수 있습니다.

**단점**

- **속도**
    - VM을 거쳐 코드를 실행하는 것은 일반적으로 직접 하드웨어에서 코드를 실행하는 것보다 느립니다. 그러나 최적화 기술이 발전함에 따라 이 차이는 점점 줄어들고 있습니다.
- **자원 사용**
    - VM은 자체적인 운영 체제와 런타임 시스템을 유지하기 때문에 추가적인 메모리와 CPU 리소스 자원을 사용하게 됩니다.

### **finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?**

finalize() Object 클래스에 정의되어 있는 메소드이며, GC에 의해 수거될 때 JVM에 의해 자동으로 호출되는 메소드로 수동으로 호출해서는 안되는 메소드입니다.

- **비결정성**
    - finalize() 메소드는 가비지 컬렉터에 의해 호출됩니다. 가비지 컬렉션은 JVM에 의해 관리되며, 언제 가비지 컬렉션이 발생하고, 어떤 객체가 수거될지는 일반적으로 예측할 수 없습니다. 따라서 finalize()가 호출되는 시점 역시 예측할 수 없습니다.
- **성능 이슈**
    - finalize() 메소드를 가진 객체는 두 번의 가비지 컬렉션 사이클을 거쳐야 합니다. 한 번은 finalize()를 호출하기 위한 것이고, 다른 한 번은 실제로 객체를 회수하기 위한 것입니다. 이로 인해 가비지 컬렉션의 성능이 저하될 수 있습니다.
- **자원 누수 위험**
    - finalize()에서 예외가 발생하면, 이 예외는 무시되며, 남은 정리 코드는 실행되지 않습니다. 이로 인해 자원이 제대로 회수되지 않는 누수가 발생할 수 있습니다.
- **finalize() 메소드의 폐지**
    - Java 9 이후로 Object 클래스의 finalize() 메소드는 deprecated(비권장) 상태입니다. 이는 finalize()의 위와 같은 문제점 때문이며, 대신 java.lang.ref.Cleaner나 java.lang.ref.PhantomReference와 같은 메커니즘을 사용하도록 권장하고 있습니다.

따라서 finalize() 메소드를 수동으로 호출하는 것은 이러한 문제점을 야기할 수 있으므로, 일반적으로는 권장되지 않습니다. 자원 정리는 대신 try-with-resources 구문이나 finally 블록 등을 사용하여 명시적으로 수행해야 합니다.

### Java 의 메모리 영역에 대해 설명해 주세요.

- Method Area : 클래스 멤버 변수, 메소드 정보, Type 정보, Constant Pool, static, final 변수 등이 생성됩니다. 상수 풀(Constant Pool)은 모든 Symbolic Reference를 포함하고 있습니다.
- PC Register: Thread가 시작될 때 생성되며, 현재 수행 중인 JVM 명령의 주소를 갖고 있습니다.
- Stack Area:  지역 변수, 파라미터 등이 생성되는 영역. 실제 객체는 Heap에 할당되고 해당 레퍼런스만 Stack에 저장.
- Heap Area:  동적으로 생성된 오브젝트와 배열이 저장되는 곳으로 GC가 관리하는 영역.

### Java의 실행방식을 설명해 주세요

- 자바 컴파일러(javac)가 자바 소스코드(.java)를 읽어 자바 바이트코드(.class)로 변환
- Class Loader를 통해 class 파일들을 JVM으로 로딩
- 로딩된 class파일들은 Execution engine을 통해 해석
- 해석된 바이트코드는 Runtime Data Areas 에 배치되어 실질적인 수행

### **자바가 컴파일 되는 과정을 설명해주세요.**

1. 사용자가 .java 파일을 생성한다
2. build한다
3. java 컴파일러의 javac의 명령어를 통해 바이트코드(.class)를 생성한다
4. class loader를 통해 JVM 메모리 내에 로드한다.
5. 실행엔진을 통해 컴퓨터가 읽을 수 있는 OS에 맞는 기계어로 해석된다.

### JVM 이란 무엇일까요? 어떻게 구성되어 있죠?

- 자바 가상 머신
- 자바 애플리케이션을 클래스 로더를 통해 읽어 자바 API와 함께 실행.
- Class Loader, Execution engine, Runtime Data Area, JNI, Native Method Library로 구성
- 클래스로더: JVM 내로 클래스를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈
- 인터프리터 : 바이트 코드를 한줄씩 실행합니다.
- JIT 컴파일러
    - 인터프리터 효율을 높이기 위한 컴파일러
    - 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러가 반복되는 코드를 네이티브 코드로 바꿈.
    - 그 다음부터 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용.
- GC(Garbage Collector): 가비지 컬렉터로 힙 영역에서 사용되지 않는 객체들을 제거
- Runtime Data Areas: 프로그램 실행 중에 사용되는 다양한 영역.
- JNI(Java Native Interface)
    - 자바 애플리케이션에서 C, C++, 어셈블리어로 작성된 함수를 사용할 수 있는 방법을 제공
    - Native 키워드를 사용하여 메서드를 호출
    - 대표적인 메서드는 Thread의 currentThread()
- Native Method Library: C, C++로 작성된 라이브러리

### **JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?**

아니다. VM과 내부에서 실행되는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖는 것이 아니라, 단일 프로세스 내에서 스레드를 통해 동시에 작업을 처리하는 구조

### **그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?**

- 올릴 수 있습니다. JVM 위에서 실행될 수 있는 언어를 JVM 언어라고 부릅니다.
- Scala, Kotlin, Groovy 등이 JVM 언어에 속합니다.
- 이러한 언어들은 각자의 특성을 가지고 있지만, JVM 위에서 실행되므로 Java의 라이브러리와 프레임워크를 활용할 수 있고, JVM의 메모리 관리와 성능 최적화 같은 기능을 이용할 수 있습니다.

### **반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?**

- 특정 상황에서 네이티브 코드로 컴파일될 수도 있습니다. 이는 GraalVM이나 Kotlin/Native와 같은 도구를 사용하면 가능합니다.

하지만, 일반적으로 JVM 언어를 사용하는 주요 이유는 JVM의 장점을 활용하기 위한 것입니다. 따라서 JVM 계열 언어를 네이티브 코드로 컴파일하는 것은 일반적인 경우는 아닙니다.

### GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.

- 정의 : GC는 힙 영역에서 사용하지 않는 객체들을 제거하는 작업을 총칭.
- 필요한 이유: 자바는 개발자가 메모리를 직접 해제해줄 수 없다. → 객체를 사용하고 제거하는 기능이 필요
- GC 수행시 시스템이 멈추기 때문에 의도치 않은 장애의 원인이 된다.
- 따라서 이를 위해 힙 영역을 조정하는 것을 GC 튜닝이라고하고 JVM 메모리는 절대 마음대로 조정해선 안된다.

### **Java의 GC에 대해 설명해 주세요.**

- 가비지 컬렉션은 JVM의 메모리 관리 기법
- 시스템에서 동적으로 할당됐던 메모리 영역 중에서 필요없어진 메모리 영역을 회수하여 메모리를 관리하는 기법
- **가비지 컬렉션 과정**
    - 가비지 컬렉션 작업을 수행하기 위해 JVM이 어플리케이션의 실행을 잠시 멈추고,가비지 컬렉션을 실행하는 스레드를 제외한 모든 스레드들의 작업을 중단 후(stop the world)사용하지 않는 메모리를 제거한 뒤(mark and sweep)기존의 작업을 재개합니다.

### GC의 동작방식

- GC는 Minor GC, Major GC로 구분 가능.
- Minor GC는 young 영역에서, Major GC는 old 영역에서 일어난다.
- Stop-the-world : GC를 수행할 때는 GC를 수행하는 스레드 이외의 스레드는 모두 정지.
- Mark: 사용되는 메모리와 사용되지 않는 메모리를 식별하는 작업
- Sweep: Mark 단계에서 사용되지 않음으로 식별된 메모리를 해제하는 작업

### Young 영역

1개의 Eden 영역과 2개의 Survivor 영역, 총 3가지로 나뉘어진다.

- Eden 영역: 새로 생성된 객체가 할당(Allocation)되는 영역
- Survivor 영역: 최소 1번의 GC 이상 살아남은 객체가 존재하는 영역
- Eden 영역이 가득 찬 후, Minor GC 실행
    1. Eden 영역에서 사용되지 않는 객체의 메모리가 해제된다.
    2. Eden 영역에서 살아남은 객체는 1개의 Survivor 영역으로 이동된다.
    3. 1~2번의 과정이 반복되다가 Survivor 영역이 가득 차게 되면 Survivor 영역의 살아남은 객체를 다른 Survivor 영역으로 이동시킨다.(1개의 Survivor 영역은 반드시 빈 상태가 된다.)
    4. 이러한 과정을 반복하여 계속해서 살아남은 객체는 Old 영역으로 이동(Promotion)된다.

### Old 영역

Major GC는 old 영역에서 일어납니다. 

- 삭제되어야 하는 객체를 mark하고  지운(sweep)다.
- 메모리는 단편화 된 상태이므로 이를 한 군데에 모아주는 것을 Compaction이라 하며 compact라고 합니다. 그래서 Mark-Sweep-Compact 알고리즘이라고 합니다.
- https://mangkyu.tistory.com/118

### **어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?**

- 변수의 값이 null이라는 것은 그 변수가 더 이상 해당 객체를 참조하지 않는다는 의미입니다. 그러나 이것만으로는 그 객체가 가비지 컬렉션(GC)의 대상이 될지 여부를 확정할 수 없습니다. 객체가 GC의 대상이 되려면, 해당 객체에 대한 모든 참조가 없어야 합니다.
- 다시 말해, 어떤 객체에 대해 여러 변수가 참조를 가지고 있었는데, 그 중 하나의 변수가 null이 되어도, 다른 변수들이 여전히 그 객체를 참조하고 있다면, 그 객체는 GC의 대상이 되지 않습니다.
- 하지만 해당 객체를 참조하는 모든 변수가 null이 되거나 범위(scope)를 벗어나서 참조할 수 없게 되면, 그 객체는 더 이상 접근할 수 없는 상태가 되어 GC의 대상이 될 수 있습니다.

이러한 메커니즘은 자바의 가비지 컬렉터가 "reachability"라는 개념을 기반으로 작동하기 때문입니다. 즉, 어떤 객체가 GC의 대상이 될지는 그 객체에 접근할 수 있는 경로가 있는지 여부에 따라 결정됩니다.

- GC의 reachability

:어떤 객체에 아직 유효한 참조가 있으면 'reachable'로, 없으면 'unreachable'로 구별하고, unreachable 객체를 garbage로 간주해 GC를 수행

---

### 컬렉션 프레임워크에 대해서 설명해주세요.

- Java Collection은 널리 알려져 있는 자료구조를 바탕으로 객체, 데이터들을 효율적으로 관리 할 수 있는 자료구조들이 있는 라이브러리
- List, Set은 Collection 인터페이스을 상속받지만, Map 인터페이스는  구조상의 차이(key, value) 라 별도로 정의.

### 제네릭에 대해서 설명해주세요.

- 제네릭은 자바의 타입 안정성. 모든 데이터 타입을 다룰 수 있도록 하나로 데이터 타입을 지정하지 않고 사용시마다 범용적이고 포괄적으로 지정한다는 의미입니다.
- 컴파일 과정에서 타입체크를 해주는 기능으로 객체의 타입을 컴파일 시에 체크하기 때문에, 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줍니다.
- 일반화된 타입 매개 변수(generic type)로 클래스나 메서드를 선언하는 기법입니다.
- 제네릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있어 에러를 사전에 방지할 수 있습니다.

### 클래스는 무엇이고 객체는 무엇인가요?

- 클래스는 객체를 정의하는 틀 또는 설계도와 같은 의미로 사용됩니다.
- 객체는 식별 가능한 개체 또는 사물입니다.
- 객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가집니다. 인스턴스들을 통칭하는 용도로 사용합니다.

### 인터페이스와 추상클래스의 차이점에 대해 설명해주세요.

### 추상클래스

객체의 추상적인 상위 개념으로 공통된 개념을 표현할 때 사용합니다. 

단일 상속만 가능합니다. 

추상클래스를 상속하는 집합간에는 연관관계가 있습니다.

### 인터페이스

구현 객체가 같은 동작을 한다는 것을 보장하기 위해 사용합니다. 

다중 상속이 가능합니다. 

인터페이스를 구현하는 집합간에는 관계가 없을 수 있습니다.

### i**nterface와 abstract에 대해서 설명하세요.**

**인터페이스(interface)**

- 모든 메서드가 추상 메서드로 이루어진 클래스 입니다.
- abstract를 쓰지 않아도 모두 추상 메서드로 정의되며, 선언한 변수는 final static 키워드가 붙습니다.

**추상클래스(abstract)**

- 클래스내에 추상 매서드가 하나 이상 포함되거나 abstract로 정의된 경우를 말합니다.
- 추상클래스는 자신의 생성자로 객체 생성이 불가능합니다. 하위 클래스를 참조해 상위 클래스의 객체를 생성하여 하위 클래스를 제어하기 위해 사용합니다.

### 애노테이션에 대해서 설명해주세요

- 애노테이션은 인터페이스를 기반으로 한 문법
- 주석처럼 코드에 달아 클래스에 특별한 의미를 부여하거나 기능을 주입 가능하다.
- built-in annotation은 상속받아서 메소드를 오버라이드 할 때 나타나는 @Override 애노테이션이 그 대표적인 예
- 메타 애너테이션은 애노테이션을 선언할 때 사용하는 애노테이션.
    - @Retention: 애노테이션 유지 범위를 지정합니다. (소스, 클래스, 런타임)
    - @Inherit: 애노테이션을 하위 클래스까지 전달여부를 지정합니다. 이 애노테이션이 있으면 하위 클래스까지 상속이 가능합니다.
    - @Target: 해당 애노테이션을 어디에 사용할 지 결정합니다. (타입, 필드, 메서드, 파라미터, 생성자, 로컬변수, 애노테이션 타입)

### 원시타입과 참조타입의 차이에 대해 설명해주세요.

- 원시타입은 Java에서 단 8개 밖에 존재하지 않는 타입
- 나머지는 모두 참조타입으로, Object 클래스이거나 이를 상속하는 클래스들로 이루어져 있습니다.
- 원시타입은 항상 값이 존재해야 합니다. 반면, Object 타입은 null 포인터를 가진다.
- 멤버변수가 초기화될 때, 원시타입은 기본값을 가지지만, 참조타입은 null 포인터를 가진다.

---

### 객체지향에 대해서 설명해주세요

- 객체 지향이 무엇인지에 대해 설명해주세요
    - 객체지향프로그래밍이란 데이터를 객체로 취급하여 프로그램에 반영한 것으로, 객체와 객체의 상호작용을 통해 프로그램이 동작하는 것을 말합니다.
    - 객체 지향 프로그래밍의 4가지 특징으로 상속, 캡슐화, 다형성, 추상화가 있고,모듈 재사용으로 확장 및 유지보수가 용이합니다.
- 객체지향으로 의존성을 관리함으로써
    - 변경 영향을 최소화하고 독립적인 배포가 가능해지며 독립적인 개발이 가능하다.
    - 가장 중요한 것은 DIP(Dependency Inversion Principle)를 통한 고수준 정책(High Level Policy) 저수준 구현 세부사항(Low Level Details)의 분리.
- 객체 지향 프로그래밍의 장점은 무엇인가요
    - **재사용성**
        - 클래스와 객체를 사용하면 코드를 재사용하기 쉽습니다. 이미 작성된 클래스를 상속받아 새로운 기능을 추가하거나 수정할 수 있습니다.
    - **확장성**
        - 새로운 기능을 추가하거나 기존 기능을 수정하는 것이 상대적으로 쉽습니다. 이는 기능이 객체 단위로 구분되어 있기 때문입니다.
    - **유지 관리 용이**
        - 코드가 객체 단위로 구분되어 있어, 코드를 이해하고 디버깅하기 더 쉽습니다. 또한, 코드의 수정이 다른 부분에 미치는 영향이 적습니다.
    
    하지만, 성능면에서 객체 지향 프로그래밍은 메모리 사용과 CPU 시간이 절차 지향 프로그래밍보다 많을 수 있습니다.
    

### SOLID(객체지향 5대원칙)에 대해서 설명해주세요.

- SRP(단일책임원칙)
    - 한 클래스의 하나의 책임만 가져야 합니다.
- OCP(개방-폐쇄 원칙)
    - 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
    - 이는, 다형성을 활용하여 지킬 수 있다.
- LSP(리스코프 치환 원칙)
    - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함.
    - 상위 타입을 상속해서 재정의 했을 때 프로그램이 깨지면 안됨.
- ISP(인터페이스 분리 원칙)
    - 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안되는 원칙
    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 더 낫다.
    - 비대한 인터페이스보단 더 작고 구체적인 인터페이스로 분리해야합니다.
- DIP(의존관계 역전 원칙) :
    - 추상적인 것은 자신보다 구체적인 것에 의존하지 않고, 변화하기 쉬운 것에 의존해서는 안된다.
    - 구체적으론 구현 클래스에 의존하지 말고, 인터페이스에 의존해야 한다.

### **추상화, 캡슐화, 상속, 다형성이란?**

**추상화(Abstration)**

- 객체의 공통적인 속성과 기능을 추출하여 정의하는것을 의미합니다.
- 자바에서 추상화를 구현할 수 있는 문법 요소로는 추상 클래스(abstract class)와 인터페이스(interface)가 있고, 인터페이스가 가장 빈번하게 사용됩니다.

**캡슐화(Encapsulation)**

- 캡슐화란 클래스 안에 서로 연관있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하는 것을 말합니다.
- 외부로부터 클래스에 정의된 속성과 기능들을 보호하고(데이터 보호(data protection)), 필요한부분만 외부로 노출될 수 있도록 하여(데이터 은닉(data hiding)) 각 객체 고유의 독립성과 책임 영역을 안전하게 지키고자 하는 목적이 있습니다.

**상속(Inheritance)**

- 기존의 클래스를 재활용하여 새로운 클래스를 작성하는 것을 의미합니다.
- 상속은 클래스 간 공유될 수 있는 속성과 기능들을 상위 클래스로 추상화 시켜 해당 상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용할 수 있도록 합니다.
- 즉, 클래스들 간 공유하는 속성과 기능들을 반복적으로 정의할 필요 없이 딱 한 번만 정의해두고 간편하게 재사용할 수 있어 반복적인 코드를 최소화하고 공유하는 속성과 기능에 간편하게 접근하여 사용할 수 있도록 합니다.

**다형성(polymorphism)**

- 다형성은 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것입니다.
- 즉, 오버라이딩(Overriding), 오버로딩(Overloading)이 가능하다는 얘기이다.

### 오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?

- 오버라이딩
    - 상위 클래스의 메소드를 재정의 하는 것을 의미.
    - 런타임 다형성
    - `@Override`를 써야하는 이유? 이 애노테이션은 컴파일 타임에 오버라이딩에 대한 안정성을 부여.
- 오버로딩
    - 같은 클래스 내에서 동일한 메소드 이름을 가지지만, 매개변수의 타입, 개수가 다르게 구현할 수 있는 것을 의미
    - 컴파일 타임 다형성.
    - 오버라이딩 가능하다.

### 동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)

- 동일성은 객체의 주소를 비교하는 것이고, 동등성은 객체의 같음을 비교
- 기본적으로 자바에서는 Object 클래스에 정의된 equals() 메소드가 동일성 비교 (즉, 재정의 하지 않는 이상, 동일성을 보장해 준다.) 근데 스트링은 이미 equals 재정의 되어 있다.
- 개발자는 원한다면 equals() 메소드를 오버라이딩해서 동등성의 판단 기준을 정의.

### **equals()와 hashcode()에 대해 설명해 주세요.**

**Java에서 equals()와 hashCode() 메소드는 Object 클래스에서 정의된 메소드이며, 객체의 동일성 및 동등성을 비교하는 데 사용됩니다.**

- **equals() 메소드**이 메소드는 두 객체가 동등한지를 판단하는 데 사용됩니다.기본적으로 equals() 메소드는 두 객체의 참조가 같은지를 비교합니다. 즉, 두 객체가 같은 메모리 주소를 가리키는 경우에만 true를 반환합니다. 하지만 equals() 메소드는 오버라이드하여 사용자 정의 동등성 비교를 수행할 수 있습니다. 예를 들어, 두 개의 String 객체가 다른 메모리 주소에 위치하더라도 동일한 문자열을 가지고 있다면, equals() 메소드는 true를 반환합니다.
- **hashCode() 메소드**이 메소드는 객체의 해시 코드 값을 생성하는 데 사용됩니다.해시 코드는 객체를 유일하게 식별하는 정수값을 반환합니다. hashCode() 메소드는 주로 해시 기반의 컬렉션, 예를 들어 HashMap, HashSet 등에서 객체를 빠르게 검색하는 데 사용됩니다.
- 두 객체가 equals()를 통해 동등하다면, 두 객체의 hashCode()는 반드시 같아야 합니다. 즉, a.equals(b)가 true를 반환한다면 a.hashCode()와 b.hashCode()는 같은 값을 반환해야 합니다.
- 그러나 두 객체의 hashCode()가 같다고 해서 두 객체가 equals()를 통해 동등하다는 것은 아닙니다. 즉, 해시 충돌(hash collision)이 발생할 수 있습니다.
- equals와 hashCode의 관계

동일한 객체는 동일한 메모리 주소를 갖는다는 것을 의미하므로, 동일한 객체는 동일한 해시코드를 가져야 한다. 그렇기 때문에 우리가 equals() 메소드를 오버라이드 한다면, hashCode() 메소드도 함께 오버라이드 되어야 한다.

### 접근 제어자의 종류와 이에 대해 설명해주세요.

변수, 메소드, 클래스 선언부에 표시되어 부가적인 의미를 부여하는 키워드를 말한다. 제어자는 접근 제어자와 그 외의 제어자, 두 가지 종류로 나눌 수 있다.

- 접근제어자란 변수 또는 메모리 접근 범위를 설정해주기 위해 사용하는 Java의 예약어를 의미합니다. 총 4가지 종류가 있습니다.접근 제어자는 한 번에 네 가지 중 하나만 선택해서 사용할 수 있습니다.
    - **public**은 접근 제한이 없으므로, 같은 프로젝트 내 어디서든 사용 가능합니다.
    - **protected**는 해당 패키지 내, 다른 패키지에서 상속받아 자손 클래스에서 사용이 가능합니다.
    - **default**는 해당 패키지 내에서만 접근이 가능합니다.
    - **private**는 해당 클래스 내에서만 접근이 가능합니다.
- 그외의 제어자
    - **static**은 클래스의, 공통적인의 의미를 가지고 있다. static이 붙은 멤버변수와 메수드, 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에, 인스턴스 생성 여부와 관계 없이 사용이 가능하다.
    - **final**은 마지막의, 변경될 수 없는 의미를 가지고 있고, 거의 모든 대상에 사용이 가능하다.
    - **abstract**은 추상의, 미완성의 의미를 가지고 있다. 메서드의 선언부에만 작성하고, 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다
- 접근 제어자를 사용하는 이유는 외부에 보여주고 싶은 정보들을 선택적으로 제공하여 캡슐화를 가능하게 한다.

### 자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?

- boolean(1), char(unsigned 2), byte(1), short(2), int(4), long(8), float(4), double(8)
- 사실 JVM에 의존적이기 때문에 정확한 크기라기 보다는 대략적인 크기이다.

### String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.

- String은 불변. StringBuilder와 StringBuffer는 가변.
- StringBuilder는 Thread-safe하지 않습니다. Multi-Thread 환경에서 사용할 때는 StringBuffer를 사용.
- **String**자바의 기본 데이터 타입인 int, float, char 등과 다르게 String은 데이터 타입이 아닌 클래스 객체입니다.ex. 한번 String name =”길동”; 라고 선언하게 되면 먼저 String 객체타입인 name이라는 인스턴스를 만들고 메모리에 “길동”을 올려버립니다. 그리고 name이 “길동”을 참조하는 레퍼런스가 되는 것입니다.

### Java8에서 추가된 기능에 대해서 설명해주세요.

- Java8에서는 Lambda식, Stream API, Optional, 날짜 시간 API, StringJoiner 등이 추가
- lambda는 함수형 프로그래밍을 지원하기 위한 기능이고, Stream API는 고차함수를 지원합니다.
- Optional은 Null-safety를 제공하며, Stream과 사용법이 유사합니다.
- StringJoiner는 문자열을 간단하게 구분자로 합칠 수 있는 기능을 제공합니다.

### **Optional 에대해 설명해주세요.**

- Java 8에서는 Optional<T> 클래스를 사용해 NPE(NullPointerException)를 방지할 수 있도록 도와준다.
- Optional<T>는 null이 올 수 있는 값을 감싸는 Wrapper 클래스로, 참조하더라도 NPE가 발생하지 않도록 도와준다. Optional 클래스는 아래와 같은 value에 값을 저장하기 때문에 값이 null이더라도 바로 NPE가 발생하지 않으며, 클래스이기 때문에 각종 메소드를 제공해준다.
    
    ➡ 즉, Optional은 null 또는 값을 감싸서 NPE(NullPointerException)로부터 부담을 줄이기 위해 등장한 Wrapper 클래스이다.
    

### **Wrapper class**

### **Boxing/unboxing**

- 기본자료형(원시형)을 ➡ wrapper class로 변환하는 것이 박싱이고
- wrapper class를 ➡ 기본자료형(원시형)으로 변환하는 것이 언박싱입니다.
- 자바의 기본 자료형(Primitive Data Type)에 대한 객체 표현을 wrapper class 라고 합니다.
- 기본 자료형으로 표현할 수 있는 간단한 데이터를 객체로 만들어야 할 경우가 있는데 그러한 기능을 지원합니다.

### try-with-resource에 대해서 설명해주세요.

- try-with-resources는 자바 버전7에 도입된 문법.
- 자바 7 버전 이전에서 하나 이상의 리소스(java.lang.AutoCloseable을 구현한 객체 혹은 java.io.Closeable를 구현한 객체)를 사용할 경우 개발자가 임의로 finally 문에서 ~~.close()를 사용하여 자원 해제를 시켜줘야 했습니다.
- 만약 개발자가 사용한 자원을 finally 문에서 해제시켜주지 않고 누락시켰다면 자원이 해제되지 않은 채로 프로그램이 오작동하게 되고, finally 문에서 자원을 해제 시켜주더라도 자원 해제를 위한 중복 코드가 발생하기 때문에 소스 코드의 가독성을 해치는 단점이 있었습니다.
- 이를 해결하기 위해 try() 안에 사용할 리소스 객체를 명시적으로 선언하여 사용하면, try 블록 안에서 로직이 정상적으로 완료되었는지, 갑작스럽게 완료되었는지 여부와 관계 없이 JVM에서 자동으로 자원을 반납해주는 기능을 하도록 도입하였습니다.
- 추가로, 자바 9 버전에서는 try() 문 안에 명시적으로 객체 선언을 하기 보다는 try 문 바깥에서 객체 선언을 하고 생성된 인스턴스의 변수를 넣어줄 수 있도록 바뀌었습니다.
    - Java 7 : try(BufferedReader br = new BufferedReader())
    - Java 9 : try(br)

### 강한 결합과 느슨한 결합이 무엇인지 설명해주세요.

- 결합도 : 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 정보를 알고 있는지에 대한 척도.
- 강한 결합도 : 어떤 모듈이 다른 모듈에 너무 자세한 부분(구현 세부사항)까지 알고 있을 경우
- 낮은 결합도: 어떤 모듈이 다른 모듈에 대해 필요한 정보(인터페이스로 추상화된 고수준 정책)만 알고 있을 경우
- 객체지향 관점에서 결합도는 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지
- 강한 결합도는 반드시 지양해야 하며, 개발자는 적절한 결합도를 유지할 수 있도록 고민하고 설계해야 합니다.

### 직렬화와 역직렬화에 대해서 설명해주세요.

- 직렬화:  자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터 변환하는 기술
- 역직렬화 : 바이트로 변환된 데이터를 다시 변환하는 기술
- 자바 직렬화는 JVM의 메모리에서만 상주되어있는 객체 데이터를 영속화(Persistence)가 필요할 때 사용. 시스템이 종료되더라도 없어지지 않는 장점을 가지며 영속화된 데이터이기 때문에 네트워크로 전송이 가능합니다.

### Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.

- Mutable 객체는 변경 가능 객체이고, Immutable 객체는 불변 객체
- Mutable 객체는 도메인 개체(도메인 클래스 혹은 엔터티)로 사용
- Immutable 객체는 불변객체이며 값 객체, 서비스 객체 등에 사용
- Immutable 객체의 변경 메서드는 변경한 객체의 복사본을 반환

### 자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.

- 공개 메서드가 아닌 곳에는 assert를 사용하여 null을 방어
- 메서드의 인자를 받을 때 Objects.requireNonNull()을 사용하여 방어
- Optional을 사용해 리턴 타입에서 null을 반환하지 않도록 방어할 수 있습니다.

### **클래스 멤버 변수 초기화 순서**

1. **static 변수 선언부** 클래스가 로드될 때 가장 먼저 초기화된다.
2. **field(필드) 변수 선언부** 객체가 생성될 때 생성자 block보다 앞서 초기화된다.
3. **constructor(생성자)**객체가 생성될 때 JVM이 내부적으로 locking (thread-safe영역)

### JDK와 JRE의 차이점을 설명하세요.

- JDK는 Java Development KIT의 약자로 개발하는데 사용되는 도구이며, JRE를 포함.
- JRE는 Java Runtime Environment의 약자로 자바로 만들어진 프로그램을 실행시키며, 필요한 도구가 들어있다.
- 운영서버와 같은 곳에서는 개발에 필요한 도구가 아닌 프로그램을 실행시키는 도구만 필요하기 때문에
개발도구가 들어있는 JDK아닌 JRE를 설치합니다.

----여기는 굳이 말씀 안하셔도 될듯합니다.----
그러나 최근에 JDK가 많이 가벼워지고 하드웨어도 좋아지고 해서 운영서버에 설치하여도 큰 문제가 없고
JDK에 로깅, 디버깅, 로그분석등 유용한 도구들도 있고 해서
굳이 JRE설치하는것 보다 JDK를 설치 해서 개발및 실행환경을 통합적으로 관리하는 경우도 있다고 합니다.

- JIT 컴파일러는 메소드 호출 시 마다 컴파일 하나요?
    - 인터프리터는 바이트코드를 실행하기 위해 이미 실행했던 실행문도 다시 읽고 번역하는 과정을 거치기 때문에 **프로그램 실행 속도를 저하시킬 수 있다는 치명적인 단점**을 가지게 된다.
    - 이러한 문제점을 보완하기 위해 고안된 것이 바로 `JIT 컴파일러`다.
    - 바이트코드 중 빈번하게 접근하는 영역에 대해 런타임중 기계어로 컴파일 하고 컴파일 된 명령문을 캐싱해 같은 부분이 호출되면 캐싱된 데이터로 실행 한다.
    - 이 때, JIT 컴파일 과정은 **별도의 스레드**에서 진행된다.
    
    >  Q. JIT 컴파일러는 메소드 호출 시 마다 컴파일 하나요?
    > 
    > 
    > **A.**
    > 
    > - 기본적으로 **메소드의 첫 호출 시점에는 컴파일 하지 않는다**. JIT 컴파일 과정은 메모리와 시간을 소비한다. JVM이 실행되는 시점에 수천개의 메서드호출이 이루어지는데 이런 메서드 모두를 바로 컴파일해서 캐싱한다면 성능 저하가 발생 할 수 있다.
    > - JVM은 미리 정의된 `컴파일 임계값`을 가지는데 바이트코드의 특정 영역에 대한 호출 횟수가 `컴파일 임계값`을 넘길때 JIT 컴파일을 진행한다.

### **리플렉션(Reflection)이란 무엇인지 설명해주세요.**

- Java에서 이미 로딩이 완료된 클래스에서 또 다른 클래스를 동적으로 로딩하여 생성자, 멤버 필드, 멤버 메서드 등을 사용할 수 있는 기법입니다.
- 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 Java API 입니다.

### **리플렉션은 어떤 경우에 사용되는지 설명해주세요.**

코드를 작성할 시점에는 어떤 타입의 클래스를 사용할지 모르지만, 런타임 시점에 지금 실행되고 있는 클래스를 가져와서 실행해야 하는 경우 사용됩니다.

- **클래스 정보 얻기**
    - Class 객체를 통해 클래스 이름, 부모 클래스, 구현한 인터페이스, 사용된 어노테이션 등의 정보를 얻을 수 있습니다.
- **메소드와 필드 정보 얻기**
    - Method, Field, Constructor 등의 클래스를 사용하여 메소드, 필드, 생성자의 정보를 얻을 수 있습니다. 이들을 통해 메소드나 생성자를 호출하거나, 필드의 값을 읽거나 변경할 수도 있습니다.
- **동적 클래스 로딩**
    - Class.forName() 메소드를 사용하여 문자열로 된 클래스 이름을 가지고 해당 클래스를 동적으로 로딩할 수 있습니다.

프레임워크나 IDE에서 이런 동적인 바인딩을 이용한 기능을 제공합니다. intelliJ의 자동완성 기능, 스프링의 어노테이션이 리플렉션을 이용한 기능이라 할 수 있습니다.

### **의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?**

맞습니다. 리플렉션은 매우 강력한 도구로, 제한 없이 사용하면 보안 문제를 일으킬 수 있습니다. 예를 들어, 리플렉션을 통해 보호된(ex: private) 필드나 메소드에 접근하거나, 보안 매커니즘을 우회하는 데 사용될 수 있습니다.

이러한 문제 방지를 위해 아래와 같은 조치를 취할 수 있습니다.

- **최소한의 권한 부여**
- **코드 검사와 테스트**
    - 리플렉션을 사용하는 부분에서 예기치 않은 동작이 발생하지 않도록 해야 합니다.
- **보안 매니저 사용**
    - Java는 SecurityManager라는 시스템을 제공합니다. 이를 사용하면 애플리케이션의 보안 정책을 더 세밀하게 제어할 수 있습니다. 예를 들어, 특정 작업(예: 리플렉션을 사용한 접근)을 허용하거나 금지하는 등의 설정을 할 수 있습니다.
- **의존하는 라이브러리 검사**
    - 외부 라이브러리가 리플렉션을 어떻게 사용하는지 알아보고, 필요하다면 그 라이브러리의 사용을 재고해야 합니다

### **불변 객체나 final을 굳이 사용해야 하는 이유가 있을까요?**

성능, 동기화, 캐싱, 보안등의 이유로 불변객체와 final을 사용해야합니다. → 메모리 절약, 보안, thread safe 보장

- **스레드 세이프 보장(Thread Safety)**
    - 불변 객체는 여러 스레드에서 동시에 접근하더라도 그 상태가 변경되지 않으므로, 동기화 없이도 안전하게 사용할 수 있습니다. 따라서 병렬 처리 환경에서의 버그를 예방하고, 성능을 향상시킬 수 있습니다.
- **가독성과 유지 관리성**
    - 불변 객체는 상태가 변경되지 않으므로 코드를 이해하고 디버깅하는 데 더 쉽습니다. 또한, 버그가 발생할 가능성을 줄여 유지 관리성을 향상시킵니다.
- **보안**
- **캐싱 기능에 의한 메모리 절약과 속도향상**

### **불변 객체가 무엇인지 설명하고 대표적인 Java의 예시를 설명해주세요.**

불변 객체(Immutable Object)는 생성된 후 그 상태가 변하지 않는 객체를 의미합니다.

즉, 객체가 한 번 생성되면 그 후로는 내부 상태를 변경할 수 없습니다. 이러한 불변성은 여러 스레드에서 동시에 객체를 사용할 때 발생할 수 있는 문제를 방지하므로, 병렬 처리 환경에서 매우 유용합니다.

- **String** String 클래스는 가장 대표적인 불변 객체입니다. String 객체가 한 번 생성되면 그 값을 변경할 수 없습니다. String 클래스의 메소드 중 일부는 문자열을 변경하는 것처럼 보이지만, 실제로는 새로운 String 객체를 생성해서 반환합니다.
- **Wrapper 클래스들** Integer, Long, Double, Character 등의 원시 타입을 감싸는 wrapper 클래스들은 모두 불변입니다.
- **BigInteger와 BigDecimal** 이들 클래스는 불변이며, 큰 정수나 정밀한 소수를 표현하는 데 사용됩니다.

Java에서는 필드가 원시 타입인 경우 final 키워드를 사용해 불변 객체를 만들 수 있고, 참조 타입일 경우엔 추가적인 작업이 필요합니다.

### **◼ 참조 타입일 경우 추가적인 작업은 어떤게 있는지 설명해주세요**

- 참조 변수가 일반 객체인 경우 객체를 사용하는 필드의 참조 변수도 불변 객체로 변경해야 합니다.
- 배열일 경우 배열을 받아 copy해서 저장하고, getter를 clone으로 반환하도록 하면 됩니다.
- ➡ 배열을 그대로 참조하거나, 반환할 경우 외부에서 내부 값을 변경할 수 있기 때문에 clone을 반환해 외부에서 값 변경하지 못하게 하는것 입니다.
- 리스트인 경우에도 배열과 마찬가지로 생성시 새로운 List를 만들어 값을 복사하도록 해야 합니다.

### **final 키워드를 사용하면, 어떤 이점이 있나요?**

- **불변성 보장**
    - final 키워드를 사용하여 변수를 선언하면 그 변수는 한 번 초기화된 후에는 변경할 수 없습니다. 이는 특정 값을 변경하지 못하도록 보장하고, 해당 변수가 참조하는 객체가 변하지 않음을 보장합니다.
- **디버깅 용이**
    - 변수가 final로 선언되면, 그 값은 프로그램 실행 도중 변경되지 않습니다. 따라서 값이 어디서 바뀌는지 추적할 필요가 없어져 디버깅이 용이해집니다.
- **스레드 안전성 / Thread Safety**
    - final 필드는 스레드 간에 안전하게 공유될 수 있습니다. 특히 멀티스레드 환경에서 유용합니다.
- **클래스 불변성**
    - final 키워드는 클래스 또는 메소드에도 적용할 수 있습니다. 클래스에 final을 붙이면 그 클래스는 상속할 수 없습니다. 메소드에 final을 붙이면 그 메소드는 오버라이딩할 수 없습니다. 이를 통해 클래스의 불변성을 보장할 수 있습니다.
- **효율성 증대**
    - 컴파일러는 final 변수를 통해 최적화를 수행할 수 있습니다. final 키워드가 붙은 변수의 값은 변하지 않으므로, 컴파일러는 이를 이용해 더 효율적인 코드를 생성할 수 있습니다.

하지만, final 키워드가 참조 타입 변수에 적용될 때, 그 변수가 참조하는 객체의 내부 상태는 final이 적용되지 않습니다. 따라서 final이 참조하는 객체 자체가 불변임을 보장하지는 않기 때문에 이점에 유의하여 사용해야 합니다.

### **Inner Class(내부 클래스)의 장점에 대해 설명해주세요.**

내부 클래스란 클래스 내에 선언되는 클래스이다. 이점을 제외하고는 일반적인 클래스와 다르지않다.

- 내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있다.
- 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 캡슐화를 증가시키고, 코드의 복잡성을 낮출 수 있다.
- 외부에서는 내부 클래스에 접근할 수 없으므로, 코드의 보안성을 높일 수 있다.

### **final / finally / finalize 를 각각 설명해주세요.**

- **final**
    - 클래스, 메소드, 변수, 인자를 선언할 때 사용할 수 있으며, 해당 요소가 더 이상 변경되거나 확장되거나 오버라이드되지 않음을 나타냅니다.
    - 변수: final로 선언된 변수는 한 번 초기화하면 변경할 수 없습니다.
    - 메소드: final로 선언된 메소드는 다른 클래스가 이 클래스를 상속할 때 메소드 오버라이딩을 금지합니다.
    - 클래스: final로 선언된 클래스는 다른 클래스가 상속받을 수 없습니다.
- **finally**
    - try-catch 구조에서 사용되며, 예외가 발생하든 발생하지 않든 항상 실행되는 코드 블록을 정의합니다.이는 주로 사용했던 자원을 반환하거나, 열려 있는 파일 또는 데이터베이스 연결을 닫는 등의 정리 작업에 사용됩니다.
- **finalize**
    - Object 클래스에 정의되어 있는 메소드이며, 객체가 가비지 컬렉션에 의해 회수되기 전에 실행되는 코드를 정의합니다.
    - 따라서, GC에 의해 호출되는 메소드로 절대 호출해서는 안되는 메소드입니다.GC가 발생하는 시점이 불분명하기 때문에 해당 메소드가 실행된다는 보장이 없고, finalize() 메소드가 오버라이딩 되어 있으면 GC가 이루어질 때 바로 Garbage Collection 되지 않습니다.GC가 지연되면서 OOME(Out of Memory Exception)이 발생할 수 있기 때문에 finalize() 메소드를 오버라이딩하여 구현하는 것을 권장하지 않고 있습니다.
    - 그러나 finalize는 Java 9 이후로 이 메소드는 deprecated 상태이며, 더 이상 사용되지 않습니다.대신 java.lang.ref.Cleaner나 java.lang.ref.PhantomReference를 사용하는 것이 권장됩니다.

### 정적(static)이란 무엇인가요?

- static은 클래스 멤버
- 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리.
- static 키워드를 통해 생성된 정적멤버들은 PermGen 또는 Metaspace에 저장되며 저장된 메모리는 모든 객체가 공유하며 하나의 멤버를 어디서든지 참조할 수 있는 장점이 있습니다.
- 그러나, GC의 관리 영역 밖에 존재하기 때문에 프로그램 종료시까지 메모리가 할당된 채로 존재합니다.
- 너무 남발하게 되면 시스템 성능에 악영향을 줄 수 있습니다.

### **static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?**

- Java에서 static 키워드는 클래스 레벨에서 사용되는 메소드나 변수, 내부 클래스에 사용될 수 있습니다. static 키워드는 해당 요소가 인스턴스 수준이 아닌 클래스 수준에서 작동하도록 지시합니다.
- 하지만, 적절하지 않게 사용된 static 요소는 객체 지향 프로그래밍의 원칙을 위반할 수 있으며, 코드의 유연성과 재사용성을 저해할 수 있습니다.
    
    **장점**
    
    - **메모리 효율성**
        - static 변수는 클래스당 하나만 생성되며, 해당 클래스의 모든 인스턴스에서 공유됩니다. 이는 메모리 사용량을 줄이는 데 도움이 될 수 있습니다.
    - **객체 생성 없이 사용 가능**
        - static 메소드나 변수는 객체를 생성하지 않고도 사용할 수 있습니다. 이는 유틸리티 메소드를 작성하거나, 상수를 정의하는 데 유용할 수 있습니다.
    - **글로벌 접근**
        - static 변수는 해당 클래스의 모든 인스턴스에서 접근할 수 있습니다. 이는 일종의 전역 변수로 작동하여, 특정 정보를 공유해야 하는 상황에서 유용할 수 있습니다.

**단점**

- **인스턴스 수준의 접근 제한**
    - static 메소드는 클래스의 인스턴스 변수나 메소드에 직접적으로 접근할 수 없습니다. static 메소드에서 인스턴스 변수를 사용하려면 객체의 인스턴스를 통해 접근해야 합니다.
- **오버라이딩 불가**
    - static 메소드는 오버라이딩할 수 없습니다. 하위 클래스에서 동일한 시그니처를 가진 static 메소드를 정의할 수는 있지만, 이는 상위 클래스의 메소드를 오버라이딩하는 것이 아니라, 하위 클래스에서 새로운 static 메소드를 정의하는 것입니다.
- **정적 바인딩**
    - static 메소드는 정적 바인딩을 사용합니다. 즉, 메소드 호출이 프로그램 실행 중에 결정되는 것이 아니라, 컴파일 시점에 결정됩니다. 이는 다형성을 제한할 수 있습니다.

### **static class와 static method를 비교해 주세요.**

- **Static Class**
    - Java에서 static 클래스는 static 내부 클래스로만 존재할 수 있습니다. 즉, 최상위 수준의 클래스는 static일 수 없습니다.
    - static 내부 클래스는 자신을 포함하는 외부 클래스의 인스턴스에 의존하지 않으므로, 외부 클래스의 인스턴스 없이도 생성할 수 있습니다.
    - static 내부 클래스는 일반적으로 외부 클래스와 관련이 있지만, 외부 클래스의 인스턴스와 독립적으로 작동하는 클래스를 정의할 때 사용됩니다.
- **Static Method**
    - static 메소드는 클래스 수준에서 작동하는 메소드입니다. 즉, 클래스의 인스턴스를 생성하지 않고도 호출할 수 있습니다.
    - static 메소드는 인스턴스 변수에 접근할 수 없으며, 오직 static 변수나 다른 static 메소드에만 접근할 수 있습니다. 주로 유틸리티나 헬퍼 메소드를 정의할 때 사용됩니다.
    - 예를 들어, Math 클래스의 Math.abs()나 Math.sqrt() 메소드는 static 메소드입니다.

두 가지 요소는 모두 클래스 수준에서 작동하지만, 그들이 사용되는 방식과 목적은 다릅니다.

static 내부 클래스는 외부 클래스와 독립적으로 작동하는 객체를 생성하는 데 사용되며, static 메소드는 객체의 인스턴스 없이도 작동하는 동작을 정의하는 데 사용됩니다.

### **non-static 멤버와 static 멤버의 차이**

**non-static 멤버(인스턴스 멤버)**

- 멤버할당: 멤버는 객체마다 별도로 존재한다
- 생성시기: 객체 생성시에 멤버가 생성
- 공유여부: 공유되지않는다

**static 멤버(클래스 멤버)**

- 멤버할당: 멤버는 클래스당 하나가 생성된다
- 생성시기: 클래스 로딩시에 멤버가 생성된다
- 공유여부: 동일한 클래스의 모든 객체들에 의해 공유된다

### **new String()과 리터럴("")의 차이에 대해 설명해주세요.**

- **new String()** new 키워드로 새로운 객체를 생성하기 때문에 Heap 메모리 영역에 저장되고,
- **리터럴("") :** Heap 안에 있는 String Constant Pool 영역에 저장됩니다.
- 문자열 상수 풀.
    - 동일한 문자열이 이미 존재하는 경우 새로운 문자열을 생성하지 않으므로 메모리 공간을 절약
    - 문자열 캐싱을 사용하므로 JVM은 문자열이 문자열 상수 풀에 존재하는지 빠르게 확인

### **ThreadLocal 에 대해서 설명해주세요.**

- ThreadLocal은 한 쓰레드에서 읽고 쓰여질 수 있는 변수를 할당하여 접근할 수 있도록 합니다.
- 멀티 쓰레드 환경에서 각 쓰레드마다 get(), set() 메서드를 통해 독립적으로 변수에 접근할 수 있습니다. 말그대로 Thread 내부에서 사용하는 지역변수입니다.
- ThreadLocal의 기본 사용법은 다음과 같습니다.
    1. ThreadLocal 객체를 생성합니다.
    2. ThreadLocal.set() 메서드를 이용하여 현재 thread의 로컬 변수에 값을 저장합니다.
    3. ThreadLocal.get() 메서드를 이용하여 현재 thread의 로컬 변수값을 읽어옵니다.
    4. ThreadLocal.remove() 메서드를 이용하여 현재 thread 로컬 변수값을 삭제합니다.

### **멀티쓰레드 환경에서 ThreadLocal 을 사용할 때 유의할 점에 대해 설명해주세요.**

- 스레드 로컬은 스레드 풀(thread pool)을 사용하는 환경에서는 주의해야 합니다. 스레드가 재활용될 수 있기 때문에 사용이 끝났다면 스레드 로컬을 비워주는 과정이 필수적이다.

### **예외처리를 하는 방법에 대해 설명해 주세요.**

1. **try, catch**
    - 예외가 발생했을때 우리는 try ... catch ... finally 라는 키워드로 예외를 처리할 수 있거나 메소드를 호출한 곳으로 던질 수 있습니다. 한 가지 중요한 점은 자바에서 모든 예외는 Exception이라는 클래스를 상속받습니다.
    - try 블록 : 가장 먼저 실행되는 코드로 여기에서 발생한 예외는 catch 블록에서 처리된다.
    - catch 블록 : try 블록에서 발생한 예외 코드나 예외 객체를 인수로 전달받아 처리한다.
    - finally 블록 : 예외의 발생 유무에 상관없이 마지막에 무조건 실행된다.
2. **throws** 말그대로 예외를 던지는 것을 뜻합니다.
    - 예외를 여기서 처리하지 않을테니 나를 불러다가 쓰는 녀석에게 에러 처리를 전가하겠다는 의미이며 코드를 짜는 사람이 이 선언부를 보고 어떤 예외가 발생할 수 있는지도 알게 해줍니다.

### Error와 Exception의 차이를 설명해주세요

**Error** 는 컴파일 시 문법적인 오류와 런타임 시 널포인트 참조와 같은 오류로 프로세스에 심각한 문제를 야기 시켜 프로세스를 종료 시킬 수 있습니다.

**Exception** 은 컴퓨터 시스템의 동작 도중 예기치 않았던 이상 상태가 발생하여 수행 중인 프로그램이 영향을 받는 것우로 예를 들면, 연산 도중 넘침에 의해 발생한 끼어들기 등이 이에 해당합니다.

프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우를 프로그램 오류라 하고, 프로그램 오류에는 에러(error)와 예외(exception) 두 가지로 구분할 수 있습니다. 에러는 메모리 부족이나 스택오버플로우와 같이 발생하면 복구할 수 없는 심각한 오류이고, 예외는 발생하더라도 수습할 수 있는 비교적 덜 심각한 오류입니다. 이 예외는 프로그래머가 적절히 코드를 작성해주면 비정상적인 종류를 막을 수 있습니다.

Error의 상황을 미리 미연에 방지하기 위해서 Exception 상황을 만들 수 있으며, java에서는 try-catch문으로 Exception handling을 할 수 있습니다.

### Unchecked Exception과 Checked Exception의 차이점은 무엇인가?

1. **Checked Exception** : 예외처리가 필수이며, 처리하지 않으면 컴파일되지 않습니다. JVM 외부와 통신(네트워크, 파일시스템 등)할 때 주로 쓰입니다.
    - RuntimeException 이외에 있는 모든 예외
    - IOException, SQLException 등
2. **Unchecked Exception** : 컴파일 때 체크되지 않고, Runtime에 발생하는 Exception을 말합니다.
    - RuntimeException 하위의 모든 예외
    - NullPointerException, IndexOutOfBoundException 등

### **Checked Exception 과 Unchecked Exception 의 transaction 예외 처리 방식을 설명해주세요.**

1. **Checked Exception**
    - 명시적으로 예외 처리를 강제하기 때문에 checked exception이라 부른다.
    - 이는 Exception 클래스를 직접 상속하거나 IOException, SQLException 같은 하위 클래스를 사용하는 경우에 해당합니다.
    - try~catch, throws 등을 사용하여 예외를 던진다.
    - 예외처리를 하지 않으면 IDE에서 컴파일시 에러를 뱉는다.
    - compile Exception으로 runtime exception 하위 exception을 제외하고 말한다.
2. **Unchecked Exception**
    - 강제하지 않기 때문에 UnChecked Exception이라 부른다.
    - 이 예외들은 런타임 시 발생하며, 프로그래머의 실수로 나타나는 경우이다.
    - 예외처리를 하지 않아도 IDE에서 에러를 뱉지 않는다.
    - Runtime Exception으로 실행 중 발생하는 Exception을 말한다.
    - Runtime Exception 하위의 NullPointException, IndexOutOfBoundException 등이 있다.
    - 트랜잭션을 그냥rollback
    - check 는 rollback 안시키고 커밋한다고 한다

### Checked Exception과 Unchecked Exception에 대해 설명해주세요. 관련하여, 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?

- 둘의 차이는 RuntimeException을 상속하는가의 여부에 따라 다릅니다.
- RuntimeException을 상속하면 UncheckedException이 됩니다.
- 스프링 트랜잭션 추상화에서 rollback 대상은 바로 UncheckedException입니다.

### **@Transactional 는 어떻게 구현되나요?**

- @Transactional을 메소드 또는 클래스에 명시하면, AOP를 통해 Target이 상속하고 있는 인터페이스 또는 Target 객체를 상속한 Proxy 객체가 생성되며, Proxy 객체의 메소드를 호출하면 Target 메소드 전 후로 트랜잭션 처리를 수행합니다.

### 방어적 복사와 Unmodifiable의 차이점은 무엇인가요?

- unmodifiable은 컬렉션 API에서 만약 복사본이 변경하려고 할 때 예외를 터트린다. 그리고 복사본에서 원본 변경은 못하지만, 원본이 바뀌면 복사본도 바뀐다.

**new ArrayList<>() VS Collections.unmodifiableList의 차이**

- **new ArrayList<>()**는 리스트를 복사할 때 원본 리스트와의 참조를 끊기 때문에 원본 리스트를 변경해도 복사본 리스트에 영향을 주지는 않는다는 장점이 있고, 대신 단순히 List로 복사하기 때문에 복사본 리스트에 add, remove 등의 수정이 가능하다는 단점이 있다.

**Collections.unmodifiableList**는 복사한 리스트의 수정을 막는 것이 핵심이기 때문에

- 복사본 리스트에 add, remove 등의 수정을 가하면 런타임 에러가 발생하여 수정이 불가능하다는 장점이 있고,대신 원본 리스트와의 참조는 끊기지 않아서 원본 리스트를 변경하면 복사본 리스트도 변경되는 단점이 있다.

[https://ksh-coding.tistory.com/77#:~:text=원본 리스트 안의 객체 요소 변경 시 복사한 리스트,한 리스트도 변경된다](https://ksh-coding.tistory.com/77#:~:text=%EC%9B%90%EB%B3%B8%20%EB%A6%AC%EC%8A%A4%ED%8A%B8%20%EC%95%88%EC%9D%98%20%EA%B0%9D%EC%B2%B4%20%EC%9A%94%EC%86%8C%20%EB%B3%80%EA%B2%BD%20%EC%8B%9C%20%EB%B3%B5%EC%82%AC%ED%95%9C%20%EB%A6%AC%EC%8A%A4%ED%8A%B8,%ED%95%9C%20%EB%A6%AC%EC%8A%A4%ED%8A%B8%EB%8F%84%20%EB%B3%80%EA%B2%BD%EB%90%9C%EB%8B%A4).

[Java – Collection – Set](https://blog.breakingthat.com/2018/05/18/java-collection-set/)

[HashMap 자바 구현 까보기](https://www.jongho.dev/java/fundamental/hashmap-자바-구현-까보기/)

[[Java] Garbage Collection(가비지 컬렉션)](https://velog.io/@kwj2435/Java-Garbage-Collection가비지-컬렉션)

[Checked Exception을 대하는 자세 - Yun Blog | 기술 블로그](https://cheese10yun.github.io/checked-exception/)

### 방어적 복사와 얕은 복사 깊은 복사

### **1. 방어적 복사**

내부의 객체를 반환할 때, **객체의 복사본을 만들어서 반환하는 것**을 방어적 복사라고 한다.

방어적 복사를 하게 되면, **복사한 외부의 객체를 변경해도 원본 내부 객체가 변경되지 않는다!**

그런데, 만약 리스트 속 원소가 불변객체가 아니라면 바뀔 수 있다. 

### **2. 얕은 복사**

원본 객체를 복사할 때, 새로운 객체를 만들지만 **원본 객체의 '주소 값'을 참조하는 복사이다.**

따라서 원본이나 복사한 객체나 변경이 되면 서로 영향을 미친다.(call-by-reference와 유사한 개념)

### **3. 깊은 복사**

원본 객체를 복사할 때, 새로운 객체를 만들고 **원본 객체의 모든 값을 복사해서 원본 객체로부터 독립적인 객체를 생성한다. 따라서 원본과 복사한 객체가 독립적이므로 변경이 되어도 서로 영향을 미치지 않는다.** (call-by-values와 유사한 개념)

### **volatile 키워드에 대해 설명해주세요.**

- 읽기, 쓰기의 경우 기본적으로 atomic함(long, double형 제외) (읽기+쓰기는 atomic한 행위 2회이므로 atomic하지 않음)
- volatile 키워드를 사용하면 long, double 형도 atomic하게 읽고 쓸 수 있음
    - long, double primitive 형은 64비트 형태이기 때문에, 32비트씩 나누어서 읽어들이기 때문
    - java의 volatile 키워드는 즉각적으로 메인 메모리에 쓰거나 읽어오는 것을 보장하고, 가시성을 보장하는 키워드
    - 한 쓰레드에서만 쓰기 작업, 다른 쓰레드는 읽기 작업만 할 때 안전성 보장
    - 두 쓰레드가 동시에 쓰기 작업에 들어간다면 동시성 문제가 발생할 수 있음

### **lock을 사용했을 시와 volatile을 사용할 시에, volatile 단점에 대해서 설명해주세요.**

- Multi Thread 환경에서 여러개의 Thread가 write하는 상황이라면 race conditionrace을 해결할 수 없습니다. 이럴 경우에는 synchronized를 사용하여 원자성(atomic)을 보장해야 합니다.

### **synchronized 사용 시 데드락이 발생하는 상황을 설명해주세요.**

- synchronized안에 synchronize가 있을 때, deadlock 발생함. 이는 lock1잡고 있고, lock2를 접근하려 할때, 다른 스레드가 lock2에서 lock 1 잡고 있으면 발생.

### 추상 클래스와 인터페이스의 차이점을 바탕으로 어떤 상황에 어떤 것이 더 적합한지 설명해주세요.

추상 클래스는 유지보수에 용이 맥락에 따라, 달라질 때, 중복을 줄일 수 있어 좋다. 

인터페이스는 협업할 때 좋다. 어떤 기능이 a,b,c 의 기능을 통해 만들어질 때, 모든 기능이 완성되기를 기다릴 수는 없다. 따라서, 이를 인터페이스로 정의하고, 결합도를 낮게 하여 유지보수가 좋게할 수 있다. 

### **자바에서 thread 를 생성하는 방법과 실행하는 방법을 설명해주세요.**

자바에서 스레드를 생성하는 방법은 두 가지가 있습니다.

- **Thread를 상속받는 방법**
    1. Thread 클래스를 상속한 클래스 정의한다.
    2. run() 메소드를 오버라이드하여 스레드 코드 작성한다.
    3. 스레드 객체를 생성한다.
    4. start() 메소드로 스레드를 시작한다.
- **Runnable 인터페이스를 구현하는 방법**
    1. Runnable 인터페이스를 구현하는 클래스를 정의한다.
    2. run() 메소드를 오버라이드하여 스레드 코드를 작성한다.
    3. Runnable 객체를 생성한다.
    4. Thread 객체를 생성한다.
    5. start() 메소드로 스레드를 시작한다.

자바는 다중 상속을 허용하지 않기 때문에 Thread 클래스를 상속받게 되면 다른 클래스를 상속받을수가 없습니다. 그래서 인터페이스인 Runnable로 구현하는 방법이 일반적입니다. 또한 재사용성(reusability)이 높고 코드의 일관성(consistency)을 유지할 수 있기 때문에 보다 객체지향적인 방법이다.

참고로, 사용자가 스레드 객체를 생성하고 **실행요청을 하더라도** **스레드가 실행되는 것은 전적으로 JVM에 의한 스케쥴러에 따릅니다.** 사용자는 Thread의 여러 메소드들을 통해서 JVM에 해당 명령들이 실행되도록 요청하는 것입니다.

- 스레드 Thread 란?

스레드는 프로세스안에서 실질적으로 작업을 실행하는 단위를 말합니다. **자바에서는 JVM(Java Virtual Machine)에 의해 관리됩니다.** 프로세스에는 적어도 한개 이상의 스레드가 있으며, Main 스레드 하나로 시작하여 스레드를 추가 생성하게 되면 멀티 스레드 환경이 됩니다. 이러한 스레드들은 프로세스의 리소스를 공유하기 때문에 효율적이긴 하지만 잠재적인 문제점에 노출될 수도 있습니다.

### **Thread 실행 시 run()으로 수행할 때와 start()로 수행할 때와의 차이를 설명해주세요.**

- run()메서드를 사용할 때
    - 단순히 하나의 프로세스에서 쓰레드를 순차적으로 실행한다.
    - context switching이 발생하지 않는다.
- start()메서드를 사용할 때
    - start0()라는 native 메서드를 활용하여 context switching 수행
    - JVM 내부에서 다수의 콜 스택을 번갈아가며 일처리를 수행하고, 동시에 작업하는 것처럼 보여 주는 것

### **synchronized 를 사용할 시 sychronized method, sychronized block, static sychronized method, static synchonized block 의 4가지 쓰임새 경우에 대해 설명해주세요.**

- **sychronized method**
    - 클래스 인스턴스 에 lock을 겁니다.
    - 인스턴스에 lock을 거는 synchronized 키워드는 synchronized가 적용된 메서드끼리 일괄적으로 lock을 공유합니다.
- **static sychronized method**
    - static이 붙은 synchronized method는 일반적으로 생각하는 static 성질을 갖으므로 인스턴스가 아닌 클래스 단위 로 lock을 겁니다.
    - 다른 인스턴스더라도 static 메서드에 synchronized가 붙은 경우 lock을 공유하는 것을 확인할 수 있습니다.
    - static synchronized method와 synchronized method의 lock은 공유되지 않습니다.
- **sychronized block**
    - 인스턴스의 block 단위 로 lock을 걸고 lock 객체를 지정해야 합니다.
    - block에 this를 명시할 경우 method에 synchornized를 붙인 것처럼 인스턴스 단위로 lock이 걸립니다.
    - block에는 객체를 지정할 수도 있고 class 형식으로 넘기면 해당 class에 lock을 걸 수 있습니다.
- **static synchonized block**
    - this와 같이 현재 객체를 가르키는 표현은 사용할 수 없습니다.
    - static synchronized method 방식과의 차이는 lock 객체를 지정하고 block 범위를 한정 지을 수 있다는 점입니다. 클래스 단위로 lock을 공유한다는 점은 같습니다.
    - block의 인자로 정적 인스턴스나 클래스만 사용합니다.

### Object를 사용하지 않고 generic을 사용하는 이유는 무엇인가요?

- `안정성` 을 맡음.

객체의 타입을 컴파일 시에 체크하기에, 타입 안정성을 높이고

형변환을 할 필요가 없어 코드가 간결해 지고, 프로그램 성능이 향상됨

**문제점** : 위와 같이 ClassCastException 가 발생할 수 있는 가능성이 있다.

코드가 간결해지고, 형변환 코드가 요구되지 않음

=> 제네릭의 사용으로 예외 발생의 위험이 줄어들고, 코드가 간결해지는 안정성 생김

### 제네릭을 사용할 수 없는 경우는?
**new**

ex) `int arr[]= new int[10];`

- heap 영역에 메모리를 할당함
    - > 메모리를 할당하기 위해서는 타입을 알아야 하지만

heap에 메모리가 할당되는 시점(프로그램 실행 시)에서는 타입 T가 무엇인지를 알 수 없음

- *static **

타입 T는 인스턴스 생성 시 어떤 타입인지 결정됨.

- > 모든 객체에 대하여 동일하게 동작해야 하는 static에 타입 변수 T를 사용할 수 없음.
