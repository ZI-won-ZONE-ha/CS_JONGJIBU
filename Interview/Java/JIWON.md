## 자바에서 HashMap에 대해서 설명해주세요

Map은 key - value 쌍 형태로 이루어진 자료구조입니다.

그 중 HashMap은 key를 자바의 `hashCode()` 메서드를 활용하여 key 값을 해싱하여 저장하는 자료구조입니다.

내부적으로 배열을 가지고 있고 key의 해시 값을 배열 인덱스로 하여 값을 저장합니다.

이러한 원리로 O(1)의 시간 복잡도로 데이터를 가져올 수 있습니다.

Hash 함수의 특징으로 인해 key 값에 해시 충돌이 발생할 수 있는데 이를 방지하기 위한 체이닝 방법이 있습니다.

## 자바에 또 HashTable과 HashMap의 차이가 어떻게 되나요?

HashTable은 HashMap이 등장하기 전 사용하던 자료구조로 HashMap과의 차이점으로는 HashMap에는 보조 해시 함수가 존재하여 해시 충돌을 줄이지만 HashTable은 보조 해시 함수가 존재하지 않기 때문에 해시 충돌이 발생할 가능성이 HashMap에 비해 큽니다.

다만 HashTable의 경우 동기화 키워드인 `synchronized` 가 메서드에 포함되어 있어 동기화가 되는 장점이 있습니다.

하지만 프로그래밍할 때 동시성을 고려할 때 `HashTable`보다는 `ConcurrentHashMap` 을 더 자주 쓰게되는데 그 이유는 HashTable은 메서드 전체에 `synchronized` 가 되기 때문에 성능이 떨어지는 단점이 존재하여 엔트리 단위로 `synchronized` 하여 동기화하는 `ConcurrentHashMap` 을 더 자주 사용하게 됩니다.

## HashSet의 내부 구현이 어떻게 되나요?

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/63df875a-66b6-4edb-a79f-9f479b120201)

HashSet은 내부적으로 HashMap을 가지고 있고, HashMap의 Key 값을 활용하여 중복 데이터를 검사할 수 있게 됩니다.

HashMap의 value 값 까지 확인하지 않아도 되므로 value에는 `PRESENT`라는 의미없는 상수를 집어넣어 데이터를 관리합니다.

## Java의 GC에 대해서 설명해주세요

java는 개발자가 직접 메모리를 관리하지 않기 때문에 가비지 컬렉터가 존재합니다.

자바가 컴파일되는 환경인 JVM에 존재하는데, 더 이상 사용이 되지 않는 할당 영역, 즉 garbage를 회수하는 역할을 한다. 

이 수행 방식을 더 자세히 말씀을 드리면 이 동적할당은 기본적으로 heap 영역에서 수행이 되는데, 이 heap 부분을 young과 old 영역으로 나누고 young은 다시 eden, survivor1, survivor2로 나눈다. 

이 상태 에서 동적할당이 일어나면 그 할당 영역은 young 영역 속 eden에 최초로 위치한다. 

그러다가 eden이 가득 차게 되면, 가비지 컬렉터가 실행되어 더 이상 참조되지 않는 것을 삭제하고 남은 것은 survivor1으로 옮긴다. 

young에서 이러한 작업이 반복되다가 참조가 오랫 동안 지속된 영역이 생기면 그것은 old 영역으로 간다. 그러다가 old 영역까지 가득차면 거기서도 mark and sweep 동작이 일어나는 방식이다.

그리고 GC 작업은 현재 프로그램의 모든 작업이 멈추는 stop the world가 발생하기 때문에 이러한 GC 작업의 속도를 빠르게 하는 것이 중요합니다.

## 자바의 메모리 영역에 대해서 설명해주세요

Method Area, Heap Area, Stack Area, PC register, Native method stack으로 구분됩니다.

Method Area는 모든 쓰레드가 공유하는 메모리 영역으로 클래스, 인터페이스, 메서드, 필드, static 변수 등의 바이트 코드를 보관합니다.

Heap Area는 모든 쓰레드가 공유하는 공간으로 new로 생성된 객체들을 모아두는 공간입니다. 동적으로 데이터가 할당되기 때문에 GC가 메모리 관리 하는 영역입니다.

Stack Area는 메서드 작업에 필요한 메모리 공간을 제공합니다. 메서드 호출마다 메서드 만을 위한 공간을 생성하고 호출된 메서드의 파라미터, 지역 변수, 리턴 값 등 메서드 작업에 필요한 값들을 임시로 저장합니다.

PC register 영역은 쓰레드가 어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록을 하는 부분으로 현재 수행중인 JVM 명령의 주소를 가집니다.

Native Method Stack은 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역입니다.

## 람다

Java 8에서 도입된 기능으로 간결한 방식으로 익명 함수를 표현할 수 있게 해주는 기능입니다. 

주로 함수형 프로그래밍 스타일을 지원하고 코드의 간결성을 증가시키는 데 사용됩니다.

람다의 주요 특징으로는 다음과 같습니다.

1. 익명성: 전통적인 함수나 메서드와 달리 이름을 갖지 않습니다.
2. 간결성: 불필요한 문법 (예: **`return`** 키워드, 접근 제한자, 반환 유형) 없이 짧은 코드로 표현됩니다.
3. 함수형 인터페이스: 람다는 함수형 인터페이스의 인스턴스를 생성하는데 사용됩니다. 함수형 인터페이스는 정확히 하나의 추상 메서드만을 포함하는 인터페이스를 의미합니다.

## 함수형 인터페이스

자바의 함수형 인터페이스(Functional Interface)는 오직 하나의 **추상 메소드만을 포함하는 인터페이스**를 의미합니다. 

자바 8에서 도입된 람다 표현식을 사용하여 이러한 인터페이스의 인스턴스를 간단하게 생성할 수 있습니다. 함수형 인터페이스는 `@FunctionalInterface` 어노테이션을 사용하여 명시적으로 정의될 수 있으며, 이 **어노테이션은 해당 인터페이스가 정확히 하나의 추상 메소드만을 가지고 있어야 함을 컴파일러에게 알려줍니다.**

1. Predicate<T>: `T` 타입의 객체를 받아 boolean을 반환합니다.
    - 주요 메소드: `boolean test(T t)`
2. Function<T, R>: `T` 타입의 객체를 받아 `R` 타입의 객체를 반환합니다.
    - 주요 메소드: `R apply(T t)`
3. Consumer<T>: `T` 타입의 객체를 받아 반환값은 없습니다.
    - 주요 메소드: `void accept(T t)`
4. Supplier<T>: 인자를 받지 않고 `T` 타입의 객체를 반환합니다.
    - 주요 메소드: `T get()`
5. UnaryOperator<T>: `T` 타입의 객체를 받아 `T` 타입의 객체를 반환합니다. `Function<T, T>`의 특수한 형태입니다.
    - 주요 메소드: `T apply(T t)`
6. BinaryOperator<T>: 두 개의 `T` 타입 객체를 받아 `T` 타입의 객체를 반환합니다.
    - 주요 메소드: `T apply(T t1, T t2)`

## synchronized

자바의 동기화에 사용되는 키워드로 Monitor 기반으로 구현되었습니다.

synchronized의 사용 위치에 따른 기능

1. 메서드 레벨
    1. 메서드 레벨에 synchronized 키워드를 사용하게 되면 해당 메서드는 한 시점에 하나의 thread 만 들어감을 보장해줍니다.
2. 특정 블록 레벨에 사용할 때
    1. 이 때는 해당 블록 부분이 한 시점에 하나의 thread만 들어감을 보장합니다.
    2. `synchronized(객체) {}` 형태로 블록을 구성하게 되는데 해당 객체를 바탕으로 모니터 락을 생성하기 때문에 만약 다른 객체로 해당 블록에 들어간다면 들어갈 수 있게 됩니다. 즉 하나의 객체에 대해서 락을 만들고 들어갑니다.

동시성을 해결하는 방법으로는 좋은 방법이지만 한 시점에 하나의 thread 만 접근을 허용하기 때문에 성능 상 이슈가 발생할 수 있고, 데드락이 발생할 수 있습니다. 또한 서버가 여러 대 배치된 상황이라면 각 서버마다 synchronized 블록이 활성화되기 때문에 원하지 않는 결과를 야기할 수 있습니다.

그렇기에 Java, Spring 기반의 환경에서는 Redis나 MySQL의 named lock을 활용한 분산락, Spring과 JPA의 도움을 받는 비관적, 낙관적 락 등 다른 방법을 활용할 수 있을거 같고, 자바 환경에서만 문제를 해결해야하는 상황이라면 java.util.concurrent 패키지의 클래스들을 활용하여 synchronized의 범위를 최소화하는 방향으로 설계할 거 같습니다.

## Stream

Java 8에 추가된 기능으로 데이터 소스를 추상화하고, 데이터를 다루는데 자주 사용되는 메서드들을 정의해 놓은 것을 말합니다. 데이터 소스가 무엇이던 간에 같은 방식으로 다룰 수 있기 때문에 재사용성이 높아지는 장점이 있습니다. 배열, 컬렉션등을 동일한 방식으로 다루는 메서드를 제공합니다.

주요 특징으로는 데이터 소스를 변경하지 않는다는 점과 일회성이라는 특징이 있습니다.

stream의 중간 연산을 통해 stream 메서드간 체이닝이 가능하고 최종 연산을 통해 stream의 요소를 소모하거나 수집하는 연산을 진행할 수 있습니다.

## Stream과 for ~ loop의 성능 차이

stream이 for loop에 비해 성능 오버헤드(파이프 라인 연산, 람다 식)가 있긴 하지만 JVM이 이를 최적화하여 크게 성능 차이가 나지 않는 것으로 알고 있습니다.

파이프 라인 출처
https://ittrue.tistory.com/164?category=958774

## Stream 병렬처리

스트림은 `.parallel()`을 사용하여 쉽게 병렬 처리를 할 수 있습니다.

## Stream을 사용할 때 주의해야 할 점

스트림은 재사용이 안되기 때문에 다시 사용하려면 또 stream을 열어야 합니다.

무한 스트림에 빠질 수 있으니 이를 조심해야 합니다. 

연산의 순서에 따라 stream의 결과 값이 달라질 수 있기 때문에 이를 조심해야 합니다.

## stream과 forEach()의 차이

1. 목적 및 사용법:
    - **stream()**:
        - **`stream()`**은 주로 컬렉션과 배열에서 호출되어, 데이터 요소들에 연속적인 연산들을 적용하기 위한 Stream 객체를 반환합니다.
    - **forEach()**:
        - **`forEach()`**는 Iterable 인터페이스에 정의된 메소드로, 컬렉션의 각 요소에 대해 주어진 액션(람다식 혹은 메소드 참조)을 수행합니다.
2. 반환 값:
    - **stream()**:
        - Stream 객체를 반환합니다.
    - **forEach()**:
        - 반환 값이 없습니다. (**`void`** 타입을 반환)
3. 사용되는 클래스/인터페이스:
    - **stream()**:
        - 주로 **`Collection`** 인터페이스를 구현하는 클래스들에서 사용됩니다. (**`List`**, **`Set`** 등)
    - **forEach()**:
        - **`Iterable`** 인터페이스에 정의된 메소드이므로, **`Iterable`** 인터페이스를 구현하는 모든 클래스에서 사용할 수 있습니다.
4. 동작 방식:
    - **stream()**:
        - 데이터를 처리하기 위한 중간 연산과 최종 연산이 가능합니다. 이러한 연산들은 종종 지연 계산되어 최종 연산이 호출될 때만 실제로 수행됩니다.
    - **forEach()**:
        - 각 요소에 대해 주어진 액션을 즉시 수행합니다.
5. 용도:
    - **stream()**:
        - 데이터 변환, 필터링, 그룹화 등 복잡한 연산을 수행할 때 사용됩니다.
    - **forEach()**:
        - 컬렉션의 모든 요소에 대해 특정 작업을 수행하고자 할 때 사용됩니다.

결론적으로, `stream()`은 데이터 스트림을 처리하는 데 사용되며 다양한 연산을 지원하고, `forEach()`는 컬렉션의 각 요소에 대해 특정 작업을 수행하는 데 사용됩니다.

stream forEach 관련 좋은 글

https://tecoble.techcourse.co.kr/post/2020-05-14-foreach-vs-forloop/

https://tecoble.techcourse.co.kr/post/2020-09-30-collection-stream-for-each/
