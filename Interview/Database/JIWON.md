## DB의 인덱스

인덱스는 데이터를 탐색할 때 더 빠르게 데이터를 탐색하기 위해 특정 기준에 따라 정렬하는 방식을 말합니다. 주로 B-Tree 자료구조를 통해 인덱스를 구현합니다. 

다만 인덱스를 생성하는 순간 삽입, 수정, 삭제되는 데이터에 대해서 인덱스 작업이 추가적으로 들어가기 때문에 현재 테이블이 조회 용도로 자주 사용되는지, 데이터 저장, 수정, 삭제 용도로 더 자주 사용되는지 충분히 판단하고 도입해야 합니다.

## Database 기본키와 유일키의 차이점

기본키의 경우 테이블에서 하나의 튜플을 식별하는 용도로 사용되지만 유일키의 경우 단순히 유니크한 값을 가진다는 의미로 사용됩니다.

기본키의 경우 null이 허용되지 않지만, 유일키의 경우 null이 허용됩니다. 그리고 기본키의 경우 하나의 테이블에서 하나만 존재할 수 있지만 유일키의 경우 하나의 테이블에 여러 유일키가 존재할 수 있습니다.

## MySQL InnoDB Primary Key 클러스터링 인덱스

InnoDB의 모든 테이블은 PK를 기준으로 클러스터링되어 저장됩니다.

이는 PK 값의 순서대로 디스크에 저장됨을 의미합니다.

PK의 인덱스는 바로 데이터에 접근하지만, 다른 세컨더리 인덱스는 PK 값을 논리적인 주소로 사용하여 인덱스가 생성됩니다. 세컨데리 인덱스 → PK → 레코드 접근

그렇기에 하나의 로우의 PK가 변경되면 레코드의 물리적인 저장 위치도 바뀌게 됩니다.

이러한 이유로 PK 기반 검색이 상당히 빠르다는 장점과 레코드를 저장하는 과정이 상대적으로 느리다는 단점이 있습니다.

## MySQL에서 유일키

MySQL은 유니크 필드에 대해서 인덱스를 생성합니다. 

테이블에 insert 하여 데이터를 추가할 때 인덱스도 같이 추가하게 되는데, 인덱스를 추가하기 위한 작업으로 현재 필드가 유니크한지 판별하는 작업이 추가적으로 발생하여 다른 인덱스보다 인덱스 추가 작업이 느린 특징이 있습니다.

**유니크 인덱스의 경우 중복된 값을 체크해야 되기 때문에 체인지 버퍼를 사용할 수 없습니다.**

그리고 InnoDB의 경우 유니크 인덱스에서 중복된 값을 체크할 때 읽기 Lock을 걸고, 인덱스를 추가하는 작업에서 쓰기 Lock을 거는데 이 때 데드락이 발생할 수 있습니다.

따라서 유니크 제약을 설정할 때는 정말로 필요한지 판단하고 유니크 제약을 걸어야 합니다.

## MySQL 인덱스 탐색 조건

아래와 같은 경우에는 인덱스를 **작업 범위 결정 조건**으로 활용할 수 없다. 단, 필터링 조건으로는 사용할 수 있다.

- Not Equal로 비교된 경우 (≠, not in, not between, is not null)
- `like ‘%??’`과 같이 뒷 부분 일치로 문자열 패턴 비교
- 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
- Not-Deterministic 속성의 스토어드 함수가 비교 조건에 사용된 경우
- 데이터 타입이 서로 다른 비교 (인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
- 문자열 데이터 타입의 콜레이션이 다른 경우

다중 칼럼 인덱스

- 작업 범위 결정 조건으로 인덱스를 쓰지 못하는 경우
    - 첫 칼럼에 대한 조건이 없는 경우
    - 첫 칼럼이 위 불가 조건에 걸리는 경우
- 작업 범위 결정 조건으로 인덱스를 사용하는 경우
    - 첫 칼럼 ~ 어느 시점 칼럼까지 동등 비교 형태( =, in)
    - i 번째 칼럼에 대해 다음 연산자 중 하나로 비교
        - 동등 비교
        - 크다 작다
        - like 좌측 일치 패턴

## 트랜잭션 격리 레벨 (MySQL 기준)

### Read Uncommitted

각 트랜잭션의 변경 사항이 Commit, Rollback 여부에 관계없이 다른 트랜잭션에서 확인할 수 있다.

Read Uncommitted의 문제는 해당 데이터가 롤백 되더라도 이미 select한 세션에서는 해당 데이터가 정상적이라고 판단한다는 것이다.

**이렇게 트랜잭션이 완료되지 않았음에도 다른 트랜잭션에서 해당 작업의 변경사항을 보는 현상을 Dirty Read라고 한다.**

### Read Committed

온라인 서비스에서 가장 많이 선택되는 격리 수준 중 하나

Commit이 완료된 트랜잭션만 다른 트랜잭션에서 조회가 가능하다.

특정 세션이 데이터를 변경하면 이전 데이터는 언두 영역으로 들어가게 되고 새로운 데이터가 테이블에 들어갑니다.

값을 변경한 세션이 커밋하게 되면 언두 영역의 레코드가 아닌 새롭게 변경된 데이터를 참조할 수 있게 된다.

**Read Committed에서는 Non-Repeatable Read가 발생한다.**

### Repeatable Read

MySQL의 **InnoDB 엔진이 기본으로 사용하는 격리 수준이다.**

Binary log를 가진 MySQL 서버에서는 해당 격리 수준을 최소로 사용해야 한다.

이 격리 수준에서는 Non-Repeatable read가 발생하지 않는다.

**InnoDB 엔진이 롤백될 상황을 대비하여 변경 전 레코드를 undo 공간에 백업하고 실제 레코드 값을 변경해준다.**

→ 이러한 변경 방식을 **MVCC**라고 한다.

**언두 영역에 백업된 데이터를 바탕으로 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장해준다.**

**Repeatable Read에서는 MVCC를 보장하기 위해 실쟁 중인 트랜잭션 중 가장 오래된 트랜잭션 번호보다 앞선 트랜잭션 번호를 가지는 언두 영역의 데이터를 삭제할 수 없다.**

다만 Repeatable Read는 **Phantom Read가 발생한다.**

**다른 트랜잭션에서 수행한 변경 작업에 의해 레코드 집합의 결과가 달라지는 현상을 Phantom Read라고 한다.**

**InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락으로 인해 Phantom Read가 발생하지 않는다.**

## InnoDB의 언두 영역과 리두 영역

### **Undo 영역 (Undo Logs):**

1. **목적**:
    - Undo 로그는 데이터 변경을 롤백하기 위한 이전 상태의 데이터를 저장합니다.
    - 롤백이 필요한 상황:
        - 트랜잭션이 실패하거나 사용자에 의해 취소된 경우.
        - 동시성 제어를 위해, 다른 트랜잭션에 의해 변경된 데이터의 이전 버전을 읽기 위해 (비록 그 트랜잭션이 아직 커밋되지 않았을지라도)
2. **동작**:
    - 트랜잭션에 의해 데이터가 변경될 때마다, InnoDB는 해당 데이터의 원래 상태를 Undo 로그에 기록합니다.
    - 트랜잭션이 롤백되면, Undo 로그를 사용하여 데이터를 원래 상태로 되돌립니다.
3. **생명 주기**:
    - Undo 로그는 트랜잭션의 생명 주기 동안 필요하며, 트랜잭션이 커밋된 후에도 일정 시간 동안 유지될 수 있습니다. 이는 MVCC (Multi-Version Concurrency Control)에서 오래된 데이터의 버전을 읽기 위해 필요하기 때문입니다.

### **Redo 영역 (Redo Logs):**

1. **목적**:
    - Redo 로그는 시스템 장애나 충돌 이후 데이터베이스를 복구하기 위한 목적으로 사용됩니다.
    - 데이터 변경이 디스크에 즉시 기록되지 않더라도, 변경 내용은 Redo 로그에 즉시 기록되므로 데이터의 무결성이 유지됩니다.
    - MySQL 장애 시 Buffer pool에 저장되어 있던 데이터의 유실을 방지(데이터 복구)하기 위해 사용된다.
    - DB에서 커밋이 발생한다고 바로 디스크에 들어가는 것이 아닌 버퍼 풀에 들어갔다 한 번에 디스크로 값을 넣기 때문에 리두 영역이 필요합니다.
2. **동작**:
    - 트랜잭션이 데이터를 변경할 때, 해당 변경 사항은 먼저 Redo 로그에 기록됩니다.
    - 이후, 변경 사항은 메모리에 있는 버퍼 풀(buffer pool)에서 디스크의 실제 데이터 파일로 비동기적으로 쓰여집니다.
    - 시스템이 비정상적으로 종료된 경우, Redo 로그를 사용하여 마지막으로 커밋된 상태까지 데이터베이스를 복구할 수 있습니다.
3. **생명 주기**:
    - Redo 로그는 원형 방식으로 관리됩니다. 이전 로그가 더 이상 필요하지 않을 때 (예: 해당 로그 내의 모든 변경이 디스크에 안전하게 저장된 경우) 재사용됩니다.

InnoDB의 이러한 로깅 메커니즘은 데이터 무결성과 ACID 속성을 유지하는 데 중요한 역할을 합니다.
