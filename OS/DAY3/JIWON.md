## Memory 관리

---

프로세스를 위해 메모리 할당, 회수, 보호하는 활동을 Memory 관리라 한다.

**Memory는 한정적이고 Memory를 할당 받아야 하는 프로그램은 많으므로 이를 효율적으로 관리해야 한다.**

→ 메모리 관리의 목적

## Memory 관리 정책

---

### Fetch Policy

디스크에서 메모리로 프로세스를 반입할 시기를 결정하는 정책으로 2가지 방법이 있다.

- Fetch on demand
    - OS, System Program, User Program 등 요청에 따라 실행할 프로세스를 메모리에 적재하는 방법
    - 고전적인 방법으로 효과적인 메모리 사용 가능
- Anticipatory fetch
    - System 요청을 미리 예측하여 메모리에 적재하는 방법
    - 성능 이점이 생긴다.
    - 단, 정확하게 예측하지 않으면 불필요한 데이터도 가져오기 때문에 적절한 예측 알고리즘이 필요하다.

두 방식은 메모리 용량과 성능 사이의 Trade off가 존재한다.

### Placement Policy

디스크에서 꺼내온 프로세스를 메모리의 어느 위치에 저장할지 결정하는 정책

최초 적합, 최적 적합, 최악 적합 등 여러 정책이 존재한다.

### Replacement Policy

메모리가 충분하지 않을 때 어떤 프로세스를 메모리에서 제거할지 결정하는 정책

FIFO, LRU 등 여러 알고리즘이 존재한다.

## Memory Structure, Memory Mapping

---

메모리는 **주소가 연속적으로 되어있는 구조**이다.

메모리의 주소는 2가지 관점에서 볼 수 있다.

### Logical Memory

개발자가 프로그래밍에 사용하는 **논리적인 메모리 공간**을 말한다.

### Physical Memory

실제 데이터, 프로그램을 저장하는 용도로 사용되는 **물리적인 메모리 공간**을 말한다.

### Mapping

Logical Memory와 Physical Memory를 서로 매핑해줘야 CPU에서 프로세스를 실행할 수 있다.

이러한 두 **Memory를 서로 매핑해주는 역할을 하는 것이 바로 MMU(Memory Management Unit)이다.**

MMU가 두 주소를 변환하는 방법은 고정 분할, 동적 분할, 페이징, 세그멘테이션 등 여러 방법이 존재한다.

### Binding

Logical Memory를 실제 메모리(Physical Memory)에 할당해줘야 하는데 이를 Binding이라고 한다.

Binding 시점에 따라 compile time, Loading time, Execution time으로 나뉜다.

- compile time
    - 프로세스가 메모리에 적재될 위치를 컴파일 시점에 안다면 물리적 주소를 생성할 수 있다. → 동적으로 바인딩하지 않고 특정 위치에 바인딩
    - 이 방법은 컴파일 시점에 메모리 위치가 고정적으로 결정되기 때문에 우리가 현재 사용하는 다중 프로세스, 쓰레드 환경에서는 사용하기 어렵다.
    - 쉽게 설명하자면 프로세스가 실행될 물리 메모리 위치가 이미 정해진 경우를 말한다.
- Loading time
    - 프로그램의 메모리 주소가 Loader에 의해 결정되는 방식이다.
    - 프로그램이 메모리에 적재되는 순간 주소를 결정하기 때문에 compile time보다 더 유연하게 메모리를 사용할 수 있다.
    - 다만, 이미 프로그램이 실행되어 메모리에 적재되면 메모리 위치를 바꿀 수 없는 단점이 있다.
- Execution time
    - 프로그램이 실행되는 상태에서도 메모리 주소를 변경할 수 있는 방식
    - 메모리 관리가 아주 좋다 → 적재된 메모리를 유연하게 옮길 수 있어서
    - 현재는 이 방식을 자주 사용한다.

## Dynamic Loading

---

바인딩을 최대한 늦춰 실행 직전에 주소를 확정하여 효율적으로 메모리를 사용하는 방법

프로그램의 모든 루틴을 메모리에 넣지 않는다.

메인 프로그램만 먼저 메모리에 넣고, 메인 프로그램에서 특정한 함수나 다른 루틴이 필요한 경우 해당 함수, 루틴을 메모리에 적재하여 사용하는 방식이다.

→ 당장 사용하지 않는 루틴들을 메모리에 적재하지 않음으로 효율적으로 메모리를 사용할 수 있다.

## Overlay

---

실행하려는 프로그램이 메모리보다 큰 경우가 발생할 수 있다.

이 때 당장 필요하지 않은 프로그램의 일부는 Overlay(중첩) 영역으로 설정할 수 있다.

Overlay 영역에 프로그램을 실행하면서 필요한 모듈들을 불러다가 사용하는 방식

## Swapping

---

CPU 할당이 끝나고 수행 완료, 대기 등 다른 상태가 되는 프로세스는 보조 기억 장치로 보내고 (Swap out) 새롭게 CPU를 할당받는 프로세스는 메모리에 적재(Swap In)

## Memory Contiguous Allocation

---

하나의 프로세스를 메모리 주소 공간에 연속적으로 할당하는 방식

### Multi Programming 환경

- Fixed Partition
    - 메모리를 여러 개의 고정된 크기로 분할하여 프로세스 적재하는 방식
    - 고정된 크기의 파티션을 사용하므로 파티션 크기보다 큰 프로세스는 적재할 수 없다
    - 파티션 크기보다 작은 프로세스를 적재하면 내부 단편화(Internal Fragmentation) 발생
    - 각 프로세스를 어떻게 넣느냐에 따라 들어갈 수 있는 프로세스의 수가 달라지고 내부 단편화로 인해 발생하는 hole의 크기도 달라진다.
    - 프로세스를 어느 영역에 배치할지 결정하는 작업 스케줄러가 필요하다!
- Variable Partition
    - 고정된 경계를 없애고 각 프로세스가 필요한 만큼 메모리 할당
    - Partition이 고정되어 있지 않아 효율적인 메모리 사용이 가능하다.

### Variable Partition에서 Allocation 방식

- First-fit
    - 사용가능한 공간 중 충분히 큰 **첫 번째 공간에 할당**
    - 검색 시간 최소화가 목적
    - 최소한의 검색으로 할당하기 때문에 공간 활용률이 떨어진다.
    - 만약 Hole의 총량보다 작은 프로세스가 있더라도 Hole이 각각 떨어져있기 때문에 프로세스가 접근하지 못하는 경우가 발생한다. → 외부 단편화 발생 가능 (external fragmentation)
- Best-fit
    - 프로세스가 현재 **들어갈 수 있는 공간 중에서 가장 작은 공간에 할당**
    - hole 사이즈를 최소화 하는게 목적
    - 공간 활용률은 좋지만 할당 과정에서 오래 걸린다. → 일일히 찾아야 함
- Worst-fit
    - 프로세스가 현재 **들어갈 수 있는 공간 중에서 가장 큰 공간에 할당**
    - 남은 hole에 다른 프로세스 할당 가능성이 커져 메모리 활용에서 유용하다.
    - Best-fit과 Worst-fit 중 뭐가 더 메모리 활용이 유리할지는 판단하기 어렵다.

### Variable Partition에서 메모리 관리하기

- 통합
    - 하나의 작업이 끝났을 때 서로 빈 공간이 있는 메모리를 하나로 합치는 방법
    - 비어있는 홀이 연속적인 경우 둘을 합쳐 더 큰 hole로 만들어준다.
- 압축
    - 현재 사용 중인 메모리를 적절히 움직여 다 붙이고 큰 hole을 만드는 방법
    - 메모리에 적재된 프로세스의 메모리를 동적으로 이동시킨다.
    - execution time binding일 때 사용 가능하다.
    - 압축하는 동안 시스템이 모든 일을 그만둔다. → 실시간 시스템에서 사용하면 큰일남
    - 압축하는 과정에서 시스템 자원 cost가 크다.
    - 성능을 포기하고 메모리 효율을 높이는 방법

## Memory Non-Contiguous Allocation

---

하나의 프로세스가 **연속적이지 않은 메모리 주소 공간**을 가지는 방법

현재 시스템에서 자주 사용하는 방식이다.

### Paging

작업을 크기가 동일한 페이지로 나누어 처리하는 방법

프로세스를 페이지로 나누어 메모리에 할당한다.

paging 과정

- 프로세스에 필요한 페이지를 결정하고 페이지 번호 부여
- 메모리의 비어있는 frame을 찾고 프로세스 적재할 위치 파악
- 프로세스의 페이지를 빈 프레임에 적재

> 페이지 → Logical Space
프레임 → Physical Space
> 

페이지와 프레임을 매핑해주는 테이블이 필요한데 이를 Page Table이라 한다.

paging 특징

- 메모리 효율적으로 사용 가능
- 외부 단편화 발생하지 않음 그러나 마지막 페이지에서 내부 단편화는 발생할 수 있다.
- 페이지 관리 부담이 있다

계층형 Page Table

- Logicla address가 커져 페이지 테이블이 커지면 메모리를 많이 먹게되어 이슈가 발생할 수 있다. → 프로세스마다 불 필요하게 거대한 페이지 테이블을 가지게 된다.
- 이 때 Page Table을 계층적으로 두어 문제를 해결할 수 있다.

<img width="655" alt="image" src="https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/ef4a371e-459f-480a-9ef7-77b2a510ebd3">

### TLB (Translation Lock-aside Buffer)

Page Table에 접근하지 않고 물리 주소를 찾기 위해 사용하는 캐시이다.

→ Page Table이 메모리에 있기 때문에 메모리에 접근을 자주하게 되는 문제를 해결할 수 있다.

최근에 사용한 페이지만 연관 레지스터 유지

→ 캐시의 원리 중 하나인 많이 참조한 메모리 정보를 또 참조하는 경향이 있다는 지역성을 이용한 방식이다.

### Shared Page

여러 프로세스가 사용하는 코드 공유

Paging 방식에서 프로세스를 메모리에 연속적으로 할당하지 않아도 되기 때문에 가능한 방법

읽기만 가능해야된다. → 쓰기가 가능해지면 문제가 발생할 수 있다. (동시성 이슈)ㄴ

### Segmentation

연관된 기능을 수행하는 하나의 모듈로 분할하는 방식 

고정적이지 않은 크기를 가진다.

메모리를 Variable Partition으로 나눠서 할당

외부 단편화 발생 가능하다.

## Virtual Memory

---

메모리를 관리하는 또 다른 방법이다.

사용자와 논리적 주소를 물리적으로 분리하여 사용자가 메인 메모리 용량을 초과한 프로세스에 주소를 지정하여 메모리를 제한 없이 사용할 수 있도록 하는 개념

현재 필요한 부분만 메모리에 load하고 나머지 부분은 디스크, ssd 등에 저장해두는 방식

프로세스에는 가상의 주소 (Virtual Address)를 준다.

## Demand Paging

---

실제로 CPU에서 처리해야 되는 프로세스의 page를 메모리에 올리는 것을 말한다.

실행 중인 프로세스들의 요구 페이지만 메모리에 적재하여 프로세스의 모든 페이지를 메모리에 적재하지 않음으로 더 많은 프로세스를 사용할 수 있게 해준다.

## Page Fault

---

만약 내가 원하는 page가 현재 메모리에 올라오지 않았다면 어떻게 될까?

이런 상황을 Page Fault라고 한다.

Page Fault가 발생한 경우 아래와 같은 작업이 발생한다.

1. 가상 주소에 access
    1. TLB를 체크하고 if TLB에 있다면? 꺼내오고 break;
2. Page Table을 검사하여 현재 메모리에 있는 페이지인지 아닌지 확인한다.
3. 현재 메모리에 없다면 Page Fault가 발생한다.
4. Page Fault가 발생하면 제어권을 OS에게 넘기고 OS는 해당 페이지를 가져온다.
5. 메모리에서 빈 공간을 찾는다.
6. 빈 공간을 찾는다면 넣어주고 만약 빈 공간이 없다면 페이지 교체 알고리즘으로 페이지를 하나 내보낸다.
7. Page가 적재 되었음을 알려주고 Page Table 정보를 수정한다.
8. 프로세스가 다시 시작된다.

## Page 교체 알고리즘

---

### OPT(Optimal)

가장 먼 미래에 참조 될 페이지를 내보내는 방식

최적의 결과를 얻지만 미래를 예측하는게 불가능하다.

### FIFO(First In First Out)

제일 먼저 들어온 페이지를 내보내는 방식

가장 간단한 알고리즘

다만 계속 상주해야되는 페이지가 있다면 좋지 않다. → 내보내질 수도 있기 때문에

frame이 늘어날 때 페이지 부재 비율이 증가하는 현상이 발생할 수 있다. → Belady’s anomaly

### LRU(Least Recently Used)

가장 오래전에 참조한 페이지를 내보내는 방식

시간 지역성에 근거한 알고리즘

Optimal에 가장 근접한 알고리즘, 많은 OS가 해당 알고리즘을 사용한다.

참조된지 얼마나 지났는지 체크하는 로직이 필요하다는 단점이 있다.

LinkedList를 이용해 구현 가능 (Java의 Linked List는 Double ended Queue)

### LFU**(Least Frequently Used)**

참조 횟수가 가장 적은 페이지를 지우는 방식

만약 참조 횟수가 같은 경우라면 오래전에 참조한 페이지를 내보낼 수 있게 로직을 설계해주면 더 좋다.

아닐 경우 랜덤하게 내보낸다.

다만, 가장 최근에 불러온 페이지가 다시 나갈 수도 있는 단점이 있다.

Heap을 이용해 구현 가능

### MFU(*****Most Frequently Used)*****

가장 자주 사용한 페이지는 곧 안쓰일거라는 가정에 만들어진 알고리즘

## Thrashing

---

프레임이 충분하지 않아 프로세스들이 서로의 페이지를 뺏는 과정에서 Page Fault가 자주 발생하여 작업이 제대로 진행되지 않는 상황을 말한다.

Page를 스왑하는 과정이 자주 발생하여 CPU의 idle time이 증가한다.

일부 시스템에서는 CPU의 사용률이 낮다는 정보를 Page Fault가 아닌 프로세스가 많이 돌고 있지 않다고 판단하여 프로세스를 더 주입하기도 한다. → 상황이 더 악화될 수 있다.

## Thrashing 예방 방법

---

지역성을 기반으로 하는 Working Set을 두어 많이 참조되는 페이지 집합을 한번에 상주시켜 예방한다.

 Page fault frequency, 즉 페이지 부재 빈도율을 체크하여 부재율이 극단적으로 커지거나 작아질 때마다 프로세스에게 할당하는 프레임의 크기를 유동적으로 조절하여 Thrashing을 예방하기도 한다.
