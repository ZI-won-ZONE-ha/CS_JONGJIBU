# ****Kafka를 활용한 이벤트 기반 아키텍처 구축****

https://www.youtube.com/watch?v=DY3sUeGu74M

## 이벤트 기반 아키텍처를 왜 선택했는지

### 배달 시스템의 복잡도 증가

초창기 설계: 배달만 잘해라

현재 설계: 요구사항, 배달 기능 추가로 인해 배달 시스템의 복잡도가 증가함 (알림, 배달시간, 통계, 쿠폰)

복잡도를 낮추고자 배달과 배달이 아닌 기능을 분리하려고 함

→ 대부분 기능들이 배달과 강한 일관성을 필요로 하지 않는 기능들임

> 강한 일관성
**배달이 변경될 때 배달에 관련된 기능들이 동시에 변경되어야 하는 일관성**
주문 → 결제는 동시에 일어나야함 (강한 일관성)
> 

**강한 일관성을 필요로 하지 않기 때문에 언젠가 반영되면 된다! (준 실시간성)**

→ 결과적 일관성을 가진다고 표현한다.

**이러한 결과적 일관성을 이벤트로 표현하면서 이벤트 기반 아키텍처를 선택하게 됨**

복잡해지는 배달 시스템을 배달 + 배달 외 기능으로 나눌 수 있음

→ **배달은 배달만 잘 수행하고 나머지 기능은 이벤트를 통해 전달!**

### 이벤트는 어떤 정보를 가져야 할까??

이벤트의 구성 요소

- 대상
- 발생 시간
- 행동

배달 시스템에서의 이벤트: 배달에서 발생한 행위를 알려주고 싶다.

이를 바탕으로 뽑은 이벤트의 구성요소

- 대상
    - 어떤 배달이 변경되었는지 알려주는 것
    - 식별자 정보를 제공
    - **배달이**
- 행동
    - 이미 벌어진 사건이므로 과거형으로 표현
    - **배차되었다**
- 정보
    - 행위와 관련된 값들을 표현
    - **XX 라이더에게**
    - 필요하다면 행위 외의 값 추가 가능
- 시간
    - 행위가 발생한 시간을 표현
    - **11시에**

이러한 구성 요소를 바탕으로 다양한 도메인 이벤트 표현 가능

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/eec41491-ab76-43e5-88f2-6cea6ae5d654)

### 이벤트 기반 아키텍처의 좋았던 점

요구사항이 추가되더라도 배달 자체의 복잡도는 그대로 유지 가능

→ 배달은 그냥 배달을 하면되고 추가적인 요구사항은 이벤트로 전달하면 됨

다른 도메인과 결합도가 감소함

도메인 히스토리 파악이 용이하다. → 데이터 분석에서 좋음 (언제 어디서 배달이 시작되는지 파악하기 쉬워짐)

### 주의할 점

풍부한 정보를 기반으로 이벤트를 구축할 때 주의할 점

- 이벤트 데이터의 무분별한 추가 주의
    - **행위자 기반의 데이터 정의 필요!!**
    - 소비처의 데이터 요구에 무조건 응해주면 안된다. → 발행처가 영향 받을 수 있음
- 이벤트의 순서가 굉장히 중요하다.

## 이벤트 파이프라인

이벤트 순서를 보장하면서 안정적으로 발행하는 방법

### 메시지 브로커

어떤 메시지 브로커를 선택해야 할까?

카프카 선택 이유

- 순서 보장
    - 토픽의 파티션을 통해 key별로 순서를 보장할 수 있다.
    - 적절한 key를 기반으로 이벤트를 발행하면 순서 보장 가능
    - ex) 배달 시스템 → 배달 번호로 순서 보장
- 고성능 고가용성
    - 실시간 이벤트를 처리할 고성능 고가용성 제공
    - 파티션 증설을 통한 파티션 증대
    - 메시지 배치 발행
    - 페이지 캐시
    - 브로커 클러스터: 한 대의 브로커에 이슈가 생겨도 다른 브로커가 이를 해결해줌
- 통합 도구
    - Kafka Streams, Kafka Connect 등 다양한 통합 도구 제공
    - 이를 통해 시스템 개선 및 확장 가능
- 전담팀 지원
    - 카프카 클러스터 관리, 모니터링 및 지원도구 제공

### Transactional outbox Pattern

여러 이슈로 이벤트 발행에 실패하는 경우가 있다.

→ 이벤트 재발행 등으로 이벤트 순서가 바뀌게 됨 → 시스템 장애

이러한 이슈를 해결하기 위해 도입함

**DB 시스템의 트랜잭션을 활용하여 이벤트를 테이블에 적재하고 이후 메시지 릴레이가 메시지 발행을 보장해주는 패턴**

- 발행해야 할 이벤트를 도메인 트랜잭션과 묶어 DB 테이블에 저장
    - 도메인의 상태와 이벤트의 일관성 보장
- 메시지 릴레이가 테이블을 읽어 이벤트를 발행
    - 이벤트 순서를 보장할 수 있게 됨

이벤트 유실, 순서 변경의 문제 해결 방안으로 도입함

### 메시지 릴레이 구현

구현 시 고려사항

- 저비용
- 안정성
- 처리량

고려사항을 바탕으로 Debezium을 결정함

> Debezium
DB 시스템의 변경 사항을 감지하고 타 시스템에 전송해주는 오픈소스
CDC에서 자주 사용됨
> 

### Debezium이 선택된 이유

- 저비용
    - 카프카 커넥트로 제공됨
    - 커넥트 환경이 구축되면 설정을 통해 사용할 수 있다.
- 안정성
    - Binary Log를 통해 순서를 보장, offset을 활용해 발행 보장
- 처리량
    - outbox 테이블의 파티셔닝을 통한 처리량 증가

## 이벤트 활용 사례

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/82c3a2c9-b961-4a76-9377-92aa69ec08bd)

이벤트 스트림을 통해 시스템 확장 및 개선에 도움이 됨

**이벤트 스트림을 바탕으로 CQRS 적용**

→ 이벤트 스트림을 기반으로 쿼리 모델을 구축

→ 조회가 쿼리 모델 사용

→ 조회와 커맨드가 서로 독립적이라 장애가 퍼지지 않게 됨

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/71803198-4f0b-4737-89df-6f13c91beeeb)

카프카에 저장된 이벤트 스트림을 기반으로 데이터 분석 환경을 구축함

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/7bfcaa2b-4496-4ded-979f-560bd8444f2e)

배치를 통한 집계 처리에서 이벤트 스트림을 활용해 집계 처리로 변경
