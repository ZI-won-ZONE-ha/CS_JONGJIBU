# Chapter 9. 옵티마이저와 힌트


## 옵티마이저 개요

---

DBMS의 옵티마이저는 쿼리를 분석하여 최적의 실행 계획을 제공한다.

→ 각 테이블의 데이터가 어떤 분포로 저장되었는지 통계 정보를 참조

쿼리의 실행 계획을 알아야 최적화된 방법으로 실행 계획을 수립할 수 있게 유도할 수 있다.

### 쿼리 실행 절차

1. SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
2. SQL 파싱 정보를 확인하면서 어떤 테이블로부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다. → 최적화 및 실행 계획 수립 단계로 옵티마이저가 처리한다.
3. 2번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용하여 스토리지 엔진으로부터 데이터 가져온다.

1번째 단계는 SQL 파싱이라고 한다.

2번째 단계는 아래의 내용을 처리한다.

- 불필요한 조건 제거 및 복잡한 연산 단순화
- 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블 읽을지 결정
- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
- 가져온 레코드들을 임시 테이블에 넣고 다시 한 번 가공해야 하는지 결정

### 옵티마이저의 종류

옵티마이저는 데이터베이스 서버에서 두뇌 역할을 담당

현재 대부분 옵티마이저는 비용 기반 최적화

- 규칙 기반 최적화: 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식 → 통계 정보를 조사하지 않고 실행 계획이 수립되기 때문에 같은 쿼리에 대해 같은 실행 계획이 수립된다. → 별로임
- 비용 기반 최적화: 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 각 단위의 작업의 비용 정보와 대상 테이블의 통계 정보를 이용해 실행 계획별 비용을 산출

## 기본 데이터 처리

---

기본 데이터를 가공하기 위한 MySQL 서버의 알고리즘을 살펴보자

### 풀 테이블 스캔과 풀 인덱스 스캔

MySQL 옵티마이저는 다음과 같은 조건이 일치할 때 주로 풀 테이블 스캔을 선택한다.

- 테이블의 레코드 건수가 너무 작아서 인덱스 스캔보다 풀 테이블 스캔이 빠른 경우 (테이블이 1개의 페이지로 구성된 경우)
- where 절이나 on절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우 (인덱스 B-Tree를 샘플링해서 조사한 통계 정보 기준)

DBMS는 풀 테이블 스캔을 실행할 때 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장한다.

InnoDB는 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 실행된다. → 리드 어헤드: 어떤 데이터가 필요해질것을 예측하여 요청이 오기 전에 디스크에 읽어 버퍼 풀로 가져다 두는 것

→ 백그라운드 스레드가 읽기 작업을 넘겨 받아 여러 페이지를 미리 가져와 쿼리가 상당히 빨리 처리된다.

`innodb_read_ahead_threshold` 시스템 변수로 언제부터 리드 어헤드를 시작할지 설정 가능

풀 인덱스 스캔도 마찬가지로 리드 어헤드가 일어난다.

`count(*)` 를 가져오는 쿼리는 레코드의 건수만 필요하므로 용량이 작은 인덱스만 가져와도 된다.

→ 풀 인덱스 스캔이 발생한다.

### 병렬 처리

MySQL 8.0부터 쿼리의 병렬 처리가 가능하다.

병렬 처리: **하나의 쿼리를 여러 스레드가 동시에 처리하는 것**

`innodb_parallel_read_ahead` 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지를 변경할 수 있다.

병렬로 쿼리를 처리하게 하는 힌트나 옵션은 없다.

→ 아무런 where 조건 없이 단순히 테이블 전체 건수를 가져오는 쿼리만 병렬로 처리 가능

단, 병렬 처리할 때 스레드를 CPU의 개수를 넘기지 말자

### order by 처리(using file sort)

대부분 select 쿼리에서 정렬은 필수적으로 사용된다.

정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 Filesort라는 별도의 처리를 이용하는 방법이 있다.

|  | 장점 | 단점 |
| --- | --- | --- |
| 인덱스 이용 | 쓰기 쿼리가 실행될 때 이미 인덱스가 정렬되어 있어 쿼리를 읽기만 하면 되어 매우 빠르다. | 쓰기 작업에 부가적인 인덱스 추가/삭제 작업이 필요하여 느리다. 인덱스 때문에 디스크 공간이 더 필요하다. 인덱스 개수가 늘어날수록 버퍼 풀을 위한 메모리가 많이 필요하다. |
| Filesort 이용 | 인덱스를 이용하지 않기 때문에 인덱스의 단점이 없는 것이 장점. 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다. | 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다. |

모든 정렬에 인덱스를 이용하도록 튜닝하는건 거의 불가능하다.

- 정렬 기준이 너무 많아 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- Group by, Distinct 같은 처리의 결과를 정렬하는 경우
- union의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 되는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

만약 Filesort를 이용했다면 실행 계획에서 Using filesort라는 메시지가 표시된다.

### 소트 버퍼

정렬을 수행하기 위한 별도의 메모리 공간

정렬이 필요한 경우 할당된다.

정렬해야 되는 레코드가 건수가 소트 버퍼의 공간보다 크면 레코드를 여러 조각으로 나누어 처리하는데 이 과정에서 임시 저장을 위해 디스크를 사용한다. 

→ 이 과정에서 디스크의 쓰기와 읽기를 유발하여 문제가 발생한다.

**소트 버퍼를 크게 둔다고해서 성능이 무조건 좋아지지 않는다**

리눅스 계열 OS에서는 큰 메모리 공간 할당으로 인해 성능이 떨어질 수 있다.

그리고 소트 버퍼는 세션 메모리 영역에 해당하여 소트 버퍼가 커지면 커넥션이 많아질 때 메모리 부족 현상이 발생할 수 있다.

소트 버퍼의 크기를 크게 두는 것은 디스크 IO 성능이 심각하게 안좋은 경우에만 고려하자!

### 정렬 알고리즘

싱글 패스: 레코드 전체를 소트 버퍼에 담는 것

투 패스: 정렬 기준 칼럼만 소트 버퍼에 담는 것

옵티마이저 트레이스 기능을 활용하면 쿼리가 어떤 정렬 모드를 수행하는지 확인할 수 있다.

`sort_algorithm` 섹션의 `sort_mode` 필드를 보면 알 수 있다.

- <sort_key, rowid>: 정렬 키와 레코드의 row id만 가져와서 정렬하는 방식
- <sort_key, additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드 칼럼들은 고정 사이즈로 메모리 저장
- <sort_key, packed_additional_fields>: 정렬 키와 레코드 전체를 가져와서 정렬하는 방식, 레코드 칼럼들은 가변 사이즈로 메모리 저장

첫 번째 방식을 투 패스 정렬 방식이라 하고 2, 3번째 방식을 싱글 패스 방식이라고 한다.

### 싱글 패스 정렬 방식

소트 버퍼에 정렬 기준 칼럼을 포함해 select 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 방식

정렬에 필요하지 않은 필드까지 전부 읽어서 소트 버퍼에 담고 정렬 수행

더 큰 소트 버퍼 공간이 필요하다.

### 투 패스 정렬 방식

정렬 대상 칼럼과 PK 값만 소트 버퍼에 담아서 정렬을 수행한다.

정렬된 순서로 다시 PK키로 테이블을 읽어서 select할 칼럼을 가져오는 정렬 방식

→ 테이블을 두 번 읽어서 불합리하다.

최선 버전은 싱글 패스 방식을 주로 사용한다.

하지만 아래의 경우 투 패스 정렬 방식을 사용한다.

- 레코드의 크기가 `max_length_for_sort_data` 시스템 변수에 설정된 값보다 클 때
- BLOB이나 TEXT 타입의 칼럼이 select 대상에 포함될 때

결론: 싱글 패스 → 정렬 대상 레코드 크기와 건수가 작은 경우, 투 패스 → 정렬 대상 레코드 크기와 건수가 큰 경우

> 정렬이 필요할 때는 필요한 칼럼만 조회하게 설계하자
→ 정렬 버퍼를 비효율적으로 사용할 수 있기 때문에!
> 

### 정렬 처리 방법

order by가 사용되면 다음 3가지 처리 방법 중 하나로 정렬이 처리된다.

아래로 갈 수록 처리 속도는 떨어진다.

| 정렬 처리 방법 | 실행 계획의 extra 칼럼 내용 |
| --- | --- |
| 인덱스를 사용한 정렬 | 별도 표시 없음 |
| 조인에서 드라이빙 테이블만 정렬 | “Using filesort” 메시지가 표시됨 |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | “Using temporary; Using filesort” 메시지가 표시됨 |

MySQL 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 다음 2가지 방법 중 하나를 선택한다.

- 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
- 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행

### 인덱스를 이용한 정렬

인덱스를 이용한 정렬을 위해서는 반드시 order by에 명시된 칼럼이 제일 먼저 읽는 테이블(조인을 사용하는 경우 드라이빙 테이블)에 속하고, order by의 순서대로 생성된 인덱스가 있어야 한다.

where 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 order by는 같은 인덱스를 사용할 수 있어야 한다.

B-Tree 계열(R-Tree 포함x)의 인덱스가 아닌 인덱스는 인덱스를 이용한 정렬을 활용할 수 없다.

여러 테이블이 조인되는 경우 네스티드-루프 방식의 조인에서만 이 방식 이용 가능

네스티드-루프 조인: https://coding-factory.tistory.com/756

인덱스를 통해 정렬이 처리되는 경우는 인덱스의 값이 정렬되어 있기 때문에 인덱스의 순서대로 값을 읽으면 된다.

→ 그렇다고 인덱스가 이미 걸려있다고 order by 구문을 제거하지는 말자! order by 구문이 들어간다고 추가적인 작업을 더 하는 것도 아니고 예외 상황 시 쿼리 실행 계획이 바뀔수도 있기 때문이다.

### 조인의 드라이빙 테이블만 정렬

조인이 수행되면 결과 레코드의 건수가 몇 배로 불어나고, 레코드 하나하나의 크기도 늘어난다.

→ 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 정렬의 차선책

→ 첫 번째로 읽히는 테이블(드라이빙 테이블)의 칼럼만으로 Order by 절을 작성해야 한다.

책 298p 예제

### 임시 테이블을 이용한 정렬

2개 이상 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수 있다.

위 2가지 상황이 아닌 경우 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다.

3가지 방법 중 제일 느린 방법

책 299p 예제

### 정렬 처리 방법의 성능 비교

주로 order by와 limit을 함께 사용한다.

→ order by와 group by 같은 작업은 where 조건을 만족하는 레코드를 모두 가져와서 정렬을 수행하거나 그루핑 작업을 실행해야만 limt 건수를 제한할 수 있다.

쿼리에서 인덱스를 사용하지 못하는 정렬이나 그루핑 작업이 느린 이유를 스트리밍 방식과 버퍼링 방식을 통해 알아보자

### 스트리밍 방식

조건에 일치하는 레코드가 검색될때마다 바로바로 클라이언트로 전송해주는 방식

언제 마지막 레코드를 받을지 알 수 없음

스트리밍 방식으로 처리되는 쿼리는 빠른 응답 시간을 보장해준다.

### 버퍼링 방식

order by나 group by는 쿼리의 결과가 스트리밍되는 것을 불가능하게 한다.

where 조건에 일치하는 모든 레코드를 가져온 후, 정렬하거나 그루핑해서 차례대로 보내야 한다.

→ 검색하고 정렬 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다려야 한다. → 응답이 느리다.

인덱스 정렬 방식은 스트리밍, 나머지 2개 방식은 버퍼링 방식이다.

**최대한 인덱스 정렬 방식으로 처리되도록 유도하자!**

### 정렬 관련 상태 변수

처리하는 주요 작업에 대해서 해당 작업의 실행 횟수를 상태 변수로 저장한다.

```sql
flush status;
show status like 'sort%';
```

몇 건의 레코드나 정렬 처리를 했는지, 소트 버퍼 간의 병합 작업이 얼마나 발생했는지 확인 가능하다.

- Sort_merge_passes: 멀티 머지 처리 횟수를 의미한다.
- Sort_range: 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
- Sort_scan: 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
- Sort_rows: 지금까지 정렬한 전체 레코드 건수를 의미

### group by 처리

group by도 스트리밍된 처리를 할 수 없게 하는 처리 중 하나이다.

having을 통해 필터링을 수행할 수 있는데 group by에 사용된 조건은 인덱스를 사용하지 못해 이 부분을 튜닝할 필요는 없다.

### 인덱스 스캔을 이용하는 group by (타이트 인덱스 스캔)

조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑 할 때 group by 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행

→ 쿼리 실행 계획의 extra에 별도로 코멘트가 표시되지 않는다.

### 루스 인덱스 스캔을 이용하는 group by

인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것을 의미한다.

실행 계획의 extra에 `Using index for group-by` 코멘트가 표시된다.

책 306p 예제 + 책 10.3.12.24.2 절 참고

단일 테이블에 대해 수행되는 group by에만 이용 가능

인덱스의 유니크한 값이 적을수록 성능이 좋아진다.

### 임시 테이블을 사용하는 group by

group by 기준 칼럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 때 해당 방식 사용

extra 칼럼에 Using temporary 표시 됨

**MySQL 8.0부터 묵시적인 정렬을 해주지 않음!!**

→ 임시 테이블을 만들어서 돌아가기 때문에

### distinct 처리

집계 함수가 포함된 DISTINCT와 포함되지 않은 DISTINCT의 쿼리 실행 계획이 다르다.

집계 함수가 포함되는 경우에 DISTINCT가 인덱스를 타지 못한다면 임시 테이블이 필요함

### select distinct

이 경우 group by와 동일한 방식으로 처리된다.

> distinct 사용시 주의점
`select distinct id, name from users;` 쿼리에서 id만 distinct 처리를 하지 않고 (id, name)을 distinct 처리한다!
즉 **distinct는 특정 칼럼만 유니크하게 만드는게 아닌 조회하는 모든 칼럼에 대해서 유니크한 값을 만들어준다.**
> 

### 집합 함수와 함께 사용된 distinct

`count()`, `min()`, `max()` 과 같은 집합 함수 내에서 distinct 가 사용될 수 있다.

**집합 함수 내에서 사용된 distinct는 그 집합 함수의 인자로 전달된 값이 유니크한 것들을 가져온다.**

```sql
select count(distinct s.salary)
from employees e, salaries s
where e.emp_no = s.emp_no
and e.emp_no between 10000 and 15000;
```

이 쿼리는 내부적으로 `count(distinct s.salary)` 를 처리하기 위해 임시 테이블을 사용한다.

하지만 쿼리 실행 계획에서 임시 테이블을 사용한다는 메시지는 표시되지 않는다.

**salary 값을 저장하기 위한 임시 테이블이 생성되고 임시 테이블의 salary 칼럼에 유니크 인덱스가 생성되기 때문에 레코드가 많아진다면 상당히 느려질 수 있다.**

**인덱스된 칼럼에 대해 distinct 처리를 수행할 때는 인덱스를 풀 스캔하거나 레인지 스캔하면서 임시 테이블 없이 최적화된 쿼리 수행 가능**

### 내부 임시 테이블 활용

MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑 할 때는 내부적인 임시 테이블을 사용한다.

일반적으로 MySQL 엔진이 사용하는 임시 테이블은 처음에는 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨진다. 바로 디스크로 가는 경우도 있음

MySQL 엔진이 사용하는 임시 테이블은 다른 세션이나 다른 쿼리에서 볼 수 없고 사용도 못 한다.

### 메모리 임시 테이블과 디스크 임시 테이블

MySQL 8.0 버전부터는 메모리는 TempTable이라는 스토리지 엔진 사용, 디스크에 저장되는 임시 테이블은 InnoDB 스토리지 엔진 사용

**TempTable은 가변 길이 타입을 지원 및 InnoDB 엔진은 트랜잭션 지원하기 때문에 개선 됨**

TempTable이 사용 가능한 메모리 공간의 크기는 `temptable_max_ram` 시스템 변수로 설정 가능

기본 값 1GB

TempTable의 크기가 1GB가 넘어간다면 TempTable을 MMAP으로 변환하여 디스크에 저장

→ InnoDB 테이블로 전환하는 것보다 오버헤드가 더 적기 때문에

임시 테이블이 처음부터 디스크로 가는 경우에는 InnoDB 테이블로 생성한다.

> 주의!
MySQL 서버는 디스크의 임시 테이블을 생성할 때 파일 오픈 후 즉시 파일 삭제를 실행한다.
그리고 데이터를 저장하기 위해 해당 임시 테이블 사용
→ 이런 방식으로 쿼리가 종료되거나, MySQL 서버가 종료되면 임시 테이블이 바로 삭제된다.
OS가 파일이 오픈된 상태에서 삭제될 때 참조가 끝날 때 삭제하는 것을 이용한 방식
> 

### 임시 테이블이 필요한 쿼리

별도의 데이터 가공을 필요로 할때 임시 테이블이 사용된다.

- order by와 group by에 명시된 칼럼이 다른 쿼리
- order by나 group by에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- distinct와 order by가 동시에 쿼리에 있는 경우 또는 distinct가 인덱스로 처리되지 못하는 경우
- union이나 union distinct가 사용된 쿼리
- 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리

Extra 칼럼에 Using temporary라는 메시지가 표시되는지 확인하면 된다.

첫번째에서 네번째 쿼리 패턴은 임시 테이블에서 유니크 인덱스가 쓰인다.

→ 쿼리 처리 성능이 상당히 느리다.

### 임시 테이블이 디스크에 생성되는 경우

내부 임시 테이블은 기본적으로 메모리 상에 만들어지지만 다음과 같은 조건 만족시 디스크 기반 임시 테이블을 사용

- union 또는 union all에서 select 되는 칼럼 중에 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
- group by나 distinct 칼럼에서 512 바이트 이상인 크기의 칼럼이 있는 경우
- 메모리 임시 테이블의 크기가 시스템 변수 값보다 큰 경우

### 임시 테이블 관련 상태 변수

임시 테이블이 디스크에 생성됐는지 메모리에 생성됐는지 확인하려면 MySQL 서버의 상태 변수를 확인하면 된다.

```sql
flush status;

-- 테스트할 쿼리 실행

show session status like 'Created_tmp%';
```

flush status를 통해 세션 상태를 초기화 해야 한다.

## 고급 최적화

---

옵티마이저 옵션은 조인 관련된 옵티마이저 옵션과 옵티마이저 스위치로 구분된다.

### 옵티마이저 스위치 옵션

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/d6b85826-1293-4e6c-b0f4-41a11a400b16)

### MRR과 배치 키 엑세스

MRR은 Multi-Range Read의 약자

MRR을 응용해서 실행되는 조인 방식을 BKA 조인이라고 하는데 기본적으로 이 방식은 비활성화되어 있다.

→ 단점이 있기 때문에

### 블록 네스티드 루프 조인

MySQL 서버에서 대부분의 조인은 네스티드 루프 조인이다.

→ 조인의 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우에 사용되는 조인 방식이다.

네스티드 루프 조인은 이중 포문 느낌으로 쿼리를 실행한다.

```python
for row1 in employees:
	for row2 in salaries:
		if condition_matched:
			return (row1, row2)
```

네스티드 루프 조인과 블록 네스티드 루프 조인의 차이점은 **조인 버퍼가 사용되는지 여부**이다.

조인은 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하면서 처리된다.

→ 드라이빙 테이블이 1000건이고 드리븐 테이블의 조인 조건이 인덱스를 이용할 수 없다면 1000번의 풀 테이블 스캔을 해야된다.

→ 이런 상황을 방지하기 위해 옵티마이저가 최대한 인덱스를 사용할 수 있게 실행 계획을 수립한다.

만약 풀 테이블 스캔, 인덱스 풀 스캔을 피할 수 없다면 조인 버퍼를 이용하게 된다.

> 주의! MySQL 8.0.18 버전부터는 해시 조인 알고리즘이 도입됐으며, MySQL 8.0.20 버전부터는 블록 네스티드 조인은 더 이상 사용되지 않고 해시 조인 알고리즘으로 대체되어 사용된다.
> 

### 인덱스 컨디션 푸시다운 (index_condition_pushdown)

책 324p 예시 참고

인덱스를 범위 제한 조건으로 사용하지 못한다고 하더라도 인덱스에 포함된 칼럼의 조건이 있다면 모두 같이 모아서 스토리지 엔진으로 전달할 수 있게 핸들러 API가 개선됨

→ 인덱스를 이용해 최대한 필터링을 할 수 있게 되었다.

실행 계획: `using index condition`

### 인덱스 확장 (use_index_extensions)

InnoDB 스토리지 엔진을 사용하는 테이블에서 세컨더리 인덱스에 자동으로 추가된 PK를 활용할 수 있게 할지를 결정하는 옵션

8.8절 클러스터링 인덱스 참고

### 인덱스 머지 (index_merge)

인덱스를 이용해 쿼리를 실행하는 경우, 대부분 옵티마이저는 테이블별로 하나의 인덱스만 사용하도록 실행 계획을 수립한다.

하지만 **인덱스 머지 실행 계획을 사용하면 하나의 테이블에 대해 2개 이상의 인덱스를 이용해 쿼리를 처리한다.**

- 인덱스 머지 - 교집합 (index_merge_intersection)

실행 계획의 extra 칼럼에 `using intersect`라고 표시되면 교집합이 일어난 상황

책 330p 예시 확인하기!

아래의 방법으로 설정을 끄고 킬 수 있다.

```sql
-- 글로벌 scope
set global optimizer_switch='index_merge_intersection=off';

-- 세션 scope
set session optimizer_switch='index_merge_intersection=off';

-- query scope
explain
select /* set_var(optimizer_switch='index_merge_intersection=off') */ *
from employees
where ...;
```

- 인덱스 머지 - 합집합 (index_merge_union)

where 절에 사용된 2개 이상의 조건이 각각의 인덱스를 사용하되 or 연산자로 연결된 경우에 사용되는 최적화

extra 칼럼에 `using union` 라고 표시

우선 순위 큐를 활용한 union 알고리즘으로 중복을 제거해서 결과를 보여준다.

→ pk 기준으로 정렬되기 때문에 가능한 방법

> and 연산은 두 조건 중 하나라도 인덱스를 사용할 수 있으면 인덱스 레인지 스캔으로 쿼리가 실행되고,
or 연산은 두 조건 중 하나라도 인덱스를 사용하지 못한다면 항상 풀 테이블 스캔으로 처리된다.
> 
- 인덱스 머지 - 정렬 후 합집합 (index_merge_sort_union)

만약 **인덱스 머지 작업을 하는 도중 결과의 정렬이 필요한 경우** MySQL 서버는 인덱스 머지 최적화의 Sort Union 알고리즘을 사용한다.

→ 두 집합의 결과에서 중복을 제거하기 위해 특정 값을 기준으로 강제로 정렬을 수행한다. 이 경우 extra 칼럼에 `using_sort_union`이 표시된다.

### 세미 조인 (semijoin)

다른 테이블과 실제 조인은 안하고 다른 테이블에서 조건에 일치하는 레코드가 존재하는지만 체크하는 형태의 쿼리를 세미 조인이라고 한다.

세미 조인 형태의 쿼리와 안티 세미 조인 형태의 쿼리는 최적화 방법에 조금 차이가 있음

`= (서브쿼리)`, `in (서브 쿼리)` 는 다음과 같은 최적화 방법 사용

- 세미 조인 최적화
- in to exists 최적화
- materialization 최적화

`<> (서브쿼리)`, `not in (서브 쿼리)` 형태의 안티 세미 조인 쿼리에는 다음과 같은 최적화 방법

- in to exists 최적화
- materialization 최적화

MySQL 서버 매뉴얼에는 아래의 최적화 전략들을 모아서 세미 조인 최적화라고 부른다.

- Table pull-out
- Duplicate Weed-out
- First Match
- Loose Scan
- Materialization

### 테이블 풀 아웃

세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화

`in (서브쿼리)` 에서 가장 빈번하게 사용되는 방식

실행 계획에서 테이블들의 id 값이 같다면 이 방식이 사용된 것이다.

제한 사항과 특성

- 세미 조인 서브쿼리에서만 사용 가능
- 서브 쿼리 부분이 unique 인덱스나 pk 룩업으로 결과가 1건인 경우에만 사용 가능
- 이 방식이 적용되어도 기존 쿼리에서 가능한 최적화 방법이 사용 불가능하지 않으므로 가능하다면 Table pull out 최적화를 최대한 적용한다.
- 만약 서브쿼리의 모든 테이블이 아우터 쿼리로 끄집어낼 수 없다면 서브쿼리 자체는 없어진다.
- 서브쿼리를 최대한 조인으로 풀어서 사용하라는 튜닝 가이드를 지키므로 서브쿼리를 조인으로 우리가 직접 풀 필요는 없다.

### 퍼스트 매치

`in (서브쿼리)` 형태의 세미 조인을 `exists (서브쿼리)` 형태로 튜닝한 것과 비슷한 방법으로 실행된다.

실행 계획에 `FirstMatch()` 문구가 들어간다.

조인으로 최적화되어 처리되는데 일치하는 레코드를 1건만 찾으면 더 이상 상대 테이블 검색을 하지 않는다.

→ 이미 존재한걸 알기 때문에 다음 탐색을 진행할 필요가 없다.

FirstMatch 최적화 전략의 장점

- 가끔 여러 테이블이 조인되는 경우 원래 쿼리에는 없던 동등 조건을 옵티마이저가 자동으로 추가하는 형태의 최적화가 실행되기도 함 → 조인 형태로 처리되기 때문에 아우터 쿼리 테이블까지 전파 가능
- 서브쿼리의 모든 테이블에 대해 FirstMatch를 수행할지 아니면 일부 테이블에 대해서만 수행할지 취사선택이 가능하다.

FirstMatch 최적화의 몇가지 제한 사항과 특성

- 서브쿼리에서 하나의 레코드만 검색되면 더 이상의 검색을 멈추는 단축 실행 경로(short-cut path)이기 때문에 FirstMatch 최적화에서 서브쿼리는 그 서브쿼리가 참조하는 모든 아우터 테이블이 먼저 조회된 이후에 실행된다.
- 실행 계획의 extra 칼럼에 FirstMatch(table-N) 문구가 표시된다.
- 상관 서브쿼리에서도 사용될 수 있다.
- group by나 집합 함수가 사용된 서브쿼리 최적화에는 사용 불가

### 루스 스캔 (loosescan)

세미 조인 서브쿼리 최적화의 LooseScan은 인덱스를 사용하는 group by 최적화 방법에서 살펴본 Using index for group by의 [루스 인덱스 스캔](https://www.notion.so/Chapter-9-b84bd3531b1e44ba97432d656657c12c?pvs=21)과 비슷한 읽기 방식을 사용한다.

책 342p 예제 확인

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/48316a94-6411-4217-8559-b1f1cd5104aa)

LooseScan 최적화의 특성

- 루스 인덱스 스캔으로 서브쿼리 테이블을 읽고, 그 다음으로 아우터 테이블을 드리븐으로 사용하여 조인을 수행한다. → 서브쿼리 부분이 루스 인덱스 스캔을 사용할 수 있는 조건이 갖춰져야 사용할 수 있는 최적화 방식이다.
- LooseScan을 최적화를 사용하지 못하게 하려면 `optimizer_switch` 시스템 변수에서 `loosescan` 옵션을 off로 하면 됨

사용할 수 있는 쿼리

```sql
select * from ... where expr in (select .. from .. where ..);
```

### 구체화(Materialization)

세미 조인에 사용되는 서브쿼리를 통째로 구체화하여 쿼리를 최적화한다는 뜻

→ 내부 임시 테이블을 생성한다는 것을 의미한다.

```sql
select * 
from employees e 
where e.emp_no in 
	(select de.emp_no from dept_emp de where de.from_date='1995-01-01');
```

이러한 형태의 쿼리에서 FirstMatch 최적화를 하려해도 employees 테이블을 full scan하기 때문에 별 도움이 되지 않는다. → **서브쿼리 구체화 최적화를 통해 해결**

1. dept_emp 테이블을 먼저 읽어 임시 테이블 생성
2. 구체화 된 임시 테이블과 employees 테이블 조인해서 결과 반환

**`Materialization` 최적화는 다른 서브쿼리 최적화와 달리 서브 쿼리 내에 `group by`가 있어도 최적화 전략을 사용할 수 있다.**

`Materialization` 최적화가 사용될 수 있는 경우

- `In(sub query)`에서 서브쿼리가 상관 서브쿼리면 안된다.
- 서브쿼리는 `group by`나 집합 함수들이 사용돼도 구체화를 사용할 수 있다.
- 구체화가 사용된 경우에는 내부 임시 테이블이 사용된다.

Materialization 최적화는 `optimizer_switch` 변수의 `semijoin` 옵션과 `materialization` 옵션이 on인 경우 사용 가능

> 세미 조인이 아닌 서브쿼리의 최적화에서도 구체화를 이용한 최적화가 사용될 수 있다.
> 

### 중복 제거 (Duplicated Weed-out)

세미 조인 서브쿼리를 일반적인 `inner join` 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리되는 알고리즘

```sql
select * from employees e
where e.emp_no in (select s.emp_no from salaries s where s.salary > 150000);
```

원본 쿼리를 `inner join` + `group by` 절로 바꿔서 실행하는 것과 동일한 작업으로 쿼리를 처리

알고리즘 처리 과정

1. salaries 테이블의 ix_salary 인덱스를 스캔해서 where 조건 처리 후 employees 테이블 조인
2. 조인된 결과를 임시 테이블에 저장
3. 임시 테이블에 저장된 결과에서 emp_no 기준으로 중복 제거
4. 중복을 제거하고 남은 레코드를 최종적으로 반환

extra 칼럼에 start temporary와 end temporary 문구가 별도로 표시된다.

장점 및 제약 사항

- 서브쿼리가 상관 서브쿼리여도 사용 가능
- 서브쿼리가 group by나 집합 함수가 사용된 경우 사용 불가
- 서브쿼리의 테이블을 조인으로 처리하기 때문에 최적화 할 수 있는 방법이 많다.

### 컨디션 팬아웃(condition_fanout_filter)

조인을 실행할 때 테이블의 순서는 쿼리 성능에 큰 영향을 미친다.

A 테이블의 레코드가 10,000건이고 B 테이블의 레코드가 10건일 때 A 테이블이 조인의 드라이빙 테이블인 경우 B 테이블이 10,000번 호출된다.

→ MySQL 옵티마이저는 **여러 테이블이 조인되는 경우 가능하면 일치하는 레코드 건수가 적은 순서대로 조인을 실행한다.**

책 348 - 349p 예제

condition_fanout_filter 최적화가 필터 값을 예측하는 방법

1. where 조건절에 사용된 칼럼에 대해 인덱스가 있는 경우
2. where 조건절에 사용된 칼럼에 대해 히스토그램이 존재하는 경우

> 옵티마이저가 실행 계획을 수립할 때 테이블이나 인덱스의 통계 정보만 사용하는 것이 아니라 다음의 순서대로 사용 가능한 방식을 선택한다.
1. 레인지 옵티마이저를 이용한 예측
2. 히스토그램을 이용한 예측
3. 인덱스 통계를 이용한 예측
4. 추측에 기반한 예측
> 

condition_fanout_filter 최적화 기능을 사용하면 더 정교한 계산으로 실행 계획을 수립하지만 그만큼 더 많은 시간과 자원을 사용하게 된다. → trade off를 고려하여 사용할지 말지를 결정하면 된다.

### 파생 테이블 머지 (derived_merge)

임시 테이블 최적화를 활성화할지 여부를 결정한다.

옵티마이저가 서브쿼리로 작성된 쿼리를 외부 쿼리로 병합해준다.

단, 다음과 같은 조건에서는 옵티마이저가 자동으로 서브쿼리를 외부 쿼리로 병합할 수 없음

→ 사용자가 직접 수동으로 병합해야 한다.

- sum(), min(), max() 등 집계 함수와 윈도우 함수가 사용된 서브쿼리
- distinct가 사용된 서브쿼리
- group by나 having이 사용된 서브쿼리
- limit이 사용된 서브쿼리
- union 또는 union all을 포함하는 서브쿼리
- select 절에 사용되는 서브쿼리
- 값이 변경되는 사용자 변수가 사용된 서브쿼리

### 인비저블 인덱스 (use_invisible_indexes)

인덱스의 상태를 제어할 수 있는 기능

→ 인덱스를 삭제하지 않고, 사용하지 못하게 제어하는 기능

`alter table … alter index … [visible | invisible]`

use_invisible_indexes = on을 하게 되면 옵티마이저가 invisible 인덱스를 볼 수 있게 된다. (기본값 off)

### 스킵 스캔 (skip_scan)

인덱스의 핵심은 값이 정렬되어 있다는 것이다.

→ 인덱스를 구성하는 칼럼의 순서가 매우 중요하다.

인덱스 스킵 스캔은 제한적이지만 인덱스의 제약(칼럼의 순서)을 뛰어넘을 수 있는 최적화 기법이다.

→ 인덱스의 선행 칼럼이 조건절에 사용되지 않더라도 후행 칼럼의 조건만으로도 인덱스를 이용한 쿼리 성능 개선이 가능하다.

→ 옵티마이저가 테이블에 존재하는 모든 하나의 칼럼에 대한 값을 가져와 해당 칼럼의 조건이 있는 것처럼 쿼리를 최적화한다.

→ 하나의 칼럼에 유니크한 값이 여러개라면 비효율적이기 때문에 옵티마이저가 이 방식 사용하지 않음

### 해시 조인 (hash_join)

해시 조인은 첫 번째 레코드를 찾는 데는 시간이 많이 걸리지만, 최종 레코드를 찾는 데까지는 시간이 많이 걸리지 않는다.

네스티드 루프 조인은 첫 레코드를 찾는 데는 빠르지만, 최종 레코드를 찾는데까지 시간이 많이 걸린다.

→ **해시 조인은 최고 스루풋 전략에 적합, 네스티드 루프 조인은 최고 응답 속도 전략에 적합**

→ 웹 서비스의 경우 응답 속도가 중요하기 때문에 네스티드 루프 조인, 분석과 같은 서비스는 전체적인 소요 시간이 중요하기 때문에 해시 조인

MySQL은 범용 데이터베이스이기 때문에 응답 속도가 더 중요하다고 판단함

→ 조인 조건의 칼럼이 인덱스가 없거나 조인 대상 테이블의 레코드 건수가 매우 적은 경우 등에 대해서만 해시 조인을 사용한다.

해시 조인은 빌드 단계와 프로브 단계로 나눠 처리된다.

빌드 단계: 조인 대상 테이블 중에서 해시 테이블로 만들기에 용이한 테이블을 골라서 메모리에 해시 테이블을 생성하는 단계 (조인 버퍼 이용, **조인 버퍼 공간이 부족하다면 청크로 분리**)

프로브 단계: 나머지 테이블의 레코드를 읽어서 해시 테이블의 일치 레코드를 찾는 단계

**MySQL 옵티마이저는 빌드 테이블 크기에 따라 클래식 해시 조인(메모리에서 전부 처리 가능한 경우)을 사용하거나 해시 테이블이 조인 버퍼 메모리보다 큰 경우는 그레이스 해시 조인을 사용한다.**

### 인덱스 정렬 선호 (prefer_ordering_index)

**MySQL 옵티마이저는 order by 또는 group by를 인덱스를 사용해 처리 가능한 경우 쿼리의 실행 계획에서 이 인덱스의 가중치를 높이 설정해서 실행된다.**

옵티마이저가 order by에 너무 가중치를 많이 줘 실수가 잦아진다면 `prefer_ordering_index` 옵션을 끄면 된다.

### 조인 최적화 알고리즘

MySQL에는 조인 쿼리의 **실행 계획 최적화를 위한 알고리즘**이 2개 있다.

### Exhaustive 검색 알고리즘

from 절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적의 조합 1개를 찾는 방법이다.

→ 테이블이 많아지면 많아질수록 검색 시간이 엄청 길어진다.

### Greedy 검색 알고리즘

exhaustive 알고리즘의 시간 소모적인 문제를 해결하기 위해 도입된 기법

1. 전체 N개의 테이블 중에서 `optimizer_search_depth` 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
2. 1번에서 생성된 조인 조합 중에서 최소 비용의 실행 계획 하나를 선정
3. 2번에서 선정된 실행 계획의 첫 테이블을 부분 실행 계획의 첫 번째 테이블로 선정
4. 전체 N - 1개의 테이블 중에서 `optimizer_search_depth` 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
5. 4번에서 생성된 조인 조합들을 하나씩 3번에서 생성된 부분 실행 계획에 대입해 실행 비용을 계산
6. 5번의 비용 계산 결과 최적의 실행 계획에서 두 번째 테이블을 3번에서 생성된 부분 실행 계획의 두 번째 테이블로 선정
7. 남은 테이블이 모두 없어질 때까지 4~6번까지의 과정을 반복
8. 최종적으로 부분 실행 계획이 테이블의 조인 순서로 결정됨

분할 정복 방식의 알고리즘

조인 최적화 시스템 변수

`optimizer_prune_level` : Heuristic 검색이 작동하는 방식을 제어한다. → 기존에 찾은 값보다 현재 찾는 값이 커지는 순간 탈출할지 말지

`optimizer_search_depth` : 어떤 알고리즘을 사용할지 결정하는 시스템 변수

책 368 - 369 확인

## 쿼리 힌트

---

옵티마이저가 사람보다 실행 계획을 못 세우는 경우가 있다.

→ 이럴 때 힌트를 사용하여 옵티마이저에게 실행 계획을 어떻게 수립할 지 알려주면 된다.

### 인덱스 힌트

인덱스 힌트는 ANSI 표준 문법을 준수하지 못하는 단점이 있다. + select와 update에서만 사용할 수 있음

→ 가능하면 옵티마이저 힌트를 사용하는 것을 추천

### straight_join

**옵티마이저 힌트인 동시에 조인 키워드이다.**

→ 여러 개의 테이블이 조인되는 경우 **조인 순서를 고정하는 역할을 수행한다.**

```sql
select STRAIGHT_JOIN *
from employees e, dept_emp de, departments d
where ...
```

이 경우 명시된 순서인 e → de → d 순서대로 조인이 실행된다.

다음 기준에 맞게 조인 순서가 결정되지 않은 경우에만 STRAIGHT_JOIN 힌트로 조정하면 된다.

- 임시 테이블(인라인 뷰, 파생된 테이블)과 일반 테이블의 조인: 임시 테이블을 드라이빙 테이블로 선정하는 것이 좋다.
- 임시 테이블끼리 조인: 임시 테이블(서브쿼리로 파생된 테이블)은 항상 인덱스가 없기 때문에 어느 테이블을 먼저 드라이빙으로 읽어도 무관하므로 **크키가 작은 테이블을 드라이빙**으로 선택해주는 것이 좋다.
- 일반 테이블끼리 조인: 양쪽 모두 조인 칼럼에 인덱스가 있거나, 양쪽 모두 조인 칼럼에 인덱스가 없는 경우 레코드가 적은 테이블을 드라이빙으로 선택하는게 좋다. 그 외에는 조인 칼럼에 인덱스가 없는 테이블을 드라이빙

비슷한 역할을 하는 힌트들

- join_fixed_order
- join_order
- join_prefix
- join_suffix

### use index / force index / ignore index

인덱스 힌트는 조인의 순서를 변경하는 것 다음으로 자주 사용된다.

인덱스 힌트는 사용하려는 인덱스를 가지는 테이블 뒤에 힌트를 명시해야 한다.

옵티마이저가 대부분 적절한 인덱스를 잘 선택하지만 3~4개의 칼럼을 포함하는 인덱스가 여러개 존재할 때 실수할 때가 있다. → 이럴 때 인덱스 힌트 사용하면 된다.

pk 인덱스는 primary라고 명시하면 된다.

- use index: 가장 자주 사용되는 인덱스 힌트 → 특정 테이블의 인덱스를 사용하도록 권장하는 힌트이다.
- force index: use index와 큰 차이가 없다. → 옵티마이저에게 미치는 영향이 더 크다는 차이점 존재하지만 별 차이 없음
- ignore index: 특정 인덱스르 못쓰게 막는 용도로 사용하는 힌트 옵티마이저가 풀 테이블 스캔을 유도하기 위해 ignore 힌트를 사용할 수 있음

인덱스 힌트에 용도를 명시해 줄 수 있다.

`for join`, `for order`, `for group` 으로 인덱스 사용 용도 명시 가능

`order by`나 `group by` 작업에서 인덱스를 사용할 수 있다면 나은 성능을 보장한다.

책 375p 예제 참고

성능이 어떻게 개선될지 판단하기 힘들다면 힌트를 굳이 사용하지말고 옵티마이저의 선택을 믿는게 낫다.

→ 옵티마이저가 상황에 맞게 좋은 계획을 선택해줄 확률이 높기 때문에

### SQL_CALC_FOUND_ROWS

해당 힌트가 포함된 쿼리는 limit 개수만큼 레코드를 찾았다고 해도 끝까지 데이터 검색을 수행하게 된다.
→ limit를 제외한 조건을 만족하는 레코드가 몇 건인지 알 수 있다.

→ **잘 사용하지 않음!!**

이유: **해당 힌트를 사용하는 것보다 limit + count() 쿼리 2번이 일반적으로 더 성능이 좋기 때문에**

해당 힌트는 성능 최적화를 위해

### 옵티마이저 힌트

옵티마이저 힌트는 종류가 매우 다양하며, 옵티마이저 힌트가 미치는 영향 범위도 매우 다양하다.

- 힌트 종류
    - 인덱스: 특정 인덱스의 이름을 사용할 수 있는 옵티마이저 힌트
    - 테이블: 특정 테이블의 이름을 사용할 수 있는 옵티마이저 힌트
    - 쿼리 블록: 특정 쿼리 블록에 사용할 수 있는 옵티마이저 힌트 → 힌트가 명시된 쿼리 블록에 대해서만 영향을 미치는 옵티마이저 힌트
    - 글로벌: 전체 쿼리에 대해서 영향을 미치는 힌트

### MAX_EXECUTION_TIME

영향 범위: 글로벌

쿼리의 실행 계획에 영향을 미치지 않는 힌트

단순히 쿼리의 최대 실행 시간을 설정하는 힌트 → 시간 초과 시 쿼리 실패

### SET_VAR

영향 범위: 글로벌

실행 계획을 바꾸는 용도 + 조인 버퍼나 정렬용 버퍼의 크기를 일시적으로 증가시켜 대용량 처리 쿼리의 성능을 향상시키는 용도로 사용(쿼리에 대해서 일부 시스템 변수 조정 가능)

### SEMIJOIN & NO_SEMIJOIN

9.3.1.9절 세미 조인을 참고

어떤 세부적인 세미 조인 전략을 사용할지 결정하는 힌트

- Duplicate Weed-out: `SEMIJOIN(DUPSWEEDOUT)`
- First Match: `SEMIJOIN(FIRSTMATCH)`
- Loose Scan: `SEMIJOIN(LOOSESCAN)`
- Materialization: `SEMIJOIN(MATERIALIZATION)`
- Table Pull-out: 없음

### SUBQUERY

세미 조인이 사용되지 못할 때 사용하는 최적화 방법

2가지 형태로 최적화 가능

- IN-to-EXISTS: `SUBQUERY(INTOEXISTS)`
- Materialization: `SUBQUERY(MATERIALIZATION)`

사용할 기회가 많지는 않음

### BNL & NO_BNL & HASHJOIN & NO_HASHJOIN

MySQL 8.0.20과 그 이후 버전에서는 해시 조인을 유도하거나 해시 조인을 사용하지 않게 하고자 한다면 다음 예제 쿼리와 같이 BNL, NO_BNL 힌트를 사용해야 한다.

### JOIN_FIXED_ORDER, JOIN_ORDER, JOIN_PREFIX, JOIN_SUFFIX

- fixed_order: straight_join 힌트와 동일하게 from 절의 테이블 순서대로 조인을 실행하게 하는 힌트
- order: from절에 사용된 테이블 순서가 아닌 힌트에 명시된 테이블의 순서대로 조인을 실행하는 힌트
- prefix: 드라이빙 테이블만 강제하는 힌트
- suffix: 드리븐 테이블만 강제하는 힌트

### MERGE & NO_MERGE

from 절에 사용되는 서브 쿼리에 대해 내부 임시 테이블 사용 또는 외부 쿼리와 병합을 선택하는 힌트이다.

내부 임시 테이블을 파생 테이블이라고 하는데 이는 불필요한 자원 소모를 유발하기 때문에 생긴 힌트

쿼리 상황에 따라 내부 임시 테이블을 생성하거나 쿼리를 병합하거나 더 나은 선택지가 다를 수 있는데 이 때 해당 힌트를 사용하여 쿼리를 유도하면 된다.

### INDEX_MERGE & NO_INDEX_MERGE

MySQL 서버는 가능하다면 테이블 당 하나의 인덱스만을 이용하여 쿼리를 처리하려고 한다.

단 하나의 인덱스가 검색 범위를 충분히 줄이지 못한다면 MySQL 옵티마이저는 사용 가능한 다른 인덱스를 이용하기도 한다.

→ 인덱스 머지

인덱스 머지 실행 계획을 해당 힌트로 제어할 수 있다.

### NO_ICP

인덱스 컨디션 푸시다운 (Index Condition Pushdown) 최적화는 가능하다면 항상 성능 향상에 도움이 되므로 **MySQL 옵티마이저는 최대한 인덱스 컨디션 푸시다운 기능을 사용하는 방향으로 실행 계획을 수립한다.**

→ ICP를 사용하라는 힌트가 없는 이유

하지만 ICP로 인해 실행 계획에 문제가 발생하는 상황이 생길 수 있다. 이 때 `NO_ICP` 힌트를 걸어주면 된다.

### SKIP_SCAN & NO_SKIP_SCAN

인덱스 스킵 스캔은 **인덱스의 선행 칼럼의 조건이 없이도 옵티마이저가 해당 인덱스를 사용할 수 있게 해주는 좋은 최적화 방식**

→ 그러나 조건이 누락된 선행 칼럼이 가지는 유니크한 값이 많아진다면 성능이 떨어진다.

이 경우 `NO_SKIP_SCAN` 힌트를 걸어 이를 막아주면 된다.

### INDEX & NO_INDEX

예전 MySQL 버전의 인덱스 힌트를 대체하는 용도로 사용한다.
