# Chapter 10. 실행 계획

---

## 통계 정보

---

MySQL 5.7 버전까지는 인덱스에 대한 정보를 가지고 실행 계획 수립

8.0부터는 인덱스되지 않은 칼럼들에 대해 히스토그램 정보가 도입되어 이를 같이 활용하여 실행 계획 수립

### 테이블 및 인덱스 통계 정보

비용 기반 최적화에서 가장 중요한 것은 **통계 정보**이다.

통계 정보가 정확하지 않으면 쿼리가 이상하게 실행될 수 있다.

### MySQL 서버의 통계 정보

MySQL 5.6 버전부터 InnoDB 엔진을 사용하는 테이블에 대한 통계 정보를 영구적으로 관리할 수 있게 개선

→ 테이블의 통계 정보가 `innodb_index_stats`, `innodb_table_stats` 테이블로 관리된다.

통계 정보를 테이블로 관리함으로써 서버를 재시작해도 정보가 유지할 수 있음

테이블을 생성할 때 통계 정보를 보관할지 말지 결정 가능 (`STATS_PERSIST = {DEFAULT | 0 | 1}`)

통계 정보의 각 칼럼이 가지는 값들

- 인덱스가 가진 유니크한 값의 개수
- 인덱스의 리프 노드 페이지 개수
- 인덱스 트리의 전체 페이지 개수
- 테이블 전체 레코드 건수
- 프라이머리 키의 크기 (InnoDB 페이지 개수)
- 프라이머리 키를 제외한 인덱스의 크기

> 통계 정보에서 `sum_of_other_index_sizes` 칼럼의 값이 경우에 따라 0으로 보일 수 있는데 이 경우에는 `analyze table` 명령을 실행하면 된다.
> 

MySQL 5.5 버전까지는 메모리에 통계 정보를 저장 그리고 사용자나 관리자가 알지 못하는 순간에 특정 이벤트가 발생하면 통계 정보가 갱신됨

→ 의도치 않게 통계 정보가 변경될 수 있다.

영구적인 통계 정보가 도입되면서 의도치 않은 통계 정보 변경을 막을 수 있다.

`innodb_auto_recalc` 시스템 변수를 off로 설정하여 통계 정보가 자동 갱신되는 것을 막을 수 있다.

테이블 생성 시 `stats_auto_recalc` 옵션을 이용해 테이블 단위로 조정도 가능

MySQL 5.6부터는 2가지 시스템 변수로 테이블 통계 정보를 어떻게 수집할지 조절할 수 있다.

- `innodb_stats_transient_sample_pages`
    - 통계 정보 수집이 실행될 때 8개의 페이지만 임의로 샘플링해서 분석하고 활용
- `innodb_stats_persistent_sample_pages`
    - analyze table 명령이 실행되면 임의로 20개의 페이지만 샘플링해서 분석하고 그 결과를 통계 정보 테이블에 저장

영구적인 통계 정보를 활용하여 더 정확한 통계 정보를 분석할 수 있다.

### 히스토그램

단순히 인덱스된 칼럼의 유니크한 값의 개수만을 가지고 실행 계획을 수립하기에는 부족하다.

옵티마이저는 이러한 부족함을 메우기 위해 실행 계획을 수립할 때 실제 인덱스의 일부 페이지를 랜덤으로 가져와 참조

**MySQL 8.0 버전 부터는 칼럼의 데이터 분포도를 참조할 수 있는 히스토그램 정보를 활용!**

### 히스토그램 정보 수집 및 삭제

MySQL 8.0 기준 **히스토그램 정보는 칼럼 단위로 관리**

→ 자동으로 수집되지는 않고 `analyze table ... update histogram` 명령을 실행해 수동으로 수집 및 관리

수집된 히스토그램 정보는 시스템 딕셔너리에 함께 저장하고 MySQL 서버가 실행될 때 `information_schema` 데이터베이스의 `column_statistics` 테이블로 로드한다.

책 400p 예제 보기

MySQL 8.0 버전에서는 2종류의 히스토그램 타입이 지원된다.

- Singleton(싱글톤 히스토그램): 칼럼값 개별로 레코드 건수를 관리하는 히스토그램, 도수 분포라고 부름
- Equi-Height(높이 균형 히스토그램): 칼럼값의 범위를 균등한 개수로 구분해서 관리하는 히스토그램, Height-Balanced 히스토그램이라고 불린다.

히스토그램은 버킷 단위로 구분되어 레코드 건수나 칼럼값의 범위가 관리된다.

싱글톤: 칼럼이 가지는 값 별로 버킷이 할당

높이 균형: 개수가 균등한 칼럼값의 범위별로 하나의 버킷이 할당

책 402p 그림 보기

싱글톤 히스토그램은 유니크한 개수가 상대적으로 적은 경우 사용

생성된 히스토그램은 `analyze table … drop histogram` 명령어로 삭제한다. (**삭제 시 실행계획 변경 유의**)

히스토그램을 삭제하지 않고 사용하지 않게 하려면 시스템 변수, 커넥션, 쿼리 별로 설정을 주면 된다.

### 히스토그램의 용도

히스토그램은 각 범위(버킷)별로 레코드 건수와 유니크한 값의 개수 정보를 가지기 때문에 정확한 예측을 도와준다.

→ 단순 통계 정보만 활용하는 것보다 쿼리 성능이 좋아지게 된다.

쿼리 성능을 개선해준다.

### 히스토그램과 인덱스

MySQL 8.0 버전에서 히스토그램은 인덱스 되지 않은 칼럼에 대한 데이터 분포도를 참조하는 용도로 사용한다.

### 코스트 모델

MySQL 8.0 서버의 코스트 모델은 2개 테이블에 저장된 설정값을 사용한다.

- server_cost: 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
- engine_cost: 레코드를 가진 데이터 페이지를 가져오는 데 필요한 비용 관리

책 409 보기

## 실행 계획 확인

---

MySQL 서버의 실행 계획은 explain 명령어로 확인할 수 있다.

MySQL 8.0 버전부터 실행 계획의 출력 포맷과 실제 쿼리의 실행 결과까지 확인할 수 있는 옵션이 추가됨

### 실행 계획 출력 포맷

MySQL 8.0 버전에서는 format 옵션을 사용하여 출력의 형식을 테이블, 트리, json으로 지정할 수 있다.

본인이 쓰고 싶은 포맷을 쓰자

### 쿼리의 실행 시간 확인

MySQL 8.0.18 버전부터 쿼리의 실행 계획과 단계별 소요 시간 정보를 확인할 수 있는 `explain analyze` 기능이 추가되었다.

트리 형식으로 결과를 출력해준다.

트리 형식의 실행 계획에서 들여쓰기는 호출 순서를 의미하며, 실제 실행 순서는 다음 기준으로 읽는다.

- 들여쓰기가 같은 레벨에서는 상단에 위치한 라인이 먼저 실행
- 들여쓰기가 다른 레벨에서는 가장 안쪽에 위치한 라인이 먼저 실행

책 415p 확인

`explain analyze` 기능은 실행 계획만 추출하는 것이 아니라 실제 쿼리를 실행하기 때문에 오래 걸리는 쿼리는 먼저 explain으로 확인하고 어느정도 튜닝을 진행한 뒤 분석하는게 좋다.

## 실행 계획 분석

---

explain 명령을 실행하면 쿼리의 특성에 따라 표 형태로 결과가 표시된다.

표의 각 레코드는 쿼리에서 사용된 테이블(서브쿼리로 임시 테이블을 만든다면 그것도 포함)의 개수만큼 출력된다.

실행 순서는 위에서 아래로 순서대로 표시된다.(union 또는 상관 서브 쿼리는 아닐 수 있음)

**출력된 실행 계획에서 위에 출력된 결과일수록 쿼리의 바깥 부분이거나 먼저 접근한 테이블이고, 아래쪽에 출력된 결과일수록 쿼리의 안쪽 부분 또는 나중에 접근한 테이블**

### id 칼럼

하나의 select 문장은 다시 1개의 select 문장을 포함할 수 있다.

**실행 계획에서 가장 왼쪽에 표시되는 id 칼럼은 단위 select 쿼리별로 부여되는 식별자 값이다.**

**하나의 select 문장 안에 여러 개의 테이블을 조인하면 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 id 값이 부여된다.**

주의: id 칼럼의 값이 쿼리 접근 순서를 의미하지는 않는다!

### select_type 칼럼

단위 select가 어떤 타입의 쿼리인지 표시되는 칼럼

type들은 다음과 같다.

- simple
    - union이나 서브쿼리를 사용하지 않는 단순한 select 쿼리인 경우 simple로 표시된다.
    - 쿼리 문장이 아무리 복잡하더라도 simple은 단 하나만 존재
    - 일반적으로 제일 바깥의 select 쿼리가 simple이다.
- primary
    - union이나 서브쿼리를 가지는 select 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리
    - simple과 마찬가지로 primary도 단 하나 존재
- union
    - union으로 결합하는 단위 select 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 select 쿼리의 타입은 union으로 표시된다.
    - union의 첫 번째 단위 테이블은 쿼리 결과들을 모아서 저장하는 임시 테이블(derived) 타입
- dependent union
    - dependent union은 union이나 union all로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미
    - union select_type과 같이 union이나 union all로 집합을 결정하는 쿼리에서 표시된다.
    - 내부 쿼리가 외부의 값을 참조해서 처리될 때 `select_type` 에 dependent 키워드가 표시된다.
- union result
    - union 결과를 담아두는 테이블을 의미한다.
    - MySQL 8.0 버전부터 union all은 임시 테이블을 사용하지 않는다.
    - id 값이 부여되지 않는 특징이 있다.
- subquery
    - from 절 이외에서 사용되는 서브쿼리
    - from 절에서 사용된 서브쿼리는 derived로 표시된다.

> **사용되는 위치에 따른 서브쿼리 분류**
- Nested Query: select되는 칼럼에 사용된 서브쿼리
- Subqeury: where 절에 사용된 경우 일반적으로 서브쿼리라고 한다.
- Derived Table: from 절에서 사용된 서브쿼리를 MySQL에서는 파생 테이블이라고 하며, RDBMS에서는 인라인 뷰라고 부른다.
**반환하는 값에 따른 서브쿼리 분류**
- 스칼라 서브쿼리: 하나의 값(레코드 1, 칼럼 1)만 반환하는 쿼리
- 로우 서브쿼리: 하나의 레코드만 반환하는 쿼리
> 
- dependent subquery
    - 서브쿼리가 바깥쪽 select 쿼리에서 정의된 칼럼을 사용하는 경우 dependent subquery
    - 외부 쿼리가 먼저 실행된 이후 내부 서브쿼리가 실행돼야 하므로 일반 서브쿼리보다 느릴 때가 많다.
- derived
    - 단위 select 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다.
    - 최적화가 좋지 않은 MySQL 버전을 사용 중이라면 실행 계획을 확인하여 파생 테이블을 생성하는지 확인하고 생성한다면 최적화 해주는 것이 좋다.

> **튜닝 팁**
쿼리 튜닝을 위해 실행 계획을 확인할 때 가장 먼저 select_type 칼럼의 값이 derived인 것이 있는지 확인해야 한다.
서브쿼리를 조인으로 해결할 수 있다면 조인을 사용하는 것을 권장!
쿼리를 개발하다보면 기능을 단계적으로 추가하면서 쿼리를 개발하는데 이 때 서브쿼리 형태로 자주 작성되게 된다. → 쿼리를 완성하면 이러한 서브쿼리를 조인으로 고쳐쓰는 습관을 가지자!
> 
- dependent derived
    - 해당 테이블이 래터럴 조인으로 사용된 것을 의미하는 타입
    - MySQL 8.0 버전부터 래터럴 조인 기능이 추가되어 from 절 서브쿼리에 외부 칼럼을 참조할 수 있다.
    - lateral 키워드를 사용해 조인을 해야한다.
- uncacheable subquery
    - 조건이 똑같은 서브쿼리가 실행될 때는 다시 실행하지 않고 이전의 실행 결과를 그대로 사용할 수 있게 캐시 공간에 담아둔다.
    - 주의: **쿼리 캐시나 파생 테이블과는 전혀 무관한 기능!!**
    - 서브쿼리에 포함된 요소에 의해 캐시가 불가능한 경우 해당 타입이 출력된다.
    - 캐시가 불가능한 요소
        - 사용자 변수가 서브쿼리에 사용된 경우
        - not-deterministic 속성의 스토어드 루틴이 서브쿼리 내에서 사용된 경우
        - uuid(), rand()와 같이 결과값이 호출될 때마다 달라지는 함수가 서브쿼리에 사용된 경우
- uncacheable union
    - uncacheable과 union 키워드의 속성이 혼합된 타입이다.
- materialized
    - from 절이나 in(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용된다.
    - 9.3.1.13절 참고

### table 칼럼

MySQL 서버의 실행 계획은 단위 select query 기준이 아니라 테이블 기준으로 표시된다.

**테이블이 없는 경우(dual 같은 거)에는 table 칼럼에 null이 표시된다.**

table 칼럼이 <derived N> 또는 <union M,N> 과 같이 **<>로 둘러싸인 것은 임시 테이블을 의미**한다.

<> 내부의 숫자는 단위 select 쿼리의 id 값을 지칭

책 430 - 431p 예시 꼭 보기!

materialized 실행 계획에서는 <subquery N> 형태로 table 칼럼이 표시된다. → 이것도 임시 테이블 만들었다고 생각하면 됨

### partitions 칼럼

MySQL 8.0 버전부터 explain 명령으로 파티션 실행 계획까지 모두 확인할 수 있다.

**파티션 키로 사용하는 칼럼은 pk를 포함한 모든 유니크 인덱스의 일부여야 한다.**

파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 테이블을 골라내는 과정을 **파티션 프루닝**이라고 한다.

옵티마이저는 **쿼리 처리를 위해 필요한 파티션들의 목록만 모아서 실행 계획의 partitions 칼럼**에 표시해준다.

**type 칼럼이 all이라고 모든 테이블을 읽는 것이 아니고 파티션들의 값 만 다 읽는 것이다.**

### type 칼럼

각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타내는 칼럼

`index_merge`를 제외하면 모두 하나의 인덱스만 사용한다.

- all
    - 테이블을 처음부터 끝까지 읽어서 레코드를 가져오는 풀 테이블 스캔 방법
- system
    - 레코드가 1건만 존재하는 테이블 또는 1건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법
    - InnoDB에서는 나타나지 않고 MyISAM이나 MEMORY 테이블에서 발생
- const
    - 쿼리가 **pk나 유니크 키 칼럼을 이용하는 where 조건**을 가지고 있으며, **반드시 1건을 반환하는 쿼리의 처리 방식을 말한다.**
    - 다른 DBMS에서는 유니크 인덱스 스캔이라고도 표현
    - pk나 유니크 키 중에서 인덱스의 일부 칼럼만 조건으로 사용할 때는 ref로 동작한다.
    - 책 437 참고 확인
- eq_ref
    - 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다.
    - 조인에서 처음 읽은 테이블의 칼럼 값을, 그 다음 읽어야 할 테이블의 pk나 유니크 키 칼럼의 검색 조건에 사용할 때를 가리켜 eq_ref라고 한다.
    - 두 번째 이후에 읽는 테이블의 type 칼럼에 eq_ref가 표시된다.
    - 두 번째 이후에 읽히는 테이블을 유니크 키로 검색할 때 유니크 인덱스는 not null이어야 하고 다중 칼럼 pk나 유니크 인덱스라면 인덱스의 모든 칼럼이 비교 조건에 사용되어야 한다.
    - → **조인에서 두 번쩨 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 쓸 수 있다.**
- ref
    - eq_ref와는 달리 조인의 순서와 관계없이 사용된다.
    - pk나 유니크 키 등의 제약 조건도 없다.
    - 동등 조건을 쓰기 때문에 빠르지만 레코드가 반드시 1건이라는 보장이 없으므로 eq_ref보다는 느리다.
    - const, eq_ref, ref는 상당히 빠른 방법이기 때문에 이 접근 방법은 튜닝하지 않고 넘어가도 된다.
- fulltext
    - MySQL 서버의 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법
    - 전문 검색 인덱스는 통계 정보가 관리되지 않으며 SQL 문법을 다르게 작성해야 한다.
    - 전문 검색 조건은 우선순위가 상당히 높다. → const, eq_ref, ref가 아니면 일반적으로 전문 검색 인덱스를 쓰게 된다.
    - fulltext보다 일반 인덱스 range가 빠른 경우가 있으니 조건별로 성능 체크를 잘 해봐야한다.
- ref_or_null
    - ref 접근 방법과 같은데, null 비교가 추가된 형태이다.
- unique_subquery
    - where 조건절에서 사용될 수 있는 in(subquery) 형태의 쿼리를 위한 접근 방법이다.
    - 서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 이 접근 방법을 사용한다.
    - MySQL 8.0 버전에서는 최적화가 더 진행되어 다른 실행 계획이 보일 수 있다.
- index_subquery
    - in 쿼리는 중복된 값이 제거되어야 한다.
    - 위의 unique_subquery는 유니크 하기 때문에 중복된 값이 없지만 다른 쿼리에서는 중복 발생 가능
    - **서브쿼리의 중복된 값을 인덱스를 통해 제거할 수 있을 때 사용된다.**
- range
    - 인덱스 레인지 스캔 형태의 접근 방법
    - 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미한다.
    - 일반적으로 가장 많이 사용하는 접근 방식이다.
- index_merge
    - 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후, 그 결과를 병합해서 처리하는 방식
    - 특징
        - 여러 인덱스를 읽기 때문에 range 접근보다 효율성이 떨어진다.
        - 전문 검색 인덱스를 사용하는 쿼리이면 index_merge가 적용되지 않음
        - 항상 2개 이상의 집합이 되기 때문에 합집합, 교집합 또는 중복 제거 같은 부가적인 작업 필요
    - extra 칼럼에 실행 계획에 조금 더 보완적인 내용이 표시된다.
    - 책 444 쿼리 예시 봐보기
- index
    - **인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미한다!**
    - 테이블 풀 스캔이랑 읽는 레코드 수는 같다. 단, 인덱스의 크기가 더 작기 때문에 속도는 더 빠르다.
    - 아래의 조건 중 1, 2 번째 또는 1, 3 번째 조건을 충족하는 쿼리에서 사용된다.
        - range나 const, ref 같은 방법으로 인덱스를 타지 못하는 경우
        - 인덱스에 포함된 칼럼만으로 처리할 수 있는 경우 (커버링 인덱스)
        - 인덱스를 이용해 정렬이나 그루핑 작업이 가능한 경우 (별도의 정렬을 피할 수 있는 경우)
- all
    - 테이블 풀 스캔
    - 위의 방법을 모두 쓰지 못 할때 사용하는 가장 비효율적인 방법
    - 대용량의 레코드를 처리하는 쿼리에서 인덱스를 잘못되게 사용하는 쿼리보다는 더 나은 접근
    - 책 447p 참고 읽어보기

### possible_keys 칼럼

MySQL 옵티마이저는 쿼리를 처리하기 위해 여러 가지 처리 방법을 고려하고 그 중에서 비용이 가장 낮을 것으로 예상되는 실행 계획을 선택해 실행한다.

**해당 칼럼은 위 과정에서 사용될 법했던 인덱스의 목록을 의미한다.** 

**→ 여기에 나왔다고 무조건 그 인덱스를 쓰는 것이 아니니 주의!**

### key 칼럼

**최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다!**

**쿼리를 튜닝할 때 key 칼럼에 의도했던 인덱스가 표시되는지 확인하는 것이 중요하다!**

primary인 경우 pk가 사용된다는 의미이고 그 외의 값은 모두 테이블이나 인덱스를 생성할 때 부여한 이름이 나옴

index_merge 실행 계획에서는 2개 이상의 인덱스가 표시된다.

### key_len 칼럼

중요한 정보 중 하나이다.

실제로 쿼리를 짜다보면 단일 칼럼 인덱스보다 다중 칼럼 인덱스가 더 많다.

→ key_len 칼럼은 다중 칼럼 인덱스에서 몇 개의 칼럼까지 사용됐는지 우리에게 알려준다.

→ 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값

책 450 예제들 보면서 바이트 어떻게 쓰는지 예시 보기

### ref 칼럼

접근 방법이 ref면 참조 조건(eq 비교 조건)으로 어떤 값이 제공됐는지 보여준다.

상수 값이면 const로 표시

다른 테이블의 칼럼 값이면 그 테이블명과 칼럼명이 표시

만약 func가 나온다면 콜레이션 변환 또는 값 자체의 연산을 거쳐서 참조됐음을 의미한다.

→ 이런 변환이 발생하지 않도록 조인 칼럼의 타입을 일치시키는게 좋다.

### rows 칼럼

rows 칼럼은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여주는 칼럼

옵티마이저가 산출해 낸 예상값이라 정확하지는 않다.

→ **반환하는 레코드의 예측치가 아니라 쿼리를 처리하기 위해 얼마나 많은 레코드를 읽고 체크해야 하는지를 의미한다.**

책 453 예시 보기

### filtered 칼럼

filtered 칼럼의 값은 필터링되어 버려지는 레코드의 비율이 아니라 필터링되고 남은 레코드의 비율을 의미한다.

MySQL 8.0 버전부터는 filtered 칼럼이 정확한 예측을 할 수 있도록 히스토그램 기능이 도입되었다.

- **성능 분석**: 높은 "filtered" 백분율은 `WHERE` 절이 효율적으로 많은 행을 필터링하고 있다는 것을 의미합니다. 반대로 낮은 백분율은 쿼리가 많은 수의 불필요한 행을 스캔하고 있다는 것을 나타내며, 성능 최적화의 여지가 있음을 시사합니다.
- **인덱스 사용**: "filtered" 값은 사용된 인덱스가 얼마나 효과적인지를 평가하는 데 도움이 될 수 있습니다. 인덱스가 잘 사용되면 높은 "filtered" 값을 기대할 수 있습니다.

### extra 칼럼

**성능에 관련된 중요한 내용이 자주 표시된다.**

내부적인 처리 알고리즘에 대해 더 자세하게 알려주는 경우가 많다.

- const row not found
    - const 접근 방법으로 테이블을 읽었는데 실제로 해당 테이블에 레코드가 1건도 존재하지 않는 경우
- deleting all rows
    - MyISAM 스토리지 엔진과 같이 스토리지 엔진 차원에서 테이블의 모든 레코드를 삭제하는 기능을 제공하는 스토리지 엔진 테이블인 경우 표시된다.
    - MySQL 8.0 부터는 안나옴
    - truncate 명령어를 사용하는게 더 좋다.
- distinct
    - 쿼리의 distinct를 처리하기 위해 조인하지 않아도 되는 항목은 모두 무시하고 필요한 것만 조인하여 꼭 필요한 레코드만 읽는다.
- firstmatch
    - 세미 조인의 여러 최적화 중에서 firstmatch 전략이 사용되면 firstmatch(table_name) 형태로 출력된다.
- full scan on null key
    - `col1 in (select co2 from …)` 형태의 쿼리에서 자주 발생한다.
    - 이 때 col1이 null이면 서브쿼리에 사용된 테이블에 대해서 풀 테이블 스캔을 해야 결과를 알 수 있다.
    - 만약 not null이 아니지만 null 비교 규칙이 필요하지 않다면 `col1 is not null` 을 추가하여 쿼리를 던져주면 된다.
- impossible having
    - 쿼리에 사용된 having 절의 조건을 만족하는 레코드가 없을 때 해당 키워드가 사용된다.
    - 쿼리가 제대로 작성되지 못한 경우이므로 쿼리를 다시 확인해봐야 한다.
- impossible where
    - where 조건이 항상 false가 되는 경우 사용된다.
    - 여기도 쿼리를 다시 확인해봐야함
- loosescan
    - 세미 조인 최적화 중 loosescan이 사용되는 경우 출력된다.
    - 9.3.1.13 루스 스캔 참고
- no matching min/max row
    - min() 또는 max()와 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한 건도 없을 때 출력된다.

> no matching이나 impossible where 등의 메서지가 무조건 쿼리 자체의 오류는 아니다.
다만 쿼리가 비즈니스 적으로 잘못된 것인지 확인해볼 필요는 있다.
> 
- no matching row in const table
    - 조인에 사용된 테이블에서 const 방법으로 접근할 때 일치하는 레코드가 없는 경우 표시된다.
- no matching rows after partition pruning
    - 파티션된 테이블에 대한 update, delete 명령의 실행 계획에서 표시될 수 있다.
    - 해당 파티션에 update 또는 delete할 대상 레코드가 없을 때 표시된다.
    - 더 정확하게는 대상 파티션이 없는 경우 출력된다.
- no tables used
    - from 절이 없는 쿼리 또는 dual을 사용하는 쿼리에서 출력된다.
- not exists
    - 아우터 조인을 이용해 안티-조인을 수행하는 쿼리에서 출력되는 실행 계획
- plan isn’t ready yet
    - explain for connection에서 조회하고자 하는 커넥션이 아직 쿼리의 실행 계획을 수립하지 못 한 상태에서 출력
- range checked for each record(index map: N)
    - 레코드마다 인덱스 레인지 스캔을 체크한다는 실행 계획
    - 책 468 - 470 예시 꼭 읽기!
- recursive
    - MySQL 8.0 버전부터 CTE를 활용해 재귀 쿼리 작성 가능
    - 재귀 쿼리의 실행 계획은 recursive가 표시된다.
- rematerialize
    - 래터럴 조인에서 출력되는 실행 계획
    - 11.4.7.6 래터럴 조인 확인하기
- select tables optimized away
    - min() 또는 max() 만 select 절에서 사용되거나 group by로 min(), max()를 조회하는 쿼리가 인덱스를 오름차순 또는 내림차순으로 1건만 읽는 형태의 최적화가 적용될 때 표시되는 실행 계획
    - 책 472 예시 확인하기
- start temporary, end temporary
    - 세미 조인 최적화 중 Duplicate Weed-out 최적화 전략이 사용되면 출력된다.
    - 9.3.1.14 중복 제거 참고하기!
- unique row not found
    - 두 테이블이 각각 유니크 칼럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 없는 경우 출력된다.
- using filesort
    - order by 처리가 인덱스를 사용하지 못할 때 출력된다.
    - **해당 쿼리는 많은 부하를 일으키기 때문에 쿼리를 튜닝하거나 인덱스를 생성하는게 좋다!**
- using index (커버링 인덱스)
    - 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 출력된다.
    - 커버링 인덱스가 만족될 때 출력된다. → 성능 향상
    - 만약 인덱스 레인지 스캔의 쿼리 성능이 마음에 들지 않는 경우 인덱스의 칼럼만 사용하도록 쿼리를 변경하면 큰 성능 향상을 가질 수 있다.
    - 책 478 예시 확인하기
- using index condition
    - 옵티마이저가 인덱스 컨디션 푸시 다운 최적화를 사용하면 출력된다.
    - 9.3.1.3 절 인덱스 컨디션 푸시 다운 참고하기!
- using index for group-by
    - group by 처리가 인덱스를 이용할 때 출력되는 실행 계획이다.
    - group by 처리를 위해 인덱스를 읽는 방법을 루스 인덱스 스캔이라고 한다.
    - 타이트 인덱스 스캔을 통한 group by 처리
        - avg(), count(), sum()과 같이 조회하려는 값이 모든 인덱스를 다 읽어야 할 때는 필요한 레코드만 듬성듬성 읽을 수가 없다
        - 이 때는 using index for group-by가 출력되지 않는다!
    - 루스 인덱스 스캔을 통한 group by 처리
        - 단일 칼럼으로 구성된 인덱스에서 그루핑 칼럼 말고 아무것도 조회하지 않는 쿼리에서 루스 인덱스 스캔 사용 가능
        - 다중 칼럼으로 구성된 인덱스에서는 group by 절이 인덱스를 사용할 수 있어야 하고 min(), max() 같이 조회하는 값이 인덱스의 첫 번째 또는 마지막 레코드만 읽어도 되는 쿼리에서 사용 가능
            - where 조건이 없는 경우
                - group by와 select 칼럼이 루스 인덱스 스캔 조건만 맞추면 된다.
            - where 조건이 있지만 검색을 위해 인덱스를 사용하지 못하는 경우
                - 이 경우 루스 인덱스 스캔을 사용하지 못한다.
                - 타이트 인덱스 스캔 과정으로 처리 됨
            - where 조건이 있고 검색을 위해 인덱스를 사용하는 경우
                - where 절의 조건이 인덱스를 탄다면 group by도 똑같은 인덱스를 타게 된다.
                - 이 경우 루스 인덱스 스캔 사용 가능
                - 옵티마이저는 where와 group by의 인덱스가 다른 경우 where가 선택되도록 실행 계획을 수립하는 경향이 있다.
                - 책 482 참고 확인
- using index for skip scan
    - 인덱스 스킵 스캔 최적화를 사용했을 때 출력된다.
    - 8.3.4.4 인덱스 스킵 스캔 확인
- using join buffer(block nested loop), using join buffer(batched key access), using join buffer(hash join)
    - 조인 버퍼가 사용되는 경우 출력된다.
    - 조인 버퍼 사이즈는 상황에 맞게 잘 조절하자
- using mrr
    - mrr 최적화가 사용된 경우 출력된다.
- using sort_union(), using union(), using intersect()
    - index_merge 접근으로 여러 인덱스가 동시에 사용되었을 때 두 인덱스로부터 읽은 결과를 어떻게 병합했는지 설명해주는 실행 계획
    - intersect → and 연산으로 묶인 경우, union → or 연산으로 묶인 경우
- using temporary
    - 임시 테이블을 활용했을 때 출력된다.
    - 책 487 임시 테이블이 사용되지만 해당 실행 계획이 출력되지 않는 케이스 확인하기
- using where
    - MySQL 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 처리한 경우 출력된다.
    - 체크 조건은 MySQL 엔진에서 처리되기 때문에 존재하는 실행 계획
- zero limit
    - limit 0를 통해 메타 정보만 조회하고자 하는 쿼리에서 출력된다.
