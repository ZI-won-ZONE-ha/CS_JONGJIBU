# Chapter8 인덱스

---

인덱스는 데이터베이스 쿼리 성능에 중요한 역할을 담당한다.

→ 쿼리 튜닝의 기본이 된다.

인덱스 별로 가지는 특성과 차이에 대해 알아보자

## 디스크 읽기 방식

---

데이터베이스 성능 튜닝은 어떻게 디스크 IO를 줄이느냐가 관건인 경우가 많다

랜덤 IO와 순차 IO에 대해 알아보자

### HDD, SSD

하드 디스크 드라이브는 기계식 장치이다.

→ 데이터베이스 서버에서 디스크 장치에 병목이 자주 발생한다.

하드 디스크를 대체하기 위해 SSD가 많이 사용된다.

SSD도 기존 하드 디스크 드라이브와 같은 인터페이스를 지원하여 내장 디스크, DAS, SAN에 그대로 사용 가능

SSD는 하드 디스크가 가지는 원판을 제거하고 플래시 메모리를 장착한다.

→ **디스크 원판을 일일히 회전하지 않으므로 빠르게 데이터를 읽고 쓸 수 있다.**

SSD의 장점은 랜덤 IO에 있다.

→ 랜덤 IO를 하기 위해 디스크 원판을 회전하지 않으므로 훨씬 빠름

### 랜덤 IO, 순차 IO

랜덤 IO는 하드 디스크 드라이브의 원판을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다.

순차 IO도 작업 과정은 같지만 두 IO에는 차이가 하나 있다.

**3개의 페이지를 기록하고자 할 때 랜덤 IO는 시스템 콜이 3번 발생하고 순차 IO는 시스템 콜이 1번 발생한다.**

디스크의 성능은 얼마나 디스크 헤더를 움직이냐에 따라 결정된다. → 랜덤 IO 작업을 줄이는게 중요하다.

MySQL 서버는 그룹 커밋, 바이너리 로그 버퍼, InnoDB 로그 버퍼 등의 기능을 제공하여 IO 작업을 줄여준다.

**쿼리를 튜닝한다 → 랜덤 IO를 줄이는게 목표!**

> 인덱스 레인지 스캔은 주로 랜덤 IO를 사용
풀 테이블 스캔은 순차 IO를 사용
→ 큰 테이블의 레코드를 대부분 읽는 작업은 풀 테이블 스캔을 유도하는게 좋다!
> 

## 인덱스란?

---

책의 색인에 비유하여 인덱스를 설명할 수 있다.

책의 찾아보기와 인덱스의 공통점은 정렬이다.

DBMS의 인덱스도 칼럼의 값을 주어진 순서대로 미리 정렬하여 보관

SortedList와 마찬가지로 인덱스도 저장되는 칼럼의 값을 이용해 데이터를 항상 정렬된 상태로 유지한다.

→ **데이터를 저장하는 과정이 느리지만, 이미 정렬되어 있어 데이터를 탐색하는건 빠르다!**

→ insert, update, delete는 느리지만 select는 빠르다

저장 속도와 읽기 속도가 서로 trade-off를 가지므로 인덱스를 추가하려는 테이블이 어떤 특징을 가지는지 꼭 확인해야한다.

- 역할에 따른 인덱스 구분
    - PK: 레코드를 대표하는 칼럼 Not Null, Unique
    - Secondary Key: PK를 제외한 나머지 인덱스
- 데이터 저장 방식에 따른 인덱스 구분
    - B-Tree 알고리즘: 가장 일반적으로 사용하는 인덱스 알고리즘
    - Hash Index 알고리즘: 칼럼의 값으로 해시를 계산하여 인덱싱하는 알고리즘, 범위 검색 안됨
- 데이터 중복 여부에 따른 인덱스
    - 유니크 인덱스: equal 조건 검색 시 1건의 데이터만 나옴을 보장해준다.
    - Non 유니크 인덱스

## B-Tree 인덱스

---

가장 일반적으로 사용되는 인덱싱 알고리즘

Balanced-Tree 인덱스

**칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태를 유지한다.**

### 구조 및 특성

최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어 있는 형태이다.

가장 하위에 있는 노드를 리프 노드, 중간의 노드를 브랜치 노드라고 한다.

데이터베이스의 인덱스와 실제 데이터가 저장된 데이터는 따로 관리된다.

**인덱스의 리프 노드에는 실제 데이터 레코드를 찾아가기 위한 주소값을 가지고 있다.**

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/38c26afa-d08a-43bd-8bd6-d7da68ee084c)

인덱스의 key 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않고 임의의 순서로 저장되어 있다.

→ 데이터베이스 테이블이 Insert만 일어나지 않고, Delete도 같이 일어나기 때문에 빈 공간을 재활용해서 이런 현상이 발생한다.

> InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장되므로 기본적으로 PK 순서로 정렬되어 저장된다. → 클러스터링 테이블 (chapter 4)
> 

인덱스는 테이블의 key 칼럼의 값만 가지고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다. → key를 가지고 데이터 파일에 매핑해줘야 된다.

InnoDB 테이블의 경우 인덱스를 통해 레코드를 읽는 경우 데이터 파일을 바로 찾아가지 못한다.

→ PK 값을 바탕으로 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장되어 있는 레코드를 읽는다.

→ 8.8절 클러스터링 인덱스에서 더 자세하게 확인

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/547ae552-9958-4a98-84e7-34d41c083709)

### B-Tree 인덱스 키 추가 및 삭제

- 인덱스 키 추가
    - 저장될 키 값을 이용해 B-Tree 상의 적절한 위치를 검색해야 한다.
    - 저장될 위치를 정하면 레코드의 키 값과 대상 레코드 주소 정보를 B-Tree의 리프 노드에 저장
    - 리프 노드가 꽉 차서 저장할 수 없는 경우 리프 노드를 분리해야 된다. → 처리 범위의 증가
    - 대략적으로 레코드 추가 비용이 1이면 인덱스에 키를 추가하는 비용은 1.5로 계산 (시간)
    - 4.2.10 체인지 버퍼 확인
- 인덱스 키 삭제
    - 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아 삭제하면 끝
    - 삭제 마킹된 인덱스 키 공간은 방치 or 재활용 가능
    - 마킹 작업도 디스크 쓰기 작업이 필요 → 디스크 IO 발생
    - InnoDB에서는 버퍼링 활용하여 지연 처리 가능
- 인덱스 키 변경
    - 먼저 기존의 Key를 제거하고 다시 새로운 Key를 넣는 방식으로 변경한다.
    - InnoDB 지연 처리 가능
- 인덱스 키 검색
    - 인덱스를 쓰기 성능을 포기하면서 쓰는 이유
    - 루트 노드부터 시작해 브랜치를 거쳐 최종 리프 노드까지 이동하면서 비교 작업 수행 → 트리 탐색
    - select에만 사용되는 것이 아닌 update, delete에서 레코드를 먼저 검색할 때도 사용한다.
    - **InnoDB 엔진에서 인덱스는 락과 연관있어 인덱스 설계가 정말 중요하다!**

## B-Tree 인덱스 사용에 영향을 미치는 요소

---

### 인덱스 키 값의 크기

디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 한다.

페이지는 InnoDB 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 함

**인덱스도 마찬가지로 페이지 단위로 관리된다.**

B-Tree의 자식 노드의 개수는 가변적인 구조이다.

→ 페이지 크기와 키 값의 크기에 따라 최대 자식 노드 개수가 정해진다.

**인덱스를 구성하는 키 값이 커지면 디스크로부터 읽어야 하는 횟수가 늘어난다.**

→ 탐색을 더 해야될 수 있다.

→ 버퍼 풀에 넣는 인덱스의 크기도 커지기 때문에 메모리에 저장하는 레코드 수도 줄어든다.

→ 메모리 효율이 떨어질 수 있다.

### B-Tree 깊이

인덱스의 깊이는 중요한데 직접 제어할 방법은 없다.

**깊이는 MySQL에서 값을 검색할 때 몇번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제**

인덱스의 키 값이 커지면 같은 레코드 개수라면 B-Tree의 깊이가 깊어져 디스크 읽기가 더 필요하게 된다.

**인덱스 키 값은 가능하면 작게 만드는게 좋다!**

### 선택도(기수성, Cardinality)

**모든 인덱스 키 값 가운데 유니크한 값의 수**

중복된 값이 많아지면 Cardinality가 낮아지고 동시에 선택도도 떨어진다.

→ 선택도가 떨어지게 되면 그 만큼 검색 대상이 늘어나기 때문에 처리 속도가 저하된다.

> Cardinality가 좋지 않더라도 정렬이나 그루핑 같은 작업을 위해 인덱스를 만드는게 좋은 경우가 있다.
→ 인덱스가 항상 검색에만 사용되는게 아니므로 적절한 선택이 필요하다
> 

결론적으로 인덱스에서 유니크한 키 값의 개수는 쿼리의 효율성에 큰 영향을 미친다! (책 228p 예시 참고)

### 읽어야 하는 레코드의 건수

인덱스를 통해 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 더 높은 비용이 드는 작업이다.

만약 100만건의 데이터 중 50만건을 읽어야 하는 경우가 있다고 가정할 때, 전체 테이블을 모두 읽고 50만개를 버리는게 효율적인지, 인덱스를 통해 50만개만 가져오는게 효율적일지 잘 판단해야 한다.

일반적으로 옵티마이저가 인덱스를 통해 데이터를 가져오는 것이 테이블에서 직접 가져오는 것에 비해 4~5배의 비용이 발생한다고 한다.

만약 **인덱스를 통해 읽을 데이터가 20~25%를 넘어선다면 테이블을 모두 직접 읽어서 필요한 레코드를 가져오는 방식이 더 효율적이다.**

→ 만약 인덱스를 쓰라고 힌트를 주더라도 옵티마이저가 풀 스캔으로 처리한다.

## B-Tree 인덱스를 통한 데이터 읽기

인덱스를 사용하게 유도할지, 사용하지 못하게 유도할지 판단하려면 인덱스를 어떻게 쓰는지 알아야 한다.

어떻게 인덱스를 사용하여 데이터를 읽는지 알아보자

### 인덱스 레인지 스캔

가장 대표적인 접근 방식

인덱스를 통해 레코드 1건만 읽는 경우 + 한 건 이상을 읽는 경우 모두를 포함하여 설명 (둘의 자세한 차이는 10장 실행 계획 참고)

**루트 노드에서 시작하여 리프 노드까지 레코드의 시작 지점을 찾은 후 리프 노드 간 링크를 활용하여 레인지 스캔한다.**

**어떤 방식으로 데이터를 스캔하든 관계없이, 인덱스를 구성하는 칼럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다.**

리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는데 레코드 한 건 단위로 랜덤 IO 발생

**커버링 인덱스로 처리될 시 인덱스 키와 레코드 주소를 바탕으로 레코드가 저장된 페이지를 가져오는 작업을 하지 않아도 된다. (인덱스 키에 원하는 데이터가 모두 있기 때문에)**

### 인덱스 풀 스캔

**인덱스의 처음부터 끝까지 모두 읽는 방식**

쿼리의 조건절에 사용되는 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔을 사용한다.

쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 이 방식을 사용한다.

→ 인덱스의 크기가 테이블의 크기보다 작으므로

```sql
index (name, age);

select name, age from member;
```

### 루스 인덱스 스캔

듬성듬성 인덱스를 읽는 방식

레인지 스캔과 비슷하게 작동하지만 중간에 필요없는 인덱스 키 값은 스킵하고 다음으로 넘어간다.

일반적으로 group by, max(), min()에 대해 최적화할 때 사용한다.

여러 조건을 만족해야 사용할 수 있다. (10장 실행 계획 참고)

### 인덱스 스킵 스캔

인덱스의 핵심은 값이 정렬되어 있다는 것이다.

→ 인덱스를 구성하는 컬럼의 순서가 중요하다!

MySQL 8.0부터는 옵티마이저가 첫 번째 칼럼을 건너뛰고 다음 칼럼으로도 인덱스 검색이 가능하게 하는 인덱스 스킵 스캔 최적화 기능이 도입되었다.

루스 인덱스 스캔 같은 경우 group by를 처리하는 경우에만 사용할 수 있었다는 차이점이 존재한다.

실행 계획에 `Using index for skip scan` 이 있다면 인덱스 스킵 스캔을 사용했다는 의미이다.(책 238p 예제 확인)

→ 옵티마이저가 최적화를 해준다.

다만 인덱스 스킵 스캔은 다음과 같은 단점이 있다.

- where 조건에 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 한다.
- 커버링 인덱스를 만족해야 한다.

## 다중 칼럼 인덱스

---

2개 이상의 칼럼을 포함하는 인덱스

두 번째 칼럼이 첫 번째 칼럼에 의존해서 정렬된다.

→ 첫 번째 칼럼이 같은 경우 두 번째 칼럼이 정렬된다.

**이런 다중 칼럼 인덱스의 성질로 인덱스 내의 칼럼의 위치(순서)가 상당히 중요하다!** 

> 잠깐 꿀팁
인덱스의 칼럼이 여러 개일 경우 카디널리티가 높은 순서대로 생성하는 것이 좋다!
https://jojoldu.tistory.com/243
> 

## B-Tree 인덱스의 정렬 및 스캔 방향

---

인덱스의 키 값은 항상 오름차순이거나 내림차순으로 정렬되어 저장한다.

인덱스를 어떤 방향으로 읽을지는 쿼리에 따라 옵티마이저가 결정한다.

### 인덱스의 정렬

MySQL 8.0 버전부터 다음과 같은 형태의 정렬 순서를 혼합한 인덱스를 생성할 수 있다.

```sql
create index ix_teamname_userscore on employees (team_name asc, user_score desc);
```

### 인덱스 스캔 방향

옵티마이저가 상황에 맞게 스캔 방향을 잘 설정해준다.

→ 쿼리가 인덱스를 사용하는 시점에 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.

쿼리의 order by, min(), max() 등의 최적화가 필요할 때도 옵티마이저는 인덱스 읽기 방향을 전환해서 사용하도록 실행 계획을 만들어 낸다.

### 내림차순 인덱스

복합 인덱스에서 각각의 칼럼에 내림차순과 오름차순이 혼합된 경우 **MySQL 8.0의 내림차순 인덱스로만 해결될 수 있다.**

- 오름차순 인덱스: 작은 값의 인덱스 키가 왼쪽으로 정렬된 인덱스
- 내림차순 인덱스: 큰 값의 인덱스 키가 왼쪽으로 정렬된 인덱스
- 인덱스 정순 스캔: 왼쪽 → 오른쪽 스캔
- 인덱스 역순 스캔: 오른쪽 → 왼쪽 스캔

p244-p245 테스트 보기

InnoDB에서 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느리다.

- 페이지 잠금이 정순 스캔에 적합한 구조
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

**쿼리가 인덱스의 특정 앞쪽 또는 뒤쪽으로 집중적으로 읽을 상황이라면 자주 사용되는 방향으로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는데 도움이 될 것이다.**

## B-Tree 인덱스의 가용성과 효율성

---

where, group by, order by가 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 한다.

### 비교 조건의 종류와 효율성

다중 칼럼 인덱스에서 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등 비교인지 아니면 크다, 작다 비교인지에 따라 인덱스 칼럼 활용 형태가 달라진다.

p247-248 예제 확인하기

다중 칼럼 인덱스의 순서에 따라 효율성이 달라지게 된다.

작업 범위 결정 조건과 필터링 조건을 잘 파악해서 인덱스 순서를 지정해줘야 한다.

작업 범위 결정 조건이 많을수록 성능이 좋아진다.

필터링 조건은 많아진다고 쿼리의 성능을 높이진 못한다.

### 인덱스의 가용성

정렬 우선 순위가 낮은 값으로는 인덱스의 가용성을 높일 수 없다.

`like ‘%hello’` , 다중 컬럼 인덱스에서 2번째 컬럼만 where 조건에 있는 경우 인덱스의 가용성이 떨어진다.

### 가용성과 효율성 판단

아래와 같은 경우에는 인덱스를 작업 범위 결정 조건으로 활용할 수 없다. 단, 필터링 조건으로는 사용할 수 있다.

- Not Equal로 비교된 경우 (≠, not in, not between, is not null)
- `like ‘%??’`과 같이 뒷 부분 일치로 문자열 패턴 비교
- 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
- Not-Deterministic 속성의 스토어드 함수가 비교 조건에 사용된 경우
- 데이터 타입이 서로 다른 비교 (인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
- 문자열 데이터 타입의 콜레이션이 다른 경우
- 다중 칼럼 인덱스
    - 작업 범위 결정 조건으로 인덱스를 쓰지 못하는 경우
        - 첫 칼럼에 대한 조건이 없는 경우
        - 첫 칼럼이 위 불가 조건에 걸리는 경우
    - 작업 범위 결정 조건으로 인덱스를 사용하는 경우
        - 첫 칼럼 ~ 어느 시점 칼럼까지 동등 비교 형태( =, in)
        - i 번째 칼럼에 대해 다음 연산자 중 하나로 비교
            - 동등 비교
            - 크다 작다
            - like 좌측 일치 패턴

## R-Tree 인덱스

---

MySQL의 공간 인덱스라는 인덱스가 있다.

공간 인덱스는 R-Tree 인덱스 알고리즘을 활용하여 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스다.

인덱스를 구성하는 칼럼 값이 2차원 공간으로 이루어져 있다.

위치 기반 서비스를 구현하는 방법으로 MySQL의 공간 확장(Spatial Extension)을 이용하면 간단하게 이러한 기능을 구현할 수 있다. MySQL의 공간 확장에는 다음과 같은 세 가지 기능이 있다.

- 공간 데이터를 저장할 수 있는 데이터 타입
- 공간 데이터 검색을 위한 공간 인덱스 (R-Tree 알고리즘)
- 공간 데이터의 연산 함수 (거리 또는 포함 관계의 처리)

## R-Tree 인덱스 구조 및 특성

---

MySQL은 공간 정보의 저장 및 검색을 위해 여러 가지 기하학적 도형 정보를 관리할 수 있는 데이터 타입을 제공한다.

Point, Line, Polygon, Geometry

Geometry는 슈퍼 타입이다. → 앞의 3개의 타입을 모두 저장할 수 있음

MBR(Minimum Bounding Rectangle): 해당 도형을 감싸는 최소 크기의 사각형을 의미한다.

**이러한 사각형(MBR)들의 포함 관계를 B-Tree 형태로 표현한 것이 R-Tree 인덱스이다.**

최상위 MBR(루트 노드) → 브랜치 노드 → 최하위 MBR(리프 노드)

## R-Tree 인덱스의 용도

---

공간 인덱스라고도 부르는 R-Tree 인덱스는 일반적으로 GPS 기준 위도, 경도 좌표 저장에 주로 사용된다.

R-Tree 인덱스는 도형의 MBR의 포함 관계를 이용하여 만들어진 인덱스이다.

→ `ST_Contains()` 또는 `ST_Within()` 과 같은 포함 관계를 비교하는 함수로 검색하는 경우에만 인덱스를 사용할 수 있다.

`ST_Contains()`와 `ST_Within()` 는 사각형 박스와 같은 다각형으로만 연산이 되므로 반경 5km와 같은 원형 정보가 필요하다면 `ST_Distance_Sphere()` 을 사용하여 원형으로 만들어줘야 한다.

## 전문 검색 인덱스

---

앞에서 본 인덱스 알고리즘은 일반적으로 크지 않은 데이터 또는 이미 키워드화한 작은 값에 대한 인덱싱 알고리즘

→ 전체 일치 또는 좌측 일부 일치와 같은 검색만 가능하다.

특정 키워드가 포함된 문서를 검색하는 전문 검색에는 InnoDB나 MyISAM에서 제공하는 B-Tree 알고리즘을 사용할 수 없다.

**문서 전체에 대한 분석과 검색을 위한 인덱싱 알고리즘을 전문 검색 인덱스라고 한다.** 

### 인덱스 알고리즘

사용자가 검색하게 될 키워드를 분석해 내고, 빠른 검색용으로 사용할 수 있게 키워드로 인덱스를 구축한다.

기법에 따라 어근 분석과 n-gram 분석 알고리즘으로 구분할 수 있다.

### 어근 분석 알고리즘

MySQL 서버의 전문 검색 인덱스는 2가지 과정을 거쳐서 색인 작업을 수행한다.

- 불용어 처리: 검색에서 별 가치가 없는 단어를 필터링해서 제거하는 작업
- 어근 분석: 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업

MeCab 오픈소스 라이브러리를 활용하여 어근 분석을 한다.

→ 일본어 기반이라 한글에 맞는 완성도를 갖추기 위해 언어 학습 과정이 필요하다

### n-gram 알고리즘

단순히 키워드를 검색해내기 위한 인덱싱 알고리즘

본문을 몇 글자씩 잘라서 인덱싱한다.

→ 언어를 이해하기 위한 과정이 필요없어 단순하지만 만들어진 인덱스가 크다는 단점이 있다.

책 260p 예제 확인하기

불용어를 거르는 작업을 MySQL 서버가 수행한다.

### 불용어 변경 및 삭제

불용어 처리로 인해 사용자에게 더 혼란스러운 상황을 줄 수 있다.

그래서 불용어 자체를 무시하거나 사용자가 불용어를 직접 등록하는 방법을 권장한다.

- 전문 검색 인덱스의 불용어 처리 무시
    - MySQL 서버의 모든 전문 검색 인덱스에 대해 불용어를 완전히 제거하는 방법
        - my.cnf 파일의 `ft_stopword_file` 에 빈 문자열 설정하면 된다.
        - 사용자 불용어 설정할 때도 사용할 수 있음
    - InnoDB 테이블의 전문 검색 인덱스에 대해 불용어 처리 무시하는 법
        - `innodb_ft_enable_stop` 시스템 변수 OFF로 설정
- 사용자 정의 불용어 사용
    - `ft_stopword_file = '/data/custom.txt'` 형태로 불용어를 등록해주면 된다.
    - InnoDB 테이블의 경우 아래와 같은 방법으로 등록 가능
        - `create table my_stopword(value VARCAHR(30)) engine = INNODB;`
        - `insert into my_stopword(value) values (’불용어’);`
        - `set global innodb_ft_server_stopword_table=’mydb/my_stopword’;`
        - `alter table tb_bi_gram add fulltext index fx_title_body(title, body) with parser ngram;`

### 전문 검색 인덱스의 가용성

전문 검색 인덱스를 사용하려면 다음 2가지 조건을 갖춰야 한다.

- 쿼리 문장이 전문 검색을 위한 문법을 사용
- 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유

전문 검색 인덱스를 사용하려면 반드시 `watch() against()` 구문으로 검색 쿼리를 작성해야 한다.

```sql
select * from tb_test where watch(doc_body) against('애플' in boolean mode);
```

## 함수 기반 인덱스

---

일반적인 인덱스는 칼럼의 값 일부 또는 전체에 대해서만 인덱스 생성이 가능하다.

칼럼의 값을 변형한 값으로 인덱스를 만들어야 할 때도 있는데 이 경우 함수 기반 인덱스를 활용하면 된다.

### 가상 칼럼을 이용한 인덱스

두 칼럼의 값을 합쳐서 검색해야되는 요건이 생긴다면 가상 칼럼을 활용할 수 있다.

```sql
alter table users 
add full_name varchar(30) as (concat(first_name, ' ', last_name)) virtual,
add index ix_fullname (full_name); 
```

다만 가상 칼럼은 테이블에 새로운 테이블이 추가되는 효과를 주기 때문에 실제 테이블 구조가 변경되는 단점이 있다.

### 함수를 이용한 인덱스

MySQL 8.0부터는 테이블 구조를 변경하지 않고, 함수를 직접 사용하는 인덱스를 생성할 수 있게 되었다.

```sql
create table users(
	...
	index ix_fullname ((concat(first_name, ' ', last_name)))
);
```

단, 함수 기반 인덱스를 제대로 활용하려면 반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용되어야 한다. → 안그러면 옵티마이저가 인식을 못 함

## 멀티 밸류 인덱스

---

전문 검색 인덱스를 제외한 모든 인덱스는 레코드 1건이 1개의 인덱스 키 값을 가진다.

인덱스 키와 데이터 레코드는 1:1이다.

**멀티 밸류 인덱스는 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스이다.**

→ RDBMS들이 Json 타입을 지원하기 시작하면서 Json 배열의 원소에 대한 인덱스가 필요해졌다.

```sql
-- 생성
index idx ((cast(credit_info -> '$.credit_scores' as unsigned array));

-- 사용
select * from user where 360 member of(credit_info -> '$.credit_scores');
```

## 클러스터링 인덱스

---

InnoDB 스토리지 엔진에서만 지원한다.

테이블의 PK에 대해서만 적용되는 내용이다.

→ PK 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 한다.

→ PK 값에 의해 레코드의 저장 위치가 결정된다.

→ PK 값이 변경되면 물리적인 데이터 저장 위치도 변경되어야 한다.

PK를 신중하게 설정해야 한다.

- 클러스터링 인덱스 선정 조건
    1. PK가 있으면 PK
    2. not null + unique 인덱스 중 첫 번째 인덱스 선택
    3. 자동으로 유니크한 값을 가지도록 증가하는 칼럼을 내부적으로 추가한 후 클러스터링 인덱스로 선택

### 세컨더리 인덱스에 미치는 영향

InnoDB 테이블에서 PK가 바뀌어 물리적인 레코드 위치가 바뀌는 상황에 대비하기 위해 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아닌 PK 값을 가지도록 구현한다.

### 클러스터링 인덱스의 장점과 단점

- 장점
    - PK로 검색할 때 매우 빠르다.
    - 테이블의 모든 세컨더리 인덱스가 PK를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많다
- 단점
    - 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스 크기가 커진다.
    - 세컨더리 인덱스를 사용할 때 PK로 다시 검색해야 하므로 처리 성능이 느리다.
    - insert할 때 PK에 의해 레코드 저장 위치가 결정되기 때문에 처리 성능이 느리다.
    - PK를 변경할 때 레코드를 delete하고 insert하는 작업이 필요해 처리 성능이 느리다.

### 클러스터링 테이블 사용 시 주의사항

- 클러스터링 인덱스 키의 크기
    - 모든 세컨더리 인덱스가 PK 값을 포함하기 때문에 PK 크기가 커지면 세컨더리 인덱스 크기도 커진다.
- PK는 Auto-Increment보다는 업무적인 칼럼으로 생성 (가능한 경우)
    - 업무적으로 해당 레코드를 대표할 수 있다면 PK로 두는게 좋다.
- PK는 반드시 명시할 것
    - 가능하면 PK는 생성하는 것을 권장한다.
- Auto-Increment 칼럼을 인조 식별자로 사용할 경우
    - 프라이머리 키의 크기가 길다면 auto-increment 칼럼을 추가하고, 이를 PK로 두는게 좋다.

## 유니크 인덱스

---

**MySQL에서는 칼럼에 unique 제약을 걸면 유니크 인덱스도 같이 생성된다.**

### 유니크 인덱스와 일반 세컨더리 인덱스의 비교

유니크 인덱스와 세컨더리 인덱스는 사실 인덱스의 구조상 아무 차이가 없다.

- 인덱스 읽기
    - 유니크 인덱스라고 빠른것이 아닌 유니크 인덱스는 값을 1개만 가져오기에 빠르다고 느끼는 것이다.
    - 레코드를 몇 개 읽느냐에서 성능 차이를 느낀다.
- 인덱스 쓰기
    - 유니크 인덱스의 경우 쓰기 전에 중복되는 값인지 확인하는 과정 필요해 더 느리다.
    - 중복되는 값을 체크할 때 읽기 잠금을 사용하고 쓸 때는 쓰기 잠금을 사용해 데드락이 자주 발생

### 유니크 인덱스 사용 시 주의사항

꼭 필요한 경우라면 유니크 인덱스를 생성하는 것이 당연하지만 더 성능이 좋아질 것으로 생각하고 불필요하게 유니크 인덱스를 생성하지 않는게 좋다.

유니크 필드에 인덱스를 만들지 않아도 된다. → 이미 유니크 인덱스가 생성되기 때문에

**유일성이 반드시 보장되어야 하는 칼럼에 대해서는 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 세컨더리 인덱스를 사용하자!**

## 외래키

---

외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있다.

**외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다.**

→ 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.

InnoDB의 외래키 관리에는 중요한 두 가지 특징이 있다.

- 테이블의 변경(쓰기 락)이 발생하는 경우에만 잠금 경합(대기)이 발생한다.
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(대기)을 발생시키지 않는다.

### 자식 테이블의 변경이 대기하는 경우

자식 테이블의 외래키 칼럼의 변경은 부모 테이블 확인이 필요한데, 이 상태에서 부모 테이블의 해당 레코드가 쓰기 락이 걸려 있으면 락을 기다린다.

### 부모 테이블의 변경이 대기하는 경우

Cascade 옵션이 걸려있을 때 자식 테이블에 어떠한 작업이 진행 중이고 여기에 락이 걸려있다면 자식 테이블의 작업을 기다려야 한다.

## 참고

Real MySQL 8.0 Chapter 8

https://12bme.tistory.com/138
