잠금, 트랜잭션, 트랜잭션의 격리 수준을 살펴본다. 

## 트랜잭션이란?

트랜잭션은 작업의 **`완전성`** 을 보장해주는 것이다. 

즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다. 

## 트랜잭션, 그리고 잠금

`잠금`(Lock)과 `트랜잭션은` 서로 비슷한 개념 같지만 사실 잠금은 `동시성을` 제어하기 위한 기능이고 트랜잭션은 데이터의 `정합성을` 보장하기 위한 기능이다.  

- 동시성과 정합성이란?
    - 동시성
    - 정합성 : 서로 모순이 없이 일관되게 일치해야 한다는 의미
    - 무결성: 데이터 베이스 제약조건이 달라질 때
    
    [무결성과 정합성이란 무엇인가?](https://velog.io/@yangsijun528/무결성과-정합성이란-무엇인가#데이터-정합성data-consistency)
    
    - DDL :  DB를 정의하는 명령어. 대표적으로 **CREATE, DROP, ALTER, TRUNCATE** 가 해당된다.
    - DML : DB에서 데이터를 조작하는 명령어. 즉 우리가 가장 많이 사용하는 **SELECT, INSERT, UPDATE, DELETE** 등이 해당된다.

## MySql 에서의 트랜젝션

트랜젝션을 지원하는 스토리지 엔진인 InnoDB와  트랜젝션을 지원하지 않는 MyISAM을 대표적으로 예로 들 수 있다. 

- MyISAM 은 Partial Update를 지원한다. → 데이터의 정합성을 맞추는데 어려움을 초래한다.
- InnoDB는 일부라도 오류가 발생하면, 전체를 원 상태로 만든다.

### 주의 사항

- **데이터 베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화 돼 있는 프로그램의 범위를 최소화 시킨다.**
    - **네트워크 작업이 있는 경우에는 반드시 트랜젝션에서 배제한다.**
    
    ex) FTP 파일 전송, 또는 네트워크를 통해 원격서버와 통신하는 등과 같은 작업은 DBMS 트랜잭션 내에서 제거하는게 좋다. 
    

# MYSQL 에서 사용되는 잠금

크게 두가지로 나눌 수 있다.

- 스토리지 엔진 레벨
    - 스토리지 엔진 간 상호 영향을 미치지 않는다.
- MYSQL 엔진 레벨 = 전체 - 스토리지 엔진 레벨
    - 모든 스토리지 엔진에 영향을 미친다.

## MySQL 엔진의 잠금

### 글로벌 락 (GLOBAL LOCK)

- `FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있다.
- MYSQL에서 제공하는 잠금 가운데 가장 범위가 크다. MYSQL 서버 전체, 테이블 OR 데이터 베이스가 다르더라도 영향을 미친다.
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 `SELECT`를 제외한 대부분의 DDL 문장이나 DML 문장을 실행할 경우, 글로벌 락이 해제 될 때까지 대기 상태로 남는다.
- 실행되기 전 모든 종류의 쿼리가 완료되어야 하고, 실행되는 동안에 `INSERT`, `UPDATE`, `DELETE` 쿼리가 오랜 시간 동안 실행되지 못할 수도 있다.
- 백업 락

### 테이블 락

- 개별 테이블 단위로 설정되는 잠금이다.
    - **명시적으로** `LOCK TABLES table_name [ READ | WRITE ]`  명령으로 Table Lock을 획득한다. 또한 `UNLOCK TABLES` 명령으로 풀어줄 수 있다.
    - **묵시적인** 테이블 락은 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.
        - 즉, 쿼리가 실행되는 동안 자동으로 획득됐다가 쿼리가 완료된 후 자동 해제된다.
        - InnoDB 테이블의 경우, **스토리지 엔진 차원에서 레코드 기반 잠금을 제공**하기 때문에 단순 데이터 변경 쿼리로 인해 테이블 락이 설정되지 않는다. → **DML 에서는 무시, DDL 에서는 적용**

### 네임드 락 (NAMED LOCK)

- GET_LOCK() 함수를 이용해 임의의 문자열에 대해 잠금을 설정한다.
- 사용자가 지정한 문자열에 대해 획득하고 반납하는 잡금이다.
- 여러 클라이언트가 상호 동기화를 처리할 떄, 많은 레코드에 대해 복잡한 요건으로 레코드를 변경할 때 유용하다.
    - 데이터 베이스 서버 1대, 웹 서버 5대와 같은 경우 여러 클라인언트에서 상호 동기화 처리할 때 유용
    - 배치 프로그램 같이, 많은 레코드를 변경하는 쿼리는 데드락 많이 발생 → 이를 해결할 수 있다.
    

### 메타데이터 락

- 데이터 베이스 객체 (테이블, 뷰)의 이름이나 구조를 변경하는 경우 사용.
- 명시적 획득, 해제가 없고, `RENAME TABLE tab_a to tab_b` 과 같은 쿼리.
    - Rename Table 명령의 경우, 원본 이름과, 변경될 이름 두 개 모두 한꺼번에 잠금을 설정한다.
- 테이블 락 때

## InnoDB 스토리지 엔진 잠금

InnoDB 에는 MYSQl 의 잠금 방식뿐만 아니라 레코드 기반의 잠금 방식도 지원한다. 일반적인 DBMS와 다르게, 레코드락과 갭락을 지원한다. 

### 레코드 락 (Record Lock)

- 일반적인 DBMS의 레코드락과 동일하지만, 인덱스의 레코드를 잠근다는 것에서 다르다.
    - 인덱스가 없을 경우, 자동 생성된 `클러스터 인덱스`를 이용하여 잠금을 설정한다.
    - `보조 인덱스`를 이용한 변경 작업은 `넥스트락` 또는 `갭락`을 이용하지만 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업에서는 갭에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다.
        - cf) 보조 인덱스란?
            
        ![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/87687210/7480fcf0-5890-4f65-8ab0-136e023338ac)
            

### 갭 락 (Gap Lock)

레코드와 레코드 사이의 간격만을 잠근다. 사이에 insert되는 것을 제어한다. 

- **레코드 밖에서의 간격 까지 포함**

### 넥스트 키 락

- 레코드 락 + 갭 락
- [STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 REPEATABLE READ 격리 수준을 사용해야한다.](https://www.notion.so/889cf55f5e5b44659ef5485c20a5b2c8?pvs=21)
- [바이너리 로그 포맷을 Row로 바꾸어 넥스트 키 락과 갭 락을 줄일 수 있다.](https://www.notion.so/97d01b6802064f5a8923fd12181abdec?pvs=21)

### 자동 증가 락

- `AUTO_INCREMENT` 라는 칼럼 속성 제공, **테이블 수준의 잠금**
- `INSERT`, `REPLACE` 쿼리 문장과 같이 새로운 레코드 저장할 때 사용
- 트랜젝션과 관련 없다.
- 테이블 당 단 하나만 존재한다.
- 명시적으로 획득할 수 없다.
- innodb_autoinc_lock_mode 를 통해 자동 증가 락의 작동 방식을 변화시킬 수 있다.
- 자동 증가 값이 한 번 증가하면 절대 줄어들지 않는다. → AUTO_INCREMENT 잠금 최소화

## 인덱스와 잠금

- InnoDB는 검색한 인덱스의 레코드에 모두 락을 걸어야 한다. 만약 인덱스가 없다면 풀스캔을 하며 모든 레코드 잠금한다.
- 레코드 수준의 잠금은 MYSQL 버전이 바뀜에 따라, 잠금과 잠금 대기 순서를 확인할 수 있게 되었다.
- **IX 락?**
    - 트랜잭션이 테이블의 개별 row에 락을 설정하는 의도를 나타낸다.
    - 테이블 수준의 락

[InoDB 잠금 (1) S락, X락, IS락, IX락](https://rosebud90.tistory.com/entry/InoDB-잠금-1-S락-X락-IS락-IX락)

---

# 격리 수준

## 트랜잭션의 격리 수준

여러 트랜젝션이 동시에 처리될 때, `특정 트랜젝션`이 `다른 트랜젝션`에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정.

- 4개의 격리 수준에서 순서대로 뒤로 갈수록 각 트랜잭션 간의 데이터 격리 정도가 높아지면, 동시 처리 성능도 떨어진다.

|  | DirtyRead | Non-Repeatable Read | Phantom-read |
| --- | --- | --- | --- |
| Read Uncommited | 발생 | 발생 | 발생 |
| Read Commited | 없음 | 발생 | 발생 |
| Repeatable Read | 없음 | 없음 | 발생(InnoDB 없음) |
| Serializable | 없음 | 없음 | 없음 |

### Read Uncommited

- `Dirty Read` 발생
    - 트랜젝션의 변경 내용이 `COMMIT` 이나 `ROLLBACK` 여부에 상관없이 다른 트랜잭션에서 보인다.

### Read Commited

- `Dirty Read` 발생 X
- 어떤 트랜잭션에서 변경한 내용이 커밋되기 전까지는 다른 트랜잭션에서 그러한 변경 내역 조회 X
    - 언두 영역에 백업된 레코드를 가져온다.
- `NON-REPEATABLE READ` 발생
    - 이는 만약, 다른 세션에서 update 치고 commit을 하면 동일한 트랜젝션에서도 다른 결과를 초래.
    - 같은 트랜젝션 냉**데이터가 변경이 된다.**
    

<aside>
💡 트랜젝션 내에서 실행되는 SELECT 문장 그리고 트랜잭션 없이 실행되는 SELECT 문장

- READ COMMITTED
    - 둘의 차이가 없다.
- REPEATABLE READ
    - SELECT 쿼리 문장도 트랜잭션 범위 내에서만 작동한다. 즉, 같은 트랜잭션에서는 동일한 결과!
    
</aside>

범위 집합 → select 쿼리 문장. 데이터는 같은데, 못봤던 row 가 생길 수 있다. 

### REPEATABLE READ

- `NON-REPEATABLE READ` 발생 X
- 트랜잭션 장기간 종료하지 않으면, 언두 영역에 백업된 데이터로 Mysql 서버 성능 떨어질 수 있다.
- `PHANTOM READ`  발생
    - 다른 트랜젝션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상
    - `Select For Update`, `Select … lock in Share Mode` 쿼리는 Select하는 레코드에 쓰기 잠금을 걸어야 하는데 언두 레코드에는 걸 수 없다.  → 언두 영역의 데이터가 아닌 현재 레코드를 가져옴.
    - InnoDB에서는 갭 락과 넥스트 키 락 덕분에 `PHANTOM READ`가 발생하지 않음.

<aside>
💡 MVCC(Multi Version Concurrency Control)

- 롤백 가능성에 대비해 변경되기 전 레코드를 언두 공간에 백업하고 실제 레코드 값 변경.
- 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜젝션 내에서 동일한 결과를 보장
</aside>

### SERIALIZABLE

- 읽기 잠금도 공유 잠금 (읽기 잠금)을 획득해야 한다.
- `PHANTOM READ`  발생 X

<aside>
💡 Non-locking Consistent Read (잠금이 필요 없는 일관된 읽기) 
- 순수한 Select 작업

</aside>

- phantom read, non repeatable 다시 정리
- 범위 집합에서만 phantom read 가 발생.

# 참고 자료

Real MySQL 8.0

[[MySQL]MySQL 벼락치기(5) - 갭락(Gap Lock)과 넥스트 키 락(Next-Key Lock)](https://idea-sketch.tistory.com/46)

[Lock으로 이해하는 Transaction의 Isolation Level](https://suhwan.dev/2019/06/09/transaction-isolation-level-and-lock/)

https://github.com/woowacourse-study/2022-Real-MySQL/issues/8
