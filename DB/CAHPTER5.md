## 트랜잭션과 잠금

---

MySQL의 **동시성에 영향을 주는 요소**이다. 각각에 대해서 간단하게 살펴보자

### 트랜잭션

작업의 완전성을 보장해 주는 것

여러 연산을 논리적인 작업으로 묶고 **논리적인 작업을 모두 완벽하게 처리하거나, 처리하지 못할 경우 원 상태로 복구(All or Nothing)**

작업의 일부만 성공하는걸 막는 것을 목표로 한다.

### 잠금(Lock)

동시성을 제어하기 위한 기능

여러 커넥션이 **동시에 하나의 데이터를 변경하고자 할 때 한 시점에 하나의 커넥션만 변경**할 수 있게 해주는 역할을 수행

만약 동시에 데이터를 변경한다면 결과 값을 예측할 수 없는 현상이 발생한다.

## 트랜잭션

---

### MySQL에서 트랜잭션

트랜잭션은 하나의 논리적인 작업에 몇 개의 쿼리가 있든 논리적인 작업이 All or Nothing을 지켜야한다.

→ 커밋 또는 롤백이 수행되어야 한다.

<img width="642" alt="스크린샷 2023-10-08 오후 8 08 29" src="https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/835d962e-98ee-46e6-8f55-570dca3d5718">

- MyISAM

<img width="137" alt="스크린샷 2023-10-08 오후 8 09 21" src="https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/22781a0b-73bf-4e42-aacb-00c9b0ca3501">

- INNODB

<img width="116" alt="스크린샷 2023-10-08 오후 8 09 51" src="https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/3af76cc1-06ed-44ee-a37d-877e421da9e0">

트랜잭션을 지원하지 않는 MyISAM의 경우 퀴리의 일부가 실패해도 그 전까지 쿼리는 Commit이 일어나고 INNODB의 경우 일부 연산이 실패한 경우 RollBack되는 것을 알 수 있다.

이렇게 MyISAM에서 발생하는 현상을 Partial Update라고 한다.

→ 이렇게 부분 업데이트가 된다면 실패한 쿼리로 인해 다른 레코드를 재처리 해줘야 한다.

트랜잭션을 지원함으로 이런 상황에 대한 고민을 하지 않아도 된다.

## 트랜잭션 주의사항

---

트랜잭션은 최소한의 코드에만 적용하는 것이 좋다.

프로그램 코드에서 트랜잭션을 최소화 해야 한다.

- DBMS에 데이터를 저장하거나 수정하는 작업부터 트랜잭션을 시작하는게 좋다.
- **네트워크를 통한 원격 서버와 통신하는 작업은 트랜잭션에서 분리해야 된다!!!(제일 중요)**
    - 외부 서버와 통신하는 과정에서 문제가 생길시 트랜잭션을 계속 물게 되어 이슈가 발생할 수 있다.
- 단순 조회 작업은 굳이 트랜잭션을 걸지 않아도 된다.
- 작업의 성격이 다르다면 굳이 하나의 트랜잭션에 있을 필요가 없다.

핵심은 **트랜잭션을 최소화 하는 것이 핵심**이다. 이를 잘 지켜서 개발하자!

## MySQL 엔진의 락

---

### 글로벌 락

`FLUSH TABLES WITH READ LOCK` 명령어로 얻을 수 있다.

MySQL이 제공하는 락 중 범위가 가장 크다.

어느 한 세션이 글로벌 락을 얻으면 다른 세션에서 `select` 를 제외한 대부분의 문장이 대기를 한다.

MySQL 서버 전체에 영향을 준다. → 테이블이나 데이터베이스가 달라도 영향을 받음

MyISAM, MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받아야 할 때 글로벌 락을 사용한다.

> 주의: mysqldump 같은 백업을 수행할 때 글로벌 락이 실행될 수 있으니 덤프를 할 때 어떤 락이 걸리는지 먼저 확인하고 덤프를 걸도록 하자!
> 

InnoDB 같은 경우 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요가 없다.

→ 더 가벼운 글로벌 락이 생겼다. Xtrabackup, Enterprise Backup과 같은 백업 툴을 위한 백업 락이 도입됨

**백업락 추가**

### 테이블 락

개별 테이블 단위로 적용되는 락

명시적, 묵시적으로 특정 테이블에 대한 락을 얻을 수 있다.

`LOCK TABLES “table_name” [ READ | WRITE ]` 명령으로 명시적으로 테이블에 대한 락 획득 가능

`UNLOCK TABLES` 명령어로 락 해제 가능

묵시적인 테이블 락은 MyISAM, MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 걸린다.

InnoDB에서도 테이블 락이 설정되기 하지만 데이터 변경 쿼리의 경우 무시되고 스키마를 변경하는 쿼리에서 영향을 준다.

### 네임드 락

`GET_LOCK()` 함수를 이용하여 임의의 String에 대해 락을 설정하는 방법

특정 테이블이나 레코드 또는 auto_increament와 같은 데이터베이스 객체에 락이 걸리는 방식이 아니다.

**사용자가 지정한 String에 대해 락을 걸고 반납하는 방식**

많은 레코드에 대해 복잡한 요건으로 레코드를 변경하는 트랜잭션에서 유용하게 사용 가능

네임드 락을 기반으로 분산 락 설계 가능

MySQL 8.0부터 네임드 락을 중첩해서 사용할 수 있고 현재 세션에서 획득한 네임드 락을 한 번에 해제할 수 있다. `select RELEASE_ALL_LOCKS()` 

### 메타데이터 락

데이터베이스 객체 (테이블 ,뷰 등)의 이름이나 구조를 변경하는 경우 사용하는 락

`RENAME TABLE tab_a TO tab_b` 와 같이 테이블의 이름을 변경하는 쿼리를 던질 때 **묵시적으로 락을 얻고 해제한다.**

메타데이터 락은 절대로 명시적으로 획득하거나 해제할 수 없다.

## InnoDB 스토리지 엔진 잠금

---

InnoDB 스토리지 엔진은 MySQL에서 제공하는 락과 별개로 자체적으로 **레코드 기반의 락**을 제공한다.

레코드 기반 락으로 더 **뛰어난 동시성 처리**가 가능하다.

과거 버전에서는 InnoDB의 락 정보를 확인하기 어려웠지만 현재에는 information_schema 데이터베이스에 존재하는 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS 테이블을 조인하여 확인할 수 있다.

그리고 Performance Schema를 활용하여 InnoDB 스토리지 엔진의 내부 잠금(세마포어)에 대한 모니터링 방법도 추가되었다.

### InnoDB 스토리지 엔진의 Lock

InnoDB 스토리지 엔진은 레코드 기반 락 기능을 제공한다.

→ **작은 공간으로 락이 관리되는 장점이 있다.**

레코드와 레코드 사이의 간격을 잠그는 갭 락도 존재한다.

### 레코드 락

레코드 자체만을 잠그는 것

다른 DBMS와의 차이는 **InnoDB의 레코드 락은 레코드 자체를 잠그는 것이 아닌 인덱스의 레코드를 잠근다는 것이다.**

인덱스를 걸지 않은 테이블이더라도 내부적으로 자동 생성되는 **클러스터 인덱스**를 활용하여 락을 설정한다.

InnoDB에서 대부분 **보조 인덱스를 이용한 변경 작업은 Next Key Lock, Gap Lock**을 사용하고 **PK나 Unique 인덱스에 의한 변경 작업은 Gap에 대해서는 잠그지 않고 레코드 자체**에만 락을 건다.

### Gap Lock

**레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것**을 의미한다.

레코드와 레코드 사이의 간격에 **새로운 레코드가 생성되는 것을 제어한다.**

Next Key Lock의 일부로 자주 사용된다.

### Next Key Lock

레코드 락과 갭 락을 합쳐놓은 형태의 잠금

갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 **동일한 결과를 보장**하는 것이 주 목적

넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다.

→ 가능하면 **로그 포맷을 ROW로 바꾸는 것이 좋고**, 현재 MySQL 8.0 이상의 버전은 ROW 포맷이 기본 설정이다.

### 자동 증가 락

auto_increment의 동시성을 맞추기 위한 lock

여러 데이터가 동시에 insert 될 때 서로 중복되지 않는 일련번호를 주기 위해 사용되는 락이다.

트랜잭션과 관계없이 insert, replace 문장에서 auto_increment 값을 가져오는 순간에 락이 걸리고 해제된다.

auto_increment 락은 테이블에 하나씩 존재

자동 증가 락도 명시적으로 얻고 해제하는 방법은 없다. 묵시적으로 일어남

### 인덱스와 잠금

InnoDB의 잠금은 레코드를 잠그는 것이 아닌 인덱스를 잠그는 방식이다.

**변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 건다.**

→ 내가 변경하고자 하는 데이터를 찾기 위해 접근한 row에 모두 락이 걸린다.

만약에 테이블에 인덱스가 걸려있지 않다면 풀 스캔하여 테이블 전체에 락이 걸리는 상황이 발생할 수도 있다.

**InnoDB의 인덱스 설계가 정말 중요하다!!**

### 레코드 수준의 잠금 확인 및 해제

InnoDB 스토리지 엔진을 사용하는 테이블의 레코드 수준 잠금은 테이블 수준의 잠금보다는 복잡하다.

MySQL 5.1 버전부터 레코드 잠금과 잠금 대기에 대한 조회 기능이 추가되었다.

→ 쿼리 하나만 실행하면 잠금과 잠금 대기 정보를 바로 확인할 수 있다.

MySQL 8.0부터 `performance_schema`의 `data_locks`와 `data_lock_waits` 테이블로 락을 확인할 수 있다.

> Real MySQL8.0 173p ~ 175p 레코드 락 확인 예제 직접 살펴보기
> 

## MySQL의 격리 수준

---

트랜잭션 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.

|  | Dirty Read  | Non-Repeatable Read | Phantom Read |
| --- | --- | --- | --- |
| Read Uncommitted | 발생 | 발생 | 발생 |
| Read Committed | 없음 | 발생 | 발생 |
| Repeatable Read | 없음 | 없음 | 발생 (InnoDB는 없음) |
| Serializable | 없음 | 없음 | 없음 |

격리 수준이 높아질 수록 동시 처리 성능이 떨어지는게 일반적이다. 참고로 MySQL에서는 Serializable 수준이 아니라면 각 수준에 따른 성능 차이가 크지 않다.

Oracle은 Read Committed를 주로 사용하고, MySQL은 Repeatable Read를 주로 사용한다.

### Read Uncommitted

각 트랜잭션의 변경 사항이 Commit, Rollback 여부에 관계없이 다른 트랜잭션에서 확인할 수 있다.

<img width="397" alt="스크린샷 2023-10-09 오후 10 15 26" src="https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/8663a157-7de1-4aed-8995-de1631bb9e53">

다른 세션에서 트랜잭션을 열고 해당 테이블의 값을 확인해보면

<img width="403" alt="스크린샷 2023-10-09 오후 10 18 06" src="https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/64791f32-c951-4ef9-bdbc-485790b1aba1">


<img width="233" alt="스크린샷 2023-10-09 오후 10 18 21" src="https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/2e3710dd-ffcc-4181-9c18-1bfe78c475e5">
  
이렇게 커밋되지 않은 값을 읽음을 알 수 있다.

Read Uncommitted의 문제는 해당 데이터가 롤백 되더라도 이미 select한 세션에서는 해당 데이터가 정상적이라고 판단한다는 것이다.

**이렇게 트랜잭션이 완료되지 않았음에도 다른 트랜잭션에서 해당 작업의 변경사항을 보는 현상을 Dirty Read라고 한다.**

### Read Committed

온라인 서비스에서 가장 많이 선택되는 격리 수준 중 하나

Commit이 완료된 트랜잭션만 다른 트랜잭션에서 조회가 가능하다.

아래의 쿼리를 하나의 세션에서 실행한다고 해보자

<img width="418" alt="스크린샷 2023-10-09 오후 10 28 37" src="https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/6bcbb23c-32ca-42a2-b7cc-0973c4b4d507">

테이블에는 변경된 2000의 값이 저장되고 **이전 값인 3000은 언두 영역으로 백업이 된다.**

다른 세션에서 확인해보면

<img width="274" alt="스크린샷 2023-10-09 오후 10 29 07" src="https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/01a29f4d-47c2-40be-a703-d47e579db401">

커밋되지 않은 데이터이기 때문에 3000으로 뜨는 것을 알 수 있다.

→ **언두 영역에서 백업된 데이터를 가져온다.**

값을 변경한 세션이 커밋하게 되면 언두 영역의 레코드가 아닌 새롭게 변경된 데이터를 참조할 수 있게 된다.

**Read Committed에서는 Non-Repeatable Read가 발생한다.**

위의 상황에서 데이터를 변경한 세션이 commit을 하고 다시 두 번째 세션이 데이터를 조회하면 처음 조회한 데이터와 다른 상황이 발생한다.

<img width="250" alt="스크린샷 2023-10-09 오후 10 39 24" src="https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/ddb40dbf-c8c4-43ad-8c1e-e88cd7c7a885">

**하나의 사용자가 같은 트랜잭션에서 똑같은 select 쿼리를 실행했을 때 다른 결과가 나오게 된다.**

→ Repeatable Read 정합성에 어긋난다.

### Repeatable Read

MySQL의 **InnoDB 엔진이 기본으로 사용하는 격리 수준이다.**

Binary log를 가진 MySQL 서버에서는 해당 격리 수준을 최소로 사용해야 한다.

이 격리 수준에서는 Non-Repeatable read가 발생하지 않는다.

**InnoDB 엔진이 롤백될 상황을 대비하여 변경 전 레코드를 undo 공간에 백업하고 실제 레코드 값을 변경해준다.**

→ 이러한 변경 방식을 **MVCC**라고 한다. (4.2.3절 MVCC 부분 참고)

**언두 영역에 백업된 데이터를 바탕으로 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장해준다.**

**Repeatable Read에서는 MVCC를 보장하기 위해 실쟁 중인 트랜잭션 중 가장 오래된 트랜잭션 번호보다 앞선 트랜잭션 번호를 가지는 언두 영역의 데이터를 삭제할 수 없다.**

다만 Repeatable Read는 **Phantom Read가 발생한다.**

**다른 트랜잭션에서 수행한 변경 작업에 의해 레코드 집합의 결과가 달라지는 현상을 Phantom Read라고 한다.**

![Untitled](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/777b7d18-4910-4db4-83ff-c372e43db319)

**InnoDB 스토리지 엔진에서는 갭 락과 넥스트 키 락으로 인해 Phantom Read가 발생하지 않는다.**

### Serializable

가장 엄격한 격리 수준

모든 트랜잭션이 순차적으로 실행되어야 한다.

동시처리 성능이 매우 떨어진다.

## 참고 자료

Real MySQL 8.0 1권 Chapter 5
