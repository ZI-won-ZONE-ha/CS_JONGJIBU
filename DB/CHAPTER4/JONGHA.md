# MySQL 전체 구조

- 대부분의 프로그래밍 언어의 접근 방법 지원
- 드라이버를 이용하여 모든 언어로 MySQL 서버에서 쿼리 사용가능

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/87687210/3021ebd8-120e-460f-94f7-3fc111aeb144)

# MySQL 서버

MySQL 엔진과 스토리지 엔진으로 나눌 수 있다. 

## MySQL 엔진

- 클라이언트 접속 및 쿼리 요청 처리하는 `커넥션 핸들러`와 `SQL 파서` 및 `전 처리기`,
- 쿼리의 최적화된 실행을 위한 `옵티마이저`
- mySQL  표준 SQL 문법(ANSI) 을 지원하기 떄문에, 타 DBMS 와 호환 가능
- MYSQL 엔진은 한 대

## 스토리지 엔진

- 스토리지 엔진 여러 개
- 성능 향상을 위해 키 캐시 (MyISAM) 또는 **InnoDB 버퍼 풀(InnoDB) 기능** 내장

## 핸들러 API

- 핸들러 요청 : MySQL 엔진의 `쿼리 실행기`에서 스토리지 엔진에 쓰기 또는 읽기를 요청, 이때 사용되는 API를 핸들러 API 라고 한다.
- SHOW GLOBAL STATUS LIKE ‘Handler%’

## MYSQL 스레딩 구조

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/87687210/3f169e6a-15a9-4d17-a6f7-95503400a433)

- 프로세스 기반이 아닌 스레드 기반 (fore, back)
- 백그라운드 스레드 개수는 MySQL 서버의 설정에 따라 달라짐
- 동일 스레드 2개 이상 씩 → 병렬 처리

### ForeGround thread

- MySQL 서버에 접속된 클라이언트 수만큼 존재
- 클라이너트 사용자가 요청하는 쿼리 문장 처리 후 커넥션 종료하면 스레드는 다시 스레드 캐쉬로 되돌아 간다.
- 스레드 캐시에 유지할 수 있는 최대 스레드 개수가 정해져 있다.
- 데이터 가져오는 방법
    - MySQL의 **데이터 버퍼**나 **캐시**로, 없을 때 직접 **디스크**의 데이터나 **인덱스** 파일로 부터 읽어옴. (우리가 생각하는 캐쉬 부분과 유사함.)
    - InnoDB는 버퍼, 캐시까지 foreground가 처리하고 , 나머지 버퍼로부터 디스크는 백그라운드가 처리
    - 사용자 스레드 = 포그라운드 스레드  (사용자 요청을 처리하고 DBMS앞단에서 사용자와 통신)

### BackGround Thread

- 가장 중요한 것 `로그 스레드`와 버퍼의 데이터를 디스크로 내려쓰는 작업 처리하는 `쓰기 쓰레드`
- 데이터 지연 유무
    - 쓰기 쓰레드는 지연(버퍼링) 처리 가능.  But 읽기 쓰레드는 불가능.
    - InnoDB에서는 쓰기 작업을 버퍼링해서 처리. 즉 `insert`, `update`, `delete` 쿼리 시, 데이터 디스크로 옮겨질 때까지 기다리지 않아도 된다.

---

## 메모리 할당 및 사용 구조

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/87687210/c3d64307-cb00-4651-b68b-3a5d6befebea)

- MySQL 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분된다.

<aside>
💡 MySQL 의 메모리는 어디에 저장이 되나요? 운영체제의 Physical 메모리 공간이라고 생각하면 되나요? → 상황에 따라 다르다 바로 할당할 수 있고, virtual → 나중에 할당할 수 있다.

</aside>

### 글로벌 메모리

- 클라이언트 수와 무관하게 하나만 할당된다.
- 모든 메모리 공간 운영체제로 부터 할당된다.
- 테이블 캐시, InnoDB 버퍼 풀, InnoDB 어뎁티브 해시 인덱스, InnoDB 라두 로그 버퍼

### 로컬 메모리

- 세션 메모리 영역 = 로컬 메모리 영역 =  클라이언트 메모리 영역
- 클라이언트 요청을 처리하기 위해, 스레드 하나씩 할당해서 클라이언트 메모리 영역이라고 부름.
- 세션 : 클라이언트와 MySQL 서버와의 커넥션
- 절대 공유되지 않는다.
- **쿼리 용도 별로 필요할 때만 공간이 할당되고, 필요하지 않으면 할당조차 안된다.**
- 커넥션 버퍼, 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼

## 플러그인 스토리지 엔진 모델

- 플러그인 모델
- 핸들러 : 어떤 기능을 호출하기 위해 사용하는 운전대 같은 역할의 객체
- **`MYSQL 엔진`**이  `**스토리지 엔진**` 조정하기 위해 `**핸들러**`를 쓴다.
- **하나의 쿼리 작업은 하위 여러 작업으로 나뉘는데, 각 하위작업이 MYSQL 에서 처리되는 지 아니면 스토리지 엔진 영역에서 처리되는지 구분하는 것이 가장 중요하다.**
- 스토리지 엔진 뿐만 아니라 다양한 기능 플러그인 형태로 지원.

## 컴포넌트

- 플러그인 아키텍쳐의 단점을 대체하기 위해 컴포넌트 도입
    - 플러그인은 오직 MySQL 서버와 인터페이스 할 수 있고, 플러그인끼리는 통신 X
    - 플러그인은 MySQL 서버 변수 함수 직접 호출 → 안전하지 않다.
    - 플러그인은 상호 의존 관계를 설정 X → 초기화 어려움.

## 쿼리 실행 구조

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/87687210/78757399-5f8c-43b9-a6aa-50084586e7ce)

### 쿼리 파서

- 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어낸다.
- 쿼리 문장의 기본 문법 오류가 발견, 사용자에게 오류 전달

### 전처리기

- 파서 트리를 기반으로 쿼리 문장 구조적 문제 확인
- 각 토큰은 테이블 이름이나 칼럼 이름, 또는 내장 함수같은 객체 매핑 → 해당 객체의 존재 여부, 객체의 접근 권한 확인

### 옵티마이저

- 쿼리 문장을 저렴한 비용으로 처리 결정 → DBMS의 두뇌
- **진짜 젤 중요함. 더 나은 선택을 위해 옵티마이저가 어떻게 하는지**

~~컴파일러가 코드 파싱하는 과정하고 비슷한거 같다~~

### 실행 엔진

- 옵티마이저 : 회사의 경영진, 실행 엔진 : 중간 관리자, 핸들러 : 각 업무의 실무자로 비유
- 만들어진 계획 대로 각 핸들러에게 요청하여 받은 결과를 또 다른 핸들러 요청의 입력으로 연결

### 핸들러(스토리지 엔진)

- MySQL 서버 가장 밑단.
- MYSQL의 실행엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어오는 역할

### 복제

- 다른 장에서 다룬다..? 중요함

### 쿼리 캐시

- SQL 실행결과를 메모리에 캐쉬 → 테이블을 읽지않고 즉시 결과 반환한다. → 성능 향상
- 테이블의 데이터 변경하며, 변경된 테이블 관련된 것 캐쉬에서 모두 삭제 → 성능 저하
- 따라서 이는 삭제됨.

## 스레드 풀

- 엔터프라이즈 에디션은 스레드 풀 제공 반면 커뮤니티 에디션은 제공하지 않는다.
- 커뮤니티 버전에서는 플러그인 형태로 Percona Server를 쓰면 된다.
- **MySQL 서버의 CPU 가 제한된 개수의 스레드 처리에만 집중 → 서버의 자원 소모 줄임.**
- 스케줄링 과정에서 CPU 시간을 제대로 확보하지 못하는 경우에는 쿼리 처리가 더 느려질 수 있다.
- CPU 제한된 스레드로 적절히 처리하도록 유도한다면 ,  Processor Affinity 도 높이고 **운영체제 입장에서 불필요한 컨텍스트 스위치 줄여 오버헤드 낮춘다. (너무 많으면은 컨텍스트 스위치 많이 일어남)**
    - Processor Affinity?
        
        프로세스를 새로 만들 때, affinity 지정해서 특정 프로세서 위에서 돌게 해달라고 요청 가능
        
        ![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/87687210/89d9e997-83d0-4a54-b89a-7d1b86ad54dd)
        
- 모든 스레드가 일하고 있다면 새로운 Worker Thread 추가 Or 대기를 판단
    - 관련 지표
        - thread_pool_max_threads (최대 thread의 개수)
        - thread_pool_stall_limit : 새로운 쿼리 요청이 들어오면, 스레드 풀은 주어신 시간 동안 기다려야 새로 들어온 요청 처리 가능

## 트랜잭션 지원 메타데이터

- 예전에는 파일 기반의 메타 데이터  → 트랜젝션이 지원되지 않아, 테이블의 생성 또는 변경 도중 MySQL 서버 비정상 종료 되면, 일관되지 않은 상태로 남아있음.
- 지금은 InnoDB table 로 관리 → 트랜젝션 기반  → All or Nothing
    - 시스템 테이블 : MySQL 서버 작동하는데 기본적으로 필요한 테이블
    - 데이터 딕셔너리 정보
- 다른 스토리지 엔진은 SDI 파일을 사용.

# InnoDB Storage 엔진 아키텍쳐

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/87687210/7f3f5990-5d09-468f-a9e9-4c70e67c212c)

## [프라이머리 키에 의한 클러스터링](https://www.notion.so/8-4d64772b4aa1485293b2c28eb28a4f56?pvs=21)

- [InnoDB는  프라이머리 키 기준으로 클러스터링, 즉 키 값 순서대로 디스크에 저장](https://www.notion.so/8-4d64772b4aa1485293b2c28eb28a4f56?pvs=21)
- 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용
- 프라이 머리 키를 이용한 레인지 스캔이 빨리 처리.
- [InnoDB와 달리, MyISAM은 클러스터링 키 지원 X](https://www.notion.so/8-4d64772b4aa1485293b2c28eb28a4f56?pvs=21)

## 외래 키 지원

- InnoDB에서만 지원함. (MyISAM, MEMORY 지원 X)
- **데드락 주의 : 변경 시, 잠금이 여러 테이블에 전파되므로 → 단점 : 실제 서비스에서 안 쓰일 수도 있다.**
- **생성 시, 부모 테이블, 자식 테이블 모두 해당 칼럼에 인덱스 생성 필요.**
- 수동으로 데이터 적재, 스키마 변경 관리 실패할 수 있다.

## MVCC

- Multi Version Concurrency Control
- 레코드 레벨의 트랜젝션을 지원하는 DBMS 가 제공  → **InnoDB에서는 언두로그를 통해 구현**
- 멀티 버전 : 하나의 레코드에 여러개의 버전이 동시에 관리
- 격리 수준에 따라, 쿼리의 결과가 달라진다.
- **update**: READ_COMMITED, REPEATABLE READ, SERIALIZABLE : 커밋 안되었기 떄문에, InnoDB 버퍼 풀이나, 데이터 파일에 있는 내용 대신, 언두영역 데이터 반환.
- **delete** : 언두 영역은 필요로 하는 트랜젝션이 없을 때 삭제 됨.
- **rolllback**: InnoDB 의 언두영역에 있는 백업 데이터를 InnoDB 버퍼 풀로 복구, 언두 영역 내용 삭제
- 트랜젝션이 길어지면, 버전 오랫동안 관리해야 함. → 언두 영역 저장 공간 꽉참.

## Non-Locking Consistent Read

- MVCC를 이용하여, 잠금을 걸지 않고 읽기 작업
- SERIALIZABLE 이 아닐 때, 순수한 읽기 작업은 다른 트랜젝션의 변경작업과 관계없이 가능.
- 일관된 읽기를 위해 언두로그를 삭제하지 못함. → 트랜젝션 최소화!

## 자동 데드락 감지

- 데드락 스레드는 잠금 목록을 검사하기 위해, 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트에 새로운 잠금을 걸고 찾음. (Wait-for-list) → 푸는 것 까지
- 동시 처리 스레드 많거나, 트랜젝션이 가진 잠금의 개수가 많아지면, 데드락 감지 스레드가 느려진다. → 서비스 커리 처리 중인 스레드 작업 못하고 대기하면서 서비스에 악영향 → CPU 자원을 소모할 수 있다.
    
   ![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/87687210/3a3df915-1cba-4b38-b4e4-f53d04c50baa)
    
- → innoDB_deadlock_detect 시스템 변수 제공

## 자동화된 장애 복구

- 장애 복구 메커니즘.
- InnoDB 데이터 파일은 MySQL 서버가 시작될 떄, 자동 복구 수행하고 복구 할 수 없다면, MYSQL 서버 종료
- innodb_force_recovery 옵션에 따라 장애상황과 해결 방법이 다르다. 이 옵션에 따라 재시작해본다.
- 만약 MySQL 서버 시작 안된다면, 백업을 이용해 다시 구축.
- 바이너리로그가 있다면, 풀 백업과 바이너리 로그로 복구할 수 있다.

## InnoDB 버퍼 풀

- InnoDB에서 가장 핵심적인 부분으로, 디스크의 데이터 파일, 인덱스 정보 메모리에 캐시 공간
- 버퍼 풀은 성능 향상을 위해 데이터 캐시 와 쓰기 버퍼링이 존재한다.
- 쓰기 지연 → 일괄 처리
- INSERT, UPDATE, DELETE처럼 데이터를 변경하는 쿼리는 랜덤한 디스크 작업을 발생시키게 된다 → 버퍼 풀이 데이터를 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있음.

### 버퍼 풀의 크기 설정

- MySQL 서버 내에서 메모리 쓰는 경우 거의 없지만 레코드 버퍼(클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때, 버퍼로 사용하는 공간) 에서 메모리 사용하는 경우 있다.
- ySQL 5.7 버전부터는 InnoDB 버퍼 풀의 크기를 동적으로 조절할 수 있게 개선됐다. 때문에 가능하면 InnoDB 버퍼 풀의 크기를 적절히 작은 값으로 설정해서 조금씩 상황을 봐 가면서 증가시키는 방법이 최적이다.
- 운영체제의 전체 메모리 공간이 8GB 미만이라면 50% 정도만 InnoDB 버퍼 풀로 설정하고 나머지 메모리 공간은 MySQL 서버와 운영체제, 그리고 다른 프로그램이 사용할 수 있는 공간으로 확보해주는 것이 좋다.
- 내부적으로 128MB 청크 단위로 쪼개어 관리 → 버퍼 풀의 크기 줄이거나 늘리는 단위 크기

### 버퍼 풀의 구조

- 버퍼 풀을 페이지 크기의 조각으로 쪼개어 저장하는데, 이를 관리하기 위해, 자료구조가 존재
    - LRU 리스트
        - 자주 사용되는 데이터 페이지 → MRU 영역
        - 사용안되면 LRU 에서 밀려나 InnoDB 버퍼 풀에서 제거 됨.
    - 플러시 리스트
        - 더티 페이지(디스크에 동기화 안된 페이지) 목록 관리
        - 특정 시점이 되면, 디스크에 기록 되어야 함.
        - 데이터 변경되면 InnoDB는 변경내용을 리두 로그에 기록 → 버퍼 풀의 데이터 페이지에도 변경 내용 반영
    - 프리 리스트
        - 실제 사용자 데이터로 채워지지 않은 비어있는 페이지들의 목록

### 버퍼 풀과 리두 로그 (? 이해하지 못함)

- 버퍼 풀은 메모리 설정 늘어날 수록 성능이 빨라진다.
- 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지(Clean Page)와 함께 INSERT, UPDATE, DELETE 명령으로 변경된 데이터를 가진 더티 페이지(Dirty Page)도 가지고 있다.
- 리그 로그 : InnoDB 스토리지 엔진은 전체 리두 로그 파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간을 구분해서 관리 → 이때의 재사용 불가능한 공간

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/87687210/4d92fdee-c5a9-4b8e-b099-4702b1383404)

### 버퍼 풀 플러시(Buffer Pool Flush)

- InnoDB 스토리지 엔진은 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 아래와 같이 두 개의 플러시 기능을 백그라운드로 실행한다
- 플러시 리스트 플러시
    - 버퍼 풀에 더티 페이지 많을 수록 디스크 쓰기 폭발 현상 증가
    - 디스크 읽고 쓰기 : 백그라운드 스레드가 수행하는 디스크 작업 → 대부분 버퍼 풀의 더티 페이지 쓰기
    - 어댑 티브 플러시 알고리즘 : 리구 로그 증가속도 분석하여 적절한 더티 페이지 버퍼풀 에 유지되도록 디스크 쓰기 실행
- LRU 리스트 플러시
    - 사용빈도 낮은 데이터 페이지 플러시
    - 이때, 더티 페이지는 디스크에 동기화, 클린 페이지는 즉시 프리 리스트로 옮긴다.

### 버퍼 풀 상태 백업 및 복구

- 워밍 업 : 디스크의 데이터가 버퍼 풀에 적재되어 있는 상태 → 워밍업이 잘되면, 몇십배의 쿼리 처리 속도를 보인다.
- 5.6 버전 부터 버퍼 풀 덤프 및 적재 기능 도입 → 버퍼 풀의 상태 백업 가능, 백업은 빠름, 복구는 느림
- InnoDB는 자동 백업 복구 기능 제공

### 버퍼 풀의 적재 내용 확인

- 버퍼 풀이 큰 경우, 조회가 큰 부하 일으키면서 서비스 쿼리 느려져 상태 확인 불가능했다. → infomation_schema 에 테이블 추가로 해결

### Double Write Buffer

- 리그로그는 페이지의 변경된 내용만을 기록한다.
- 만약 디스크 파일로 더티 페이지를 플러시할 때 일부만 기록되면, 복구가 불가능한 점을 → Double Write Buffer로 해결
- 더티 페이지를 묶어 Double Write 버퍼로 기록하고, 각 더티 페이지를 데이터 파일에 랜덤 쓰기 한다.
    - 만약 일부만 기록되면, Double Write 버퍼와 비교하여, 해당 내용을 데이터 파일의 페이지로 복사.
- HDD 에서는 부담이 되지 않는데, SSD에서는 부담이 된다.

그다음은 gg 못해 먹겠슴 ㅃㅃ 

to be continued….
