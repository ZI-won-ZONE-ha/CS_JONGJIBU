# 8장. URL 단축기 설계

---

## 문제 이해 및 설계 범위 확정

---

URL 단축기의 요구사항은 다음과 같다.

- URL 단축: 주어진 긴 URL을 훨씬 짧게 줄인다.
- URL 리다이렉션: 축약된 URL로 요청이 오면 원래 URL로 안내
- 높은 가용성, 규모 확장성, 장애 감내 요구

### 개략적 추정

- 쓰기 연산: 매일 1억 개 URL 생성
- 초당 쓰기 연산: 1억 / 24 / 3600 = **1160**
- 읽기 연산: 읽기 연산과 쓰기 연산의 비율이 10:1 일 때 읽기 연산은 **11600**
- 서비스를 10년 운영한다면 1억 * 365 * 10 = 3650억 개의 레코드를 보관해야 된다.
- 축약전 URL의 평균 길이는 100이라고 가정
- 10년 동안 필요한 저장 용량은 3650억 * 100바이트 = 36.5TB

## 개략적 설계안 제시 및 동의 구하기

---

### API 엔드포인트

클라이언트는 서버가 제공하는 API 엔드포인트를 통해 서버와 통신

URL 단축기의 경우 2개의 엔드포인트가 기본적으로 필요하다.

- URL 단축용 엔드포인트
    - 단축할 URL을 body에 담아 POST 요청을 보내야 한다.
    - 반환 값: 단축된 URL
- URL 리다이렉션용 엔드포인트
    - 단축 URL에 대해 HTTP 요청이 오면 원래 URL로 보내주는 용도의 엔드포인트
    - GET 요청

### URL 리다이렉션

단축 URL을 브라우저에 입력하면 Status Code는 301이 나오고 Location 헤더는 원래의 URL을 가리키게 된다.

- 301 응답
    - URL에 대한 HTTP 요청의 처리 책임이 영구적으로 Location 헤더에 반환된 URL로 이전되었다는 응답
    - 영구적으로 이전되기 때문에 브라우저는 원래의 URL을 캐시하게 된다.
    - → 단축 URL로 요청을 보내면 캐싱된 원래 URL로 요청을 보낸다.
    - 서버 부하를 줄이는 것이 중요할 때 사용하면 좋다.
- 302 응답
    - 일시적으로 Location 헤더가 지정하는 URL에 의해 처리되어야 한다는 응답
    - 클라이언트의 요청이 언제나 단축 URL를 통해서 이동하게 된다.
    - 트래픽 분석이 중요할 때 사용하면 좋다.

리다이렉션을 구현하는 가장 좋은 방법은 해시 테이블을 사용하는 것이다.

### URL 단축

URL 단축 시 중요한 것은 단축 URL을 원래의 URL로 매핑하는 것이다. (해시 함수 이용)

해시 함수는 다음과 같은 요구사항을 만족해야 한다.

- 입력으로 주어지는 URL이 다른 값이면 해시 값도 달라야 한다.
- 계산된 해시 값은 원래 입력으로 주어졌던 URL로 복원될 수 있어야 한다.

## 상세 설계

---

### 데이터 모델

해시 테이블은 실제 시스템이 쓰기에는 곤란하다.

→ 메모리는 유한하고 비싸기 때문에

**<단축 URL, 원래 URL> 순서 쌍을 RDB에 저장하는게 더 나은 방법이다.**

### 해시 함수

원래 URL → 단축 URL로 변환하는데 쓰이는 함수이다.

- 해시 값 길이

hashValue를 숫자, 알파벳으로 제한할 때 가능한 문자의 개수는 62개

→ hashValue의 길이를 정하기 위해서는 62^n ≥ 3650억을 만족하는 n 값을 찾아야 한다.

n = 7인 경우 이를 만족한다. → hashValue의 길이를 7로 설정 가능함!

- 해시 충돌 해소

해시 함수를 사용하는 가장 쉬운 방법은 잘 알려진 해시 함수를 적용하는 것이다.

다만 해시 함수를 적용한다면 원하는 hashValue의 길이를 가질 수 없어 특정 부분을 잘라야 한다.

→ 만약 특정 길이만큼 자르게 된다면 해시 충돌이 발생할 수 있다.

→ 해시 충돌이 발생할 경우 원래의 url에 특정 문자열을 붙이는 방법으로 해시 충돌 방어 가능

그러나 이러한 방법은 단축 url을 생성할 때 Database에 해당 해시 값이 존재하는지 계속 확인해줘야 한다.

→ 오버헤드가 발생함 (**볼륨 필터**를 통해 어느정도 성능 문제 해결 가능)

- base-62 변환

**진법 변환을 활용하는 방법으로 흔히 사용되는 접근법이다.**

가능한 문자의 개수가 62개이므로 base-62 변환이 가능하다.

- 두 접근법 비교
    - 해시 후 충돌 해소 전략
        - 단축 URL 길이가 고정됨
        - 유일성이 보장되는 ID 생성기 없어도 됨
        - 충돌이 발생할 가능성 존재
        - 다음에 사용할 URL을 찾는 방식으로 ID를 통해 URL를 만들어내지 않음
    - base-62
        - 단축 URL 길이가 ID에 따라 가변적이다.
        - 유일성 보장 ID 생성기가 필요하다.
        - 충돌이 발생하지 않음
        - ID를 기반으로 해시값을 만들기 때문에 다음 해시값 예측 가능 → 보안 이슈 발생 가능

### URL 단축기 상세 설계

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/446b25e9-92ad-42f9-adbb-47032a947aef)

1. 입력으로 원래의 URL을 받는다.
2. 데이터베이스에 해당 URL이 존재하는지 검사
3. 데이터베이스에 존재한다면 단축 URL을 리턴
4. 데이터베이스에 없다면 유일한 ID 값을 할당하고 이를 Database의 PK로 활용
5. 62진법 변환을 활용하여 ID를 단축 URL로 변환
6. Database에 ID, 기존 URL, 단축 URL을 저장하고 단축 URL을 사용자에게 반환한다.

**ID는 전역적으로 유일한 ID로 생성되어야 한다!**

### URL 리다이렉션 설계

읽기를 훨씬 많이하는 부분이니 **<단축 URL, 원래 URL>을 캐싱해두어 성능을 높일 수 있다.**

1. 사용자가 단축 URL로 요청을 보냄
2. 로드밸런서가 요청을 웹 서버에 전달
3. 이미 캐시에 단축 URL이 존재한다면 캐시에서 원래 URL 꺼내서 반환
4. 캐시에 단축 URL이 없다면 Database에서 꺼낸다.
5. 꺼낸 원래 URL을 캐시에 저장하고 사용자에게 반환

## 마무리

---

추가적으로 고민할 부분

- 처리율 제한 장치: 엄청난 양의 URL 생성 요청이 들어올 경우 시스템이 무력화될 수 있다.
- 웹 서버 스케일 아웃: Stateless 계층으로 자유로운 스케일 아웃 가능
- 데이터베이스 규모 확장: 데이터베이스 다중화 및 샤딩을 통한 규모 확장 가능
- 데이터 분석 솔루션: URL 단축기에 분석 솔루션을 통합해 링크에 대한 정보를 분석할 수 있다.
- 가용성, 데이터 일관성, 안정성: 대규모 시스템이 성공적으로 운영하기 위해 필요한 속성들
