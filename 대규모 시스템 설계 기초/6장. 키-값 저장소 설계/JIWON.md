# 6장. 키-값 저장소 설계

---

키 값 저장소는 비 관계형 데이터베이스이다.

데이터를 저장하기 위해 Key(고유 식별자)가 필요하다.

키는 짧을수록 좋다. → 성능상의 이유

대표적인 키-값 저장소: 아마존 다이나모, memcached, Redis 등

## 문제 이해 및 설계 범위 확정

---

읽기, 쓰기, 메모리 사용량 사이의 균형과 데이터의 일관성과 가용성 사이의 결정이 필요하다.

아래의 특성을 가지는 키-값 저장소를 설계해보자

- 키-값 쌍의 크기는 10KB 이하이다.
- 큰 데이터를 저장할 수 있다.
- 높은 가용성을 제공해야 한다.
- 높은 규모 확장성을 제공해야 한다. → auto scale up, down 필요
- 데이터 일관성 수준은 조정이 가능해야 한다.
- 응답 지연시간이 짧아야 한다.

## 단일 서버 키-값 저장소

---

가장 직관적인 방법: 키-값 쌍 전부를 메모리 내에 해시 테이블로 저장

→ 빠른 속도를 보장하지만 모든 데이터를 메모리 안에 두는 것이 불가능할 수 있음

이를 위한 개선책

- 데이터 압축
- 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장

이런 개선책을 사용하더라도 결국엔 부족한 타이밍이 온다. → 분산 저장소가 필요해진다.

## 분산 키-값 저장소

---

분산 키-값 저장소는 분산 해시 테이블이라고도 부른다.

분산 시스템을 설계할 때는 CAP 정리를 이해하고 있어야 한다.

### CAP

CAP 정리는 Consistency(일관성), Availability(가용성), Partition Tolerance(파티션 감내)라는 세 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리이다.

- 데이터 일관성: 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접근했냐와 관계없이 언제나 같은 데이터를 보아야 한다.
- 가용성: 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.
- 파티션 감내: 파티션은 두 노드 사이에 통신 장애가 발생했음을 의미한다. 파티션 감내는 네트워크에 파티션이 생기더라도 시스템은 계속 동작해야 함을 뜻한다.

**이 중에 2가지를 보장하면 하나는 포기해야 되는 것이 CAP 정리이다.**

- CP 시스템: 일관성과 파티션 감내를 지원하는 키-값 저장소로 가용성을 희생한다.
- AP 시스템: 가용성과 파티션 감내를 지원하는 키-값 저장소로 일관성을 희생한다.
- CA 시스템: 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야 한다. → 실세계에 존재하지 않는 시스템

### 이상적 상태

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/df7dcbc1-5f9b-4c84-8725-2bd696b70aad)

이상적인 환경이라면 네트워크 파티션이 발생하지 않는다.

→ n1에 기록되는 데이터가 n2, n3에 같이 동기화된다.

→ 데이터 일관성, 가용성 모두 만족하는 상황

### 실세계의 분산 시스템

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/acfd7718-77df-41aa-92c6-eefa6cf001b2)

실세계의 분산 시스템은 파티션 문제를 피할 수 없다.

**위 그림과 같은 상황이라면 n1, n2는 n3에서 받은 데이터가 동기화되지 않고, n3는 n1, n2에서 받은 데이터가 동기화되지 않은 상황이 발생한다.**

그러면 두 가지 상황 중 하나를 선택해야 한다.

- CP 시스템
    - 일관성을 위해 n1과 n2에 쓰기 연산을 중지시킨다.
    - 대신에 쓰기 연산을 하지 못 하므로 가용성이 깨지게 된다.
    - 은행권 시스템은 일관성이 중요하여 이런 선택을 많이 함
- AP 시스템
    - 가용성을 위해 n1과 n2에 쓰기 연산을 중지시키지 않음
    - 대신에 동기화되지 않은 데이터를 읽을 수 있다.

현재 개발하는 요구사항에 맞춰 두 가지 상황 중 하나를 선택해야 한다.

### 시스템 컴포넌트

키-값 저장소 구현에 사용될 핵심 컴포넌트 및 기술들

- 데이터 파티션
    - 전체 데이터를 한 대의 서버에 다 넣는 것은 불가능 → 데이터를 작은 파티션으로 분할
    - 파티션 나눌 때 고민해야 되는 점
        - 데이터를 여러 서버에 고르게 분산할 수 있는가
        - 노드가 추가되거나 삭제될 때 데이터 이동을 최소화할 수 있는가
        - → 안정 해시로 이런 고민 사항 해결 가능
- 데이터 다중화 (Replication)
    - 높은 가용성과 안정성을 확보하기 위해 데이터를 N개 서버에 비동기적으로 다중화할 필요가 있음
    - 어떤 키를 해시 링 위에 배치한 후 그 지점으로 부터 순회하면서 N개의 서버에 데이터를 저장
    - 다만 가상 노드를 사용할 시 같은 서버에 또 데이터 들어갈 수 있음 → 중복 방지 로직 필요
    - **안정성을 보장하기 위해 다른 데이터 센터에 사본을 저장하도록 하자!**
- 일관성 (Consistency)
    - 여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 한다.
    - 정족수 합의 프로토콜을 사용하면 읽기/쓰기 연사 모두에 일관성을 보장할 수 있다.
        - N = 사본 개수
        - W = 쓰기 연산에 대한 정족수 → W개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야 함
        - R = 읽기 연산에 대한 정족수 → R개의 서버로부터 응답을 받아야 읽기 연산이 성공
        - 책 99p - 100p 예시 확인하기
        - R과 W를 적절히 조절하여 어떤 연산을 최적화할지 결정할 수 있다.
- 일관성 모델
    - 데이터의 일관성의 수준을 결정하는 모델
    - 강한 일관성 (strong consistency): 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환
        - 고가용성 시스템에는 적합하지 않음
    - 약한 일관성 (weak consistency): 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못할 수 있다.
    - 결과적 일관성 (eventual consistency): 약한 일관성의 한 형태로, 갱신 결과가 결국에는 모든 사본에 반영되는 모델
        - 다이나모, 카산드라가 선택한 일관성
- 일관성 불일치 해소 (Inconsistency resolution)
    - 데이터 버저닝
        - 데이터 다중화 → 가용성은 높아지지만 사본 사이의 일관성이 깨질 수 있음
        - 버저닝은 데이터를 변경할 때마다 데이터의 새 버전을 만드는 방법
        - 각 버전의 데이터는 immutable
        - 벡터 시계로 버저닝 가능함 (책 102 - 104p 참고)
            - 단점: 충돌 감지 및 해소 로직 필요, 벡터 시계의 순서쌍 개수에 빠르게 늘어서 데이터 관리 필요
- 장애 처리
    - 장애를 어떻게 처리할지 결정하는 것은 중요한 문제
    - 우선 장애 감지, 장애 해소
- 장애 감지
    - 가십 프로토콜
        - 각 노드는 멤버십 목록을 유지한다. 멤버십 목록은 멤버 ID와 박동 카운터 쌍의 목록
        - 각 노드는 주기적으로 자신의 박동 카운터를 증가
        - 각 노드는 무작위로 선정한 노드들에게 주기적으로 자신의 박동 카운터 전송
        - 박동 카운터 목록을 받은 노드는 멤버십 목록을 최신 값으로 갱신한다.
        - 어떤 멤버의 박동 카운터가 갱신되지 않으면 해당 멤버는 장애로 판단
        - 책 106p 예시 참고
    - 일시적 장애 처리
        - 장애를 감지한 시스템은 가용성을 보장하기 위해 조치를 해야 된다.
        - 정족수 요구사항에 맞춰서 장애에 대응해야 됨
        - 단서 후 임시위탁 기법을 통해 일시적 장애 처리 가능
    - 영구 장애 처리
        - 반 엔트로피 프로토콜을 구현하여 사본들을 동기화
        - 책 108 - 109p 다시 읽기
    - 데이터 센터 장애 처리
        - 정전, 네트워크 장애, 자연재해 등 여러 이유로 데이터 센터가 무너질 수 있음
        - 다중화 하는 것이 정말 중요하다!
- 시스템 아키텍처 다이어그램
    - 클라이언트는 키-값 저장소가 제공하는 두 가지 api를 통해 통신
    - 중재자는 클라이언트 - 저장소 사이의 프록시 역할을 수행
    - 노드는 안정 해시의 해시 링 위에 분포
- 쓰기 경로 (write path)
- 읽기 경로 (read path)
