# 10장. 알림 시스템 설계

---

알림 시스템은 모바일 푸시 알림, SMS 메시지, 이메일 세 가지로 분류 가능

## 문제 이해 및 설계 범위 확정

---

파악할 요구사항들

- 어떤 종류의 알림을 지원하는지 (푸시, sms, 이메일)
- 실시간 시스템인지 (hard real-time, soft real-time)
- 어떤 단말을 지원하는지 (ios, 안드, 컴퓨터)
- 알림은 누가 생성하는지 (클라이언트, 서버 측 스케줄링)
- 사용자가 알림을 거부할 수 있는지
- 하루에 몇 건 보내는지

## 개략적 설계안 제시 및 동의 구하기

---

### 알림 유형별 지원 방안

**ios 푸시 알림**

3가지 컴포넌트가 필요함

- 알림 제공자: 알림 요청을 만들어 애플 푸시 알림 서비스로 보내는 주체 필요한 데이터는 다음과 같음
    - 단말 토큰: 알림 요청을 보내는 데 필요한 고유 식별자
    - 페이로드: 알림 내용을 담은 JSON 딕셔너리 데이터
- APNS: 애플이 제공하는 원격 서비스 → 푸시 알림은 ios 장치로 보내줌
- ios 단말: 아이폰

**안드로이드 푸시 알림**

안드로이드 푸시 알림도 ios와 비슷한 방식으로 동작한다.

APNS 대신에 FCM(Firebase Cloud Messaging)을 사용함

**sms 메시지**

sms 메시지를 보낼 때는 보통 제 3사업자의 서비스를 많이 이용 → 요금제

https://techblog.woowahan.com/7724/

**이메일**

이메일도 상용 이메일 서비스를 주로 이용한다. → 요금제

전송 이슈도 잘 안나고 데이터 분석도 가능해서 자주 쓰임

### 연락처 정보 수집 절차

알림을 보내려면 모바일 단말 토큰, 전화번호, 이메일 등 정보가 필요하다.

→ 사용자 정보가 데이터베이스에 있어야 함

데이터베이스 테이블은 아래와 같은 형식이 될 수 있음 (user - device 가 OneToMany)

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/c24c1c37-348d-4726-a6fd-bf4d9d340e26)

마스킹해야 되는 개인정보일 시 양방향 해시로 잘 설계해두기

### 알림 전송 및 수신 절차

**개략적 설계안 (초안)**

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/e1576b95-e65a-4800-b363-e6244197dc58)

- N개의 서비스: 마이크로서비스, 크론잡, 분산 시스템 컴포넌트 등 서비스가 여러개일 수 있음
- 알림 시스템: 알림 전송, 수신 처리의 핵심, 일단은 1개 사용
- 제 3자 서비스: 사용자들에게 알림을 실제로 전달하는 역할을 수행, **제 3자 서비스와 통합할 때 유의할 점은 확장성!!**
- 단말: 아이폰, 갤럭시, 맥북, 갤럭시북 등 단말

문제점

- SPOF: 알림 시스템이 1개이면 단일 장애 지점이 될 수 있다.
- 규모 확장성: 하나의 서비스로 푸시 알림에 대한 모든 것(데이터 저장까지)을 처리하므로 데이터베이스, 캐시 등 중요 컴포넌트를 확장하기 어려움
- 성능 병목: 알림 시스템에서 특정 요청을 처리하는데 오래 걸리면 병목이 될 수 있다. → 트래픽이 많아질시 과부하 가능

개략적 설계안 (개선 버전)

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/06b78567-b0df-492b-ad7c-bc5e57721319)

- 알림 시스템에서 데이터베이스 캐시 분리
- 알림 서버를 증설하고 자동으로 **스케일 아웃** 가능하도록 설계
- **메시지 큐**를 활용하여 **시스템 컴포넌트 사이의 강결합을 제거**

각 컴포넌트의 기능

- 알림 서버
    - 알림 전송 API: 스팸 방지를 위해 보통 사내 서비스 또는 인증된 클라이언트만 이용 가능
    - 알림 검증: 이메일 주소, 전화번호 등에 대한 기본적 검증을 수행
    - 데이터베이스 또는 캐시 질의: 알림에 포함시킬 데이터를 가져오는 기능
    - 알림 전송: 알림 데이터를 메시지 큐에 전달한다. → 메시지 큐가 여러개이면 병렬적으로 처리 가능
- 데이터베이스: 사용자, 알림, 설정 등 다양한 정보 저장
- 메시지 큐: 의존성을 제거하기 위해 사용, 대량의 알림이 전송되는 경우에는 버퍼 역할도 수행한다. 알림 종류별로 별도의 큐를 사용하게 되면 특정 서비스에 장애가 발생하더라도 다른 서비스에 영향을 주지 않을 수 있다.
- 작업 서버: 메시지 큐에 전송할 알림을 꺼내서 제 3자 서비스로 전달하는 역할을 담당하는 서버
- 제 3자 서비스
- 단말

알림 전송 과정

1. API를 호출하여 알림 서버로 알림을 보낸다.
2. 알림 서버는 사용자 정보, 단말 토큰, 알림 설정 같은 메타데이터를 캐시나 DB에서 꺼내온다.
3. 알림 서버는 전송할 알림에 맞는 이벤트를 생성하고 이벤트를 큐로 발행한다.
4. 작업 서버는 큐에서 이벤트를 구독한다.
5. 작업 서버는 알림을 제 3자 서비스로 전송한다.
6. 제 3자 서비스는 사용자 단말로 알림을 전송한다.

## 상세 설계

---

### 안정성

분산 환경에서 운영될 알림 시스템을 설계할 때는 안정성을 확보해야 한다.

**데이터 손실 방지**

**알림 시스템은 어떠한 상황에서도 알림이 유실되면 안 된다!** 

→ 알림이 지연되거나 순서가 바뀌는 것은 괜찮지만 사라지면 안 된다는 의미

이러한 요구사항을 만족하기 위해 알림 데이터를 DB에 저장하고 재시도 매커니즘을 구현해야 한다.

→ 알림 로그 데이터를 데이터베이스에 저장하는 방법

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/186d3b5a-9b06-4915-86b9-8cbb0cc2f3e1)

**알림 중복 전송 방지**

같은 알림이 여러 번 반복되는 것을 완전히 막는 것은 불가능

→ 분산 시스템의 특성상 가끔 중복되어 전송되는 경우가 있음

**빈도를 줄이기 위해 노력해야 된다.**

중복 탐지 매커니즘을 도입하고, 오류를 신중하게 처리하여 중복 전송을 방지할 수 있다.

- 보내야 할 알림이 도착하면 이벤트 ID를 검사하여 이전에 본 적이 있는 이벤트인지 확인

### 추가로 필요한 컴포넌트 및 고려사항

**알림 템플릿**

알림 메시지 대부분은 형식이 비슷함 

→ 템플릿을 활용하면 좋다.

**알림 설정**

사용자가 알림 설정을 상세히 조절할 수 있어야 한다.

이러한 정보는 알림 설정 테이블에 보관할 수 있다.

**알림 설정 테이블 정보를 바탕으로 알림을 켜둔 사용자에게만 알림을 보내야 한다.**

**전송률 제한**

사용자가 너무 많은 알림을 받지 않게 전송률을 제한 해줘야 한다.

**재시도 방법**

제 3자 서비스가 알림 전송에 실패하면 해당 알림을 재시도 전용 큐에 넣는다. 같은 문제가 자주 발생하면 개발자에게 통지

**푸시 알림과 보안**

ios와 안드의 경우 appKey, appSecret을 활용하여 보안을 유지해야 한다.

→ 인증되거나 승인된 클라이언트만 API를 활용하여 알림을 보낼 수 있어야 한다.

**큐 모니터링**

큐에 얼마나 이벤트가 쌓여있는지 모니터링 해줘야 한다.

→ 너무 크면 이벤트를 제대로 처리하지 못하고 있다는 뜻임

→ 이런 경우 작업 서버 증설 필요

**이벤트 추적**

데이터 분석 서비스를 활용하면 이벤트 추적이 가능함

→ 알림 확인율, 클릭율, 실제 사용 등 여러 매트릭을 제공받을 수 있다.

### 수정된 설계안

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/8074d40c-8401-44f4-8fef-5454bd22751a)

- 알림 서버에 인증, 전송률 제한 기능 추가
- 오류 상황 시 재시도 로직 추가
- 전송 템플릿을 활용하여 알림 생성을 단순화, 알림 내용 일관성 유지
- 모니터링과 추적 시스템을 추가하여 시스템 상태를 확인하고 추후 시스템 개선을 쉽도록 설계

## 마무리

---

집중한 주제

- 안정성: 메시지 전송 실패율을 낮추기 위해 안정적인 재시도 매커니즘 도입
- 보안: 인증된 클라이언트만 알림을 보낼 수 있도록 appKey, appSecret 등 매커니즘 도입
- 이벤트 추적 및 모니터링: 알림의 생성, 전송까지의 과정을 추적하고 시스템 상태를 모니터링하기 위해 알림 전송의 각 단계마다 이벤트를 추적 및 모니터링
- 사용자 설정: 사용자가 알림 수신 설정을 조정할 수 있도록 설계 → 알림을 보내기전 반드시 해당 정보를 확인해야 됨
- 전송률 제한: 사용자에게 알림을 보내는 빈도를 제한할 수 있도록 설계
