# 14장. 유튜브 설계

---

유튜브 통계

- 월간 능동 사용자 수: 20억
- 매일 재생되는 비디오: 50억
- 미국 성인 73% 유튜브 이용
- 5천만 창작자
- 유튜브 광고 수익 150억 달러
- 모바일 인터넷 트래픽 37% 유튜브가 점유
- 80개 언어로 이용 가능

## 문제 이해 및 설계 범위 확정

---

- 어떤 기능이 가장 중요한가 → 비디오 업로드, 시청 기능
- 어떤 클라이언트를 지원하는가 → 모바일 앱, 웹 브라우저, 스마트 TV
- 일간 능동 사용자 수 → 500만
- 사용자가 제품에 평균적으로 소비하는 시간 → 30분
- 다국어 지원 필요한지
- 비디오 해상도는 어느정도 지원하는지
- 암호화가 필요한지
- 비디오 파일 크기 제한은 어떻게 되는지
- 아마존, 구글, MS가 지원하는 클라우드 서비스를 활용해도 되는지

요구 사항은 다음과 같다.

- 빠른 비디오 업로드
- 원활한 비디오 재생
- 재생 품질 선택 가능
- 낮은 인프라 비용
- 높은 가용성과 규모 확장성과 안정성
- 지원 클라이언트: 모바일 앱, 웹 브라우저, 스마트 TV

### 개략적 규모 추정

- 일간 능동 이용자: 500만
- 한 사용자는 평균 5개의 비디오 시청
- 10%의 사용자가 하루에 1 비디오 업로드
- 비디오 평균 크기 300MB
- 비디오 저장을 위해 매일 새로 요구되는 저장 용량 = 500만 * 10% * 300MB = 150TB
- CDN 비용
    - 클라우드 CDN은 사용량에 비례한다.

## 개략적 설계안 제시 및 동의 구하기

---

우선 CDN과 BLOB 스토리지는 기존 클라우드 서비스를 사용한다고 가정

→ 규모 확장이 쉬운 CDN과 BLOB 스토리지를 설계하는 것은 복잡한 작업

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/05aa8e13-bd6a-47e5-9cad-a449fa4b42dd)

- 단말: 유튜브를 시청하는 클라이언트
- CDN: 비디오를 저장하는 공간
- API 서버: 비디오 스트리밍을 제외한 모든 요청은 API 서버가 처리함

### 비디오 업로드 절차

비디오 업로드 절차의 설계안

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/2a953e88-ad83-4ae6-9770-98eb236fe554)

- 사용자: 유튜브를 이용하는 클라이언트
- 로드 밸런서: API 서버에 요청을 분산하는 역할을 수행한다.
- API 서버: 비디오 스트리밍을 제외한 다른 모든 요청을 처리한다.
- 메타데이터 데이터베이스: 비디오의 메타 데이터를 저장하는 데이터베이스 → 샤딩, 다중화를 통한 성능 및 가용성 요구사항을 충족한다.
- 메타데이터 캐시: 성능을 높이기 위해 비디오 메타데이터와 사용자 객체를 캐시한다
- 원본 저장소: 원본 비디오를 저장할 대형 이진 파일 저장소(BLOB) 시스템
- 트랜스코딩 서버: 비디오 인코딩이라고도 부르는 절차로 비디오 포맷을 변환하는 절차 → 단말, 대역폭에 따른 최적의 비디오 스트림을 제공하기 위해 필요함
- 트랜스코딩 비디오 저장소: 트랜스코딩이 완료된 비디오를 저장하는 BLOB 저장소
- CDN: 비디오 캐시 역할을 담당 → 스트리밍은 CDN을 통해 이루어진다.
- 트랜스코딩 완료 큐: 비디오 트랜스코딩 완료 이벤트를 보관할 메시지 큐
- 트랜스코딩 완료 핸들러: 이벤트를 받아 메타데이터 캐시와 데이터베이스를 갱신할 작업 서버

비디오 업로드는 다음 두 프로세스가 병렬적으로 수행된다.

1. 비디오 업로드
2. 비디오 메타데이터 갱신

**프로세스 a: 비디오 업로드**

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/39877d8c-f903-4c6d-853a-57dba6d40b8b)

1. 비디오를 원본 저장소에 업로드한다.
2. 트랜스코딩 서버는 원본 저장소에서 해당 비디오를 가져와 트랜스코딩을 시작한다.
3. 트랜스코딩이 완료되면 아래 두 절차가 병렬적으로 수행된다.
    1. 완료된 비디오를 트랜스코딩 비디오 저장소로 업로드
    2. 트랜스코딩 완료 이벤트를 트랜스코딩 완료 큐에 넣는다.
        1. 트랜스코딩이 끝난 비디오를 CDN에 올린다.
        2. 완료 핸들러가 이벤트 데이터를 큐에서 꺼낸다.
        3. 완료 핸들러가 메타데이터 데이터베이스와 캐시를 갱신한다.
4. API 서버가 단말에게 비디오 업로드가 끝나서 스트리밍 준비가 되었음을 알린다.

**프로세스 b: 메타데이터 갱신**

원본 저장소에 파일이 업로드되는 동안, 단말은 병렬적으로 비디오 메타데이터 갱신 요청을 API 서버로 보냄

메타데이터에는 파일 이름, 크기, 포맷 등 정보가 있다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/c181563d-32bd-4586-879d-4c21d01e62b3)

### 비디오 스트리밍 절차

다운로드: 비디오를 단말로 내려 받는 것

스트리밍: 장치가 원격지의 비디오로부터 지속적으로 비디오 스트림을 전송 받는 것

스트리밍 프로토콜: 비디오 스트리밍을 위해 데이터를 전송할 때 쓰이는 표준화된 통신 방법

- MPEG-DASH
- Apple HLS
- Microsoft Smooth Streaming
- Adobe HTTP Dynamic Streaming

→ **프로토콜마다 지원하는 비디오 인코딩이 다르고 플레이어도 다르다.**

→ 서비스 용도에 맞게 프로토콜을 잘 골라야 함

비디오는 CDN에서 스트리밍된다. → 가장 가까운 CDN에서 데이터를 받아오므로 전송지연이 매우 낮음

## 상세 설계

---

### 비디오 트랜스코딩

비디오를 녹화하면 해당 비디오는 특정 포맷으로 저장된다.

→ 다른 장치에서 비디오를 재생하기 위해 호환되는 비트레이트와 포맷으로 변경해야됨

비디오 트랜스코딩이 필요한 이유

- 가공되지 않은 비디오의 용량은 크다.
- 상당수의 단말과 브라우저는 특정 비디오 포맷만 지원함
- 사용자에게 원활한 비디오 재생을 보장하기 위해 저화질~고화질로 적절하게 보내줘야 함
- 모바일 단말의 경우 네트워크 상황이 수시로 달라짐

인코딩 포맷은 두 부분으로 구성되어 있다.

- 컨테이너: 비디오 파일, 오디오, 메타데이터를 담는 바구니 같은 것 .avi, .mov, .mp4
- 코덱: 비디오 화질을 보존하면서 파일 크기를 압축시킬 목적으로 고안된 압축 알고리즘

### 유향 비순환 그래프(DAG) 모델

**각기 다른 유형의 비디오 프로세싱 파이프라인을 지원하면서 처리 과정에서 병렬성을 높이기 위해 적절한 수준의 추상화를 도입하여 클라이언트로 하여금 실행할 작업을 손수 정의할 수 있도록 해야 한다.**

→ 작업을 단계별로 배열할 수 있도록 하여 해당 작업들이 순차적으로 또는 병렬적으로 실행되도록

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/ae8f836c-59ab-49ca-9bb7-35b764c30814)

비디오 작업

- 검사: 비디오 품질을 검사한다.
- 비디오 인코딩: 비디오를 다양한 해상도, 코덱, 비트레이트 조합으로 인코딩하는 작업
- 섬네일: 사용자가 업로드한 이미지 또는 비디오에서 자동 추출된 이미지로 섬네일을 만든다.
- 워터마크: 비디오에 대한 식별 정보를 이미지 위에 오버레이 형태로 띄워 표시하는 작업

### 비디오 트랜스 코딩 아키텍처

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/21067d97-d7fc-42f8-a47c-6034122b6c57)

전처리기, DAG 스케줄러, 자원 관리자, 작업 실행 서버, 임시 저장소로 구성된다.

**전처리기**

- 비디오 분할: 비디오 스트림을 GOP(Group of Pictures)라는 단위로 쪼갠다.
- DAG 생성: 클라이언트가 작성한 설정 파일에 따라 DAG를 만들어낸다.
- 데이터 캐시: 전처리기는 분할된 비디오의 캐시이다. 안정성을 높이기 위해 전처리기는 GOP와 메타데이터를 임시 저장소에 보관한다. 비디오 인코딩 실패시 임시 저장소에 보관된 데이터를 활용해 인코딩 재개

**DAG 스케줄러**

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/7cbfa28e-dddb-4ecd-849d-6005b0ca2ab0)

**자원 관리자**

자원 배분을 효과적으로 수행하는 역할을 담당

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/a8ee1e1c-a613-4cdc-adff-25a6d864507c)

- 작업 큐: 실행한 작업이 보관되어 있는 우선순위 큐
- 작업 서버 큐: 작업 서버의 가용 상태 정보가 보관되어 있는 우선순위 큐
- 실행 큐: 현재 실행 중인 작업 및 작업 서버 정보가 보관되어 있는 큐
- 작업 스케줄러: 최적의 작업/서버 조합을 골라, 해당 작업 서버가 작업을 수행하도록 지시하는 역할

작업 관리자는 다음과 같이 동작함

- 작업 큐에서 작업을 꺼낸다.
- 작업을 실행하기 위한 적절한 작업 서버를 고른다.
- 작업 서버에 작업 실행을 지시한다.
- 작업이 어떤 서버에 할당되었는지 정보를 실행 큐에 넣는다.
- 작업이 완료되면 작업을 실행 큐에서 제거한다.

**작업 서버**

DAG에 정의된 작업을 수행한다. → 작업 종류에 따라 작업 서버도 구분하여 관리함

**임시 저장소**

메타데이터: 빈번히 참조, 데이터 크기 작음 → 메모리에 캐시

비디오/오디오 데이터: BLOB 저장소에 저장

**인코딩된 비디오**

인코딩 파이프라인의 최종 결과물

### 시스템 최적화

**속도 최적화: 비디오 병렬 업로드**

GOP를 병렬적으로 업로드하면 일부가 실패하더라도 빠르게 업로드 재개 가능하다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/1f322902-fc39-40a4-9817-b212d1c5dcde)

**속도 최적화: 업로드 센터 사용자 근거리에 지정**

업로드 센터를 여러 곳에 두어 가까운 지역으로 비디오를 업로드할 수 있도록 설계할 수 있다.

**속도 최적화: 모든 절차를 병렬화**

느슨하게 결합된 시스템을 만들어 병렬성을 높일 수 있다.

설계안을 다음과 같이 변경해야 한다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/9806b0fb-9b90-43e2-829b-0c77ff9f2680)

메시지 큐를 도입하여 시스템 결합도를 낮출 수 있음

- 메시지 큐가 없다면 인코딩 모듈은 이전 작업이 끝나기를 기다려야 된다.
- 메시지 큐 도입으로 이전 작업을 기다릴 필요가 없다. 각각 수행한 작업을 큐에 올리기만 하면 된다.

**안정성 최적화: 미리 사인된 업로드 URL**

허가받은 사용자만 올바른 장소에 비디오를 업로드할 수 있도록 미리 사인된 업로드 URL을 이용한다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/c5939dd0-d1f1-44fc-9215-8368f30764f8)

업로드 절차

1. 클라이언트는 POST 요청을 통해 미리 사인된 URL를 받는다.
2. API 서버가 미리 사인된 URL을 반환한다.
3. 클라이언트는 해당 URL이 가리키는 위치에 비디오를 업로드한다.

**안정성 최적화: 비디오 보호**

비디오 저작권 방지를 위해 다음과 같은 선택지가 있다.

- DRM 시스템 도입
- AES 암호화
- 워터마크

**비용 최적화**

CDN은 비싸다 CDN 요금을 어떻게 관리할 수 있을까

유튜브 비디오 스트리밍은 롱테일 분포를 따른다 → 볼건 보고 안볼건 안본다.

이를 통한 최적화 방법

1. 인기 비디오는 CDN으로 다른 비디오는 비디오 서버를 통해서 재생
2. 인기가 별로 없는 비디오는 인코딩 할 필요가 없을 수도 있다. 짧은 비디오라면 필요할 때 인코딩해도 된다.
3. 어떤 비디오는 특정 지역에서만 인기있다. → 다른 지역에 옮길 필요가 없음
4. CDN을 직접 구축하고 ISP와 제휴한다.

### 오류 처리

시스템 오류 2가지는 다음과 같다.

- 회복 가능 오류: 재시도하면 회복할 수 있는 오류를 말한다.
- 회복 불가능 오류: 절대로 해결할 수 없는 오류를 말한다.

오류에 대한 전형적 해결 방법들

- 업로드 오류: 몇 회 재시도
- 비디오 분할 오류: 낡은 버전의 클라이언트가 GOP 경계에 따라 비디오를 분할하지 못하는 경우 전체 비디오를 서버에 전송하고 서버가 이를 처리
- 트랜스코딩 오류: 재시도
- 전처리 오류: DAG 그래프 재생성
- DAG 스케줄러 오류: 작업을 다시 스케줄링
- 자원 관리자 큐에 장애 발생: 사본을 이용한다.
- 작업 서버 장애: 다른 서버에서 작업 재시도
- API 서버 장애: 무상태성이므로 다른 서버로 보낸다.
- 메타데이터 캐시 서버 장애: 데이터는 다중화 되어 있으므로 다른 노드에서 데이터 가져오기, 장애난 서버는 새로운 것으로 교체
- 메타데이터 데이터베이스 서버 장애
    - 주 서버가 죽었다면 부 서버를 주 서버로 교체
    - 부 서버가 죽었다면 다른 부 서버가 읽기 연산을 처리하고 죽은 서버 교체

## 마무리

---

추가적으로 고민해볼 사항들

- API 계층의 규모 확장성 확보 방안: API 서버의 무상태성을 바탕으로 수평적 확장
- 데이터베이스 계층 규모 확장성 확보 방안: DB 샤딩 및 다중화
- 라이브 스트리밍: 응답지연이 낮아야한다. 병렬화 필요성이 떨어짐 → 작은 데이터를 빨리 처리해야되기 때문. 오류 처리 방법을 다르게 해야된다.
- 비디오 삭제: 문제가 생긴 비디오는 삭제해야 한다. → 업로드 과정에서 식별하거나 사용자 신고로 처리 가능
