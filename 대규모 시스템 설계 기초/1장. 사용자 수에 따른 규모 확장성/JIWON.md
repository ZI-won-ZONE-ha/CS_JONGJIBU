# 1장. 사용자 수에 따른 규모 확장성

---

## 단일 서버

---

모든 컴포넌트가 단 한 대의 서버에서 실행되는 간단한 시스템

웹 앱, 데이터베이스, 캐시 등이 전부 서버 한 대에서 실행된다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/cb7dfe1a-c18f-4260-8ade-960ba0165b17)

사용자 요청 처리 흐름

1. 사용자는 도메인 이름을 이용하여 웹 사이트에 접속한다. → DNS에 질의하여 IP 주소로 변환하는 과정 필요하고 DNS는 서드파티가 제공하는 유료 서비스를 이용한다.
2. DNS 조회 결과를 바탕으로 IP 주소가 반환된다. 
3. 해당 IP 주소로 HTTP 요청이 전달된다.
4. 요청을 받은 웹 서버는 HTML 페이지 또는 JSON 응답을 반환한다.

실제 요청이 어디서 오는지

- 웹 애플리케이션: 비즈니스 로직, 데이터 저장은 백엔드를 사용하고 프레젠테이션으로는 프론트를 사용
- 모바일 앱: 모바일 앱과 웹 서버 간 통신을 위해 HTTP Protocol를 이용. 응답 타입으로는 주로 JSON 사용

## 데이터베이스

---

사용자가 늘면 서버 하나로는 감당이 안되어 여러 서버가 필요함

하나는 웹, 모바일 요청 처리 용도로 하나는 데이터베이스 용도로 사용

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/a4f47b8f-5938-427c-94dd-1afa75a2f460)

어떤 데이터베이스를 사용할까?

- 관계형 데이터베이스
    - 데이터를 테이블, 로우, 칼럼으로 표현한다.
    - 여러 테이블의 관계를 바탕으로 데이터를 가져올 수 있다. →join
    - MySQL, Oracle, PostgreSQL 등 존재
- 비 관계형 데이터베이스
    - NoSQL
    - Key-Value Store
    - Graph Store
    - Column Store
    - Document Store
    - 낮은 응답 지연시간 요구, 데이터가 비정형 데이터, 데이터를 직렬화 또는 역직렬화만 하면 되는 데이터, 아주 많은 양의 데이터를 저장할 필요가 있을 때 사용할 수 있다.

## 수직적 규모 확장(Scale Up) vs 수평적 규모 확장 (Scale Out)

---

- 수직적 규모 확장
    - 서버의 하드웨어를 더 좋은 하드웨어로 교체하는 확장 방식
    - CPU, RAM 등을 추가하여 규모를 확장
    - 추가할 수 있는 하드웨어의 한계가 존재한다.
    - 장애 자동 복구, 다중화 방안을 제시하지 않음
- 수평적 규모 확장
    - 서버의 개수를 늘려서 확장하는 방식
    - 대규모 애플리케이션에서 사용하기 적절한 방식

### 로드밸런서

**로드밸런서는 부하 분산 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할 수행**

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/6d15ecfa-32d9-49de-b76d-69f9eea9cf7b)

- 사용자는 로드밸런서의 Public IP 주소로 접근 → 웹 서버가 직접 접속을 처리하지 않음
- 서버 간 통신에는 Private IP 주소를 사용하여 보안성 강화
    - Private IP: 같은 네트워크에 속한 서버 사이의 통신에서 쓰일 수 있는 IP주소
- 로드밸런서 도입으로 장애를 자동 복구할 수 있게되어 가용성 향상
    - 서버 1이 죽으면 서버 2로 모든 트래픽 전송 → 웹 사이트 전체 다운 방지
    - 트래픽이 가파르게 증가하여 감당하지 못한 시점이 올 때 서버 3을 추가하고 로드 밸런서에 연결하면 문제 해결 가능

### 데이터베이스 다중화

대부분의 DBMS는 다중화 지원

→ Master, Slave 구조로 다중화 설정

**쓰기 연산은 Master에서 지원한다.**

**Slave는 Master DB의 Replica로 읽기 연산만을 지원한다.**

→ 대부분의 DB 연산이 Read가 많다는 특징 활용함

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/8b4f0158-3d4c-4916-8c7e-9287a0f4615e)

DB 다중화의 장점

- 더 나은 성능: 데이터 변경은 Master, 데이터 조회는 Slave 구조가 됨에 따라 연산들이 분산되어 처리되고 읽기 연산은 분산적으로 처리되어 성능이 좋아진다.
- 안정성: 데이터베이스 서버가 천재지변으로 무너져도 다른 데이터베이스들이 있기 때문에 안전하다.
- 가용성: 데이터를 여러 지역에 복제하여 하나의 데이터베이스에 장애가 생겨도 다른 서버의 데이터를 가져옴으로 가용성 높은 서비스로 처리 가능

DB가 무너졌을 때 시나리오

- 부 서버가 한 대일 때 무너짐 → 메인 서버가 읽기 연산까지 담당해주면 된다.
- 부 서버가 여러 대일 때 무너짐 → 다른 부 서버가 읽기 연산 담당해주면 된다.
- 메인 서버가 무너짐 → 부 서버가 메인 서버를 담당하여 쓰기 연산을 담당해준다.
    - 고려할 점: 부 서버에 보관된 데이터가 최신 상태가 아닐 수 있음 → 레플리케이션 속도 이슈로 인해 → 이럴 때는 복구 스크립트 실행 및 다중 마스터, 원형 다중화 구조로 대처해야 한다.
    - Replica Lag 문제라고도 한다.
    - [https://velog.io/@haron/트러블슈팅-Replica-Lag-이슈-tpdqvums](https://velog.io/@haron/%ED%8A%B8%EB%9F%AC%EB%B8%94%EC%8A%88%ED%8C%85-Replica-Lag-%EC%9D%B4%EC%8A%88-tpdqvums)

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/7ddedc8c-6062-408e-8029-29e55225a34e)

- 사용자는 DNS로부터 로드밸런서의 Public IP 획득
- 사용자는 Public IP로 로드밸런서 접속
- 요청은 로드밸런싱으로 서버1, 서버2 중 한 곳에 접근
- 읽기 작업: Slave DB
- 쓰기 작업: Master DB

## 캐시

캐시는 코스트가 큰 연산 결과 또는 자주 참조되는 데이터를 메모리에 두고 빠르게 처리될 수 있도록 하는 저장소이다.

### 캐시 계층

캐시 계층은 데이터가 잠시 보관되는 곳으로 DB보다 훨씬 빠르다.

→ 성능 개선 및 데이터베이스 부하 줄일 수 있음

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/f41f8890-5abb-48ab-a4bb-3093fc19df5f)

웹 서버는 캐시를 확인하고 캐시에 데이터가 없다면 데이터베이스에서 해당 데이터를 가져오고 캐시에 이를 저장해두는 방식으로 동작한다.

→ 읽기 주도형 캐시 전략

### 캐시 유의사항

- 캐시는 갱신이 적고 조회가 많은 상황에서 유리하다.
- 캐시는 휘발성 메모리에 데이터를 두므로 영속적으로 보관할 데이터를 담아두면 안 된다.
- 캐시 데이터 만료 전략에 대해 고민해야 한다.
- 영속성 저장소와 캐시 사이의 데이터 일관성을 보장해야 한다.
- 캐시 서버 장애 상황에 대한 전략이 있어야 한다. → 캐시 서버가 한 대라면 단일 장애 지점이 될 수 있음
- 캐시 메모리에 대한 크기를 잘 지정해야 한다.
- 데이터 evict 정책을 잘 세워야 한다. → 어떤 데이터를 방출할지 → LRU, LFU, FIFO 등 여러 전략 존재

## 콘텐츠 전송 네트워크 (CDN)

---

정적 콘텐츠를 전송하는데 쓰이는 지리적으로 분산된 서버의 네트워크

→ 이미지, 비디오, CSS, JS 파일 캐시 가능

동작 방식

- 사용자 웹 사이트 방문
- 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달한다.
    - 사용자와 CDN 서버가 물리적으로 멀수록 응답이 느리다.

CDN 동작 방식

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/e9219572-3796-4b4f-9151-9c3b1c3e6c24)

1. 사용자가 정적 데이터에 접근 → CDN 서비스 제공자가 제공하는 URL을 바탕으로 접근
2. CDN 서버 캐시에 해당 데이터가 없는 경우 원본 서버로부터 정적 데이터 가져옴
3. 원본 서버가 CDN에게 정적 데이터 응답 → TTL(Time To Live) 값 포함하여 응답
4. CDN 서버는 파일을 캐시하고 사용자에게 데이터 반환
5. 다른 사용자가 TTL 이전에 같은 데이터를 요청하면 캐싱된 데이터 반환

### CDN 사용시 고려사항

- 비용: CDN 사업자에게 비용을 내야하므로 자주 캐싱할 필요가 없는 정적 데이터는 CDN에서 빼는 것을 고려
- 적절한 만료 시한 설정: 시의성이 중요한 컨텐츠의 경우 적절한 만료 시한으로 관리해야 한다.
- CDN 장애에 대한 대처 방안: CDN이 터진 경우 이를 감지하여 원본 서버로 데이터를 요청하는 로직 필요
- 컨텐츠 무효화: 아직 만료되지 않은 컨텐츠를 무효화 API 또는 버전 정보를 바탕으로 무효화가 가능하다.

이렇게 적절하게 캐시와 CDN을 활용하면 서버의 부하를 감소시키고 성능을 향상시킬 수 있다.

## 무상태(stateless) 웹 계층

---

**웹 계층을 수평적으로 확장할 때는 상태 정보를 웹 계층에서 제거해야 한다.**

→ 상태 정보를 RDB 또는 NoSQL과 같은 저장소에 보관하고 필요할 때 가져오게 해야 됨

### 상태 정보 의존적인 아키텍처

상태 정보를 보관하는 서버는 클라이언트 정보를 유지하여 요청들 사이에 공유되도록 한다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/07f3e446-41fb-44ed-9453-826daa50ca5e)

이렇게 상태 정보에 의존적인 서버를 설계하게 되면 유저 1은 계속 서버 1과 통신을 해야하고 유저 2는 계속 서버 2와 통신을 해야한다.

→ 로드밸런서의 고정 세션 기능이 있지만 이는 로드밸런서에 부담을 준다. + 서버 추가 및 서버 장애 대처가 어려움

### 무상태 아키텍처

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/443b5a7e-e667-4fa3-a37f-0398272170f4)

이렇게 무상태 아키텍처를 구축하게 되면 유저가 어떤 서버든 요청을 보낼 수 있게 된다.

상태 정보가 필요한 경우 공유 저장소로부터 데이터를 가져온다.

→ 상태 정보가 웹 서버로부터 물리적으로 분리되어 있음

상태 정보는 RDB, NoSQL 등에 저장 가능 → NoSQL이 규모 확장 측면에서 좋다.

## 데이터 센터

---

웹 사이트의 규모가 커지게 되면 여러 사용자에게 쾌적한 환경을 제공하기 위해 여러 데이터 센터를 지원해야 한다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/c4b68b83-409b-404b-991e-26529d7ba7c5)

장애가 없는 상황에서 유저는 본인의 물리적 위치에서 가장 가까운 데이터 센터로 보내진다.

→ 지리적 라우팅(geoRouting) → geoDNS가 사용자 위치에 따라 IP 주소를 알맞게 변경해준다.

만약 **데이터 센터에 장애가 발생한다면 모든 트래픽이 장애가 발생하지 않은 지점으로 이동한다.**

다중 데이터센터 아키텍처 기술적 난제

- 트래픽 우회: 올바른 데이터 센터로 트래픽을 보내는 효율적인 방법을 찾아야 한다. geoDNS는 물리적 위치를 바탕으로 트래픽 보냄
- 데이터 동기화: 데이터 센터마다 별도의 DB를 사용중인 상태라면 장애가 자동으로 복구되어 트래픽이 다른 데이터베이스로 우회되어도 원하는 데이터가 존재하지 않을 수 있다. → 데이터를 여러 데이터센터에 걸쳐 다중화해야됨
- 테스트와 배포: 여러 위치에서 테스트를 해보는 것이 중요하다 → 자동화된 배포 도구는 모든 데이터 센터에 동일한 서비스가 설치되도록 하는 데 중요한 역할 수행

## 메시지 큐

---

메시지 큐는 메시지의 무손실을 보장하고 비동기 통신을 지원하는 컴포넌트

→ 메시지의 버퍼 역할을 하며, 비동기적으로 전송함

생산자가 메시지를 만들어 메시지 큐에 메시지를 발행하고 소비자가 큐의 메시지를 받아 그에 맞는 동작을 수행하는 방식으로 동작한다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/4e6aa7f1-f62d-4e37-a69a-6d74167a280b)

메시지 큐를 이용하면 서비스 또는 서버 간 결합이 느슨해진다.

→ 규모 확장성을 보장하는 애플리케이션 구성 가능

생산자는 소비자 프로세스가 다운되어 있어도 메시지 발행 가능

소비자는 생산자 서비스가 가용한 상태가 아니더라도 메시지 수신 가능

책 23p 메시지 큐 예시 읽기

## 로그, 메트릭, 자동화

---

- 로그: 에러 로그를 모니터링하는 것은 중요 → 시스템 오류와 문제들 빠르고 쉽게 파악 가능 → 로그를 모아주는 서비스를 활용하면 더 쉽게 로그 조회 가능
- 메트릭: 메트릭을 잘 수집하면 사업 현황에 관한 유용한 정보를 얻을 수 있다. 시스템의 현재 상태도 쉽게 파악 가능
    - 호스트 단위 메트릭: CPU, 메모리, Disk IO
    - 종합 메트릭: DB 계층의 성능, 캐시 계층의 성능
    - 핵심 비즈니스 메트릭: 일별 사용자, 수익, 재방문률
- 자동화: 생산성을 높이기 위해 활용한다. CI, 빌드, 테스트, 배포 자동화 등으로 개발 생산성 향상

### 메시지 큐, 로그, 메트릭, 자동화 등을 반영한 설계

1. 메시지 큐는 각 컴포넌트를 느슨하게 결합해주고 결함에 대한 내성을 높인다.
2. 로그, 모니터링, 메트릭, 자동화 등을 지원한다.

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/43784505-c3ad-4839-a83b-79b8fcc75c03)

## 데이터베이스의 규모 확장

---

저장할 데이터가 많아지면 데이터베이스 부하도 증가한다.

데이터베이스도 스케일 업, 스케일 아웃으로 규모 확장 가능

### 스케일 업

서버의 하드웨어 자원을 더 좋은 자원으로 교체하는 방식

하드웨어의 한계가 있으므로 무제한으로 증축 불가능

SPOF(Single Point Of Failure)로 인한 위험성이 크다.

비용이 많이 든다. 고성능 서버로 갈수록 가격이 올라간다.

### 스케일 아웃

**데이터베이스의 수평적 확장은 샤딩이라고도 부른다.**

더 많은 서버를 추가하여 증축하는 방식

**샤딩: 대규모 데이터베이스를 샤드라고 부르는 작은 단위로 분할하는 기술을 말한다.**

모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없음

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/d52ba158-7e16-445d-8186-c01e95863f66)

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/397dd7dd-ba5d-4318-926b-045935bf6f8f)

샤딩 고려할 점

- 샤딩 키(파티션 키)를 어떻게 정하는지
    - 샤딩 키를 정할 때는 데이터를 고르게 분할 할 수 있도록 하는 게 가장 중요하다.
    - 데이터의 재샤딩
        - 데이터가 너무 많아져서 하나의 샤드로 감당이 안될 때
        - 샤드 간 데이터 분포가 균등하지 못할 때 → 샤드 소진
    - 유명인사 문제(핫스팟 키 문제)
        - 특정 샤드에 쿼리가 집중되어 서버에 과부하가 걸리는 문제
    - 조인과 비정규화
        - 여러 샤드에 걸친 데이터를 조인하기가 힘들다.
        - DB를 비정규화 하거나 하나의 테이블에서 쿼리가 수행될 수 있도록 해야 됨

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/4a0e8e88-4ae2-4f1d-a8eb-05ebc07ca05e)

## 백만 사용자, 그리고 그 이상

---

수백만 사용자 이상을 지원하려면 새로운 전략을 도입해야 한다.

1장에서 다룬 시스템 규모 확장 기법들

- 웹 계층은 무상태 계층으로
- 모든 계층에 다중화 도입
- 가능한 많은 데이터를 캐시할 것
- 여러 데이터 센터를 지원할 것
- 정적 콘텐츠는 CDN을 통해 제공할 것
- 데이터 계층은 샤딩을 통해 그 규모를 확장할 것
- 각 계층은 독립적 서비스로 분할할 것
- 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것
