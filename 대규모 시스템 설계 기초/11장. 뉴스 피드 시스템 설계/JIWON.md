# 11장. 뉴스 피드 시스템 설계

---

뉴스 피드: 홈페이지에 중앙에 지속적으로 업데이트 되는 스토리 (페이스북)

## 문제 이해 및 설계 범위 확정

---

- 어떤 기종에서 동작하는지 (모바일, 웹)
- 중요한 기능이 무엇인지 (피드를 올리고 다른 사람의 피드 조회 가능)
- 피드가 어떤 순서로 배치되는지 (최신순, 인기순)
- 최대 친구가 몇 명인지 (5000명)
- 트래픽 규모가 어느 정도인지 (매일 천만 명)
- 피드에 이미지, 비디오 올릴 수 있는지

## 개략적 설계안 제시 및 동의 구하기

---

- 피드 발행: 사용자가 스토리를 포스팅하면 포스팅 데이터를 캐시와 데이터베이스에 기록, 포스팅은 친구의 피드에도 전송된다.
- 뉴스 피드 생성: 뉴스 피드는 친구들의 포스팅을 시간 흐름 역순으로 모아서 만든다고 가정

### 뉴스 피드 API

HTTP 프로토콜 기반

상태 정보 업데이트, 뉴스 피드 불러오기, 친구 추가 등 다양한 API 지원

**피드 발행 API**

새 스토리를 포스팅하는 API, POST 메서드

바디: 포스팅 내용을 담는다.

Authorization 헤더: API 호출 인증을 위해 사용한다.

**피드 읽기 API**

뉴스 피드를 가져오는 API, GET 메서드

Authorization 헤더: API 호출 인증을 위해 사용한다.

**피드 발행**

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/6fd390ce-0c34-4a9e-87a5-351fb552eafc)

사용자: POST로 요청을 보낸다.

로드 밸런서: 트래픽을 분산시킨다.

웹 서버: HTTP 요청을 내부 서비스로 중계한다.

포스팅 저장 서비스: 요청으로 생성된 포스팅을 데이터베이스와 캐시에 저장

포스팅 전송 서비스: 새 포스팅을 친구의 뉴스 피드에 푸시 → 빠르게 read가 가능하도록 캐시에 저장

알림 서비스: 친구들에게 새 포스팅이 올라왔음을 알리거나 푸시 알림을 보낸다.

**뉴스 피드 생성**

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/38f82198-de5f-4fec-a0f2-3e328145adba)

사용자: GET 요청을 보낸다.

로드 밸런서: 트래픽을 분산시킨다.

웹 서버: 트래픽을 뉴스 피드 서비스로 보낸다.

뉴스 피드 서비스: 캐시에서 뉴스 피드를 가져온다.

뉴스 피드 캐시: 뉴스 피드를 랜더링할 때 필요한 피드 ID를 보관

## 상세 설계

---

### 피드 발행 흐름 상세 설계

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/9d280ba9-5f2e-4aaf-84a1-4b25b3342b8f)

**웹 서버**

클라이언트와 통신, 인증, 처리율 제한 등 기능을 수행

올바른 인증 토큰을 가진 사용자만 API 호출이 가능하도록 설계해야 한다.

스팸과 유해한 컨텐츠를 막기 위해 한 사용자의 포스팅 개수를 조절할 수 있어야 한다.

**포스팅 전송(팬아웃) 서비스**

사용자의 새 포스팅을 그 사용자와 친구 관계에 있는 모든 사용자에게 전달하는 과정

- 쓰기 시점에 팬아웃하는 모델
    - 새로운 포스팅을 기록하는 시점에 뉴스 피드를 갱신한다.
    - 장점
        - 뉴스 피드가 실시간으로 갱신되며 친구 목록에 있는 사용자에게 즉시 전송
        - 뉴스 피드를 읽는 데 드는 시간이 짧음
    - 단점
        - 친구가 많은 사용자의 경우 뉴스 피드 갱신이 오래 걸린다. (핫키)
        - 서비스를 자주 이용하지 않는 사용자의 뉴스 피드도 갱신함
- 읽기 시점에 팬아웃하는 모델
    - 피드를 읽어야 하는 시점에 뉴스 피드를 갱신한다. → 요청 기반 모델
    - 장점
        - 자주 사용하지 않는 사용자가 많으면 리소스 낭비가 줄어서 좋다.
        - 핫키 문제 발생하지 않음
    - 단점
        - 뉴스 피드를 읽는 데 많은 시간이 소요될 수 있다.

**뉴스 피드를 빠르게 가져올 수 있도록 대부분의 사용자는 푸시 모델을 활용하고, 친구나 팔로워가 많은 사용자의 경우 팔로워로 하여금 해당 사용자의 포스팅을 필요할 때 가져갈 수 있도록 하는 풀 모델을 활용하여 시스템 과부하 방지 가능**

안정 해시를 통해 요청과 데이터를 보다 고르게 분산하여 핫키 문제를 줄일 수 있음

이를 바탕으로 구현한 팬아웃 서비스

1. 그래프 데이터베이스를 활용하여 친구 ID 목록을 가져온다. (그래프 데이터베이스는 친구 관계, 친구 추천 등 관리하기 용이함)
2. 사용자 정보 캐시에서 친구들의 정보를 가져온다. 사용자 설정에 따라 친구 중 일부를 걸러낸다.
3. 친구 목록과 새 스토리의 포스팅 ID를 메시지 큐에 넣는다.
4. 팬 아웃 작업 서버가 메시지 큐에서 데이터를 꺼내서 뉴스 피드 데이터를 뉴스 피드 캐시에 넣는다. 뉴스 피드 캐시는 <포스팅 ID, 사용자 ID> 순서 쌍을 보관한다. → 전체 데이터를 캐시에 넣으면 메모리 부하가 발생할 수 있기 때문에 ID로 순서 쌍 보관

### 피드 읽기 흐름 상세 설계

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/cf504a1c-5560-44d7-9c9f-be6f0568379e)

1. 사용자가 뉴스 피드를 읽으려는 요청을 보낸다.
2. 로드 밸런서가 요청을 웹 서버 중 하나로 보낸다.
3. 웹 서버는 피드를 가져오기 위해 뉴스 피드 서비스를 호출한다.
4. 뉴스 피드 서비스는 뉴스 피드 캐시에서 포스팅 ID 목록을 가져온다.
5. 뉴스 피드에 표시할 사용자 이름, 사진, 컨텐츠 등 사용자 캐시와 포스팅 캐시에서 데이터를 가져와 온전한 뉴스 피드를 만든다.
6. 생성된 뉴스 피드를 JSON 형태로 보내주고 이를 렌더링 한다.

### 캐시 구조

![image](https://github.com/ZI-won-ZONE-ha/CS_JONGJIBU/assets/88527476/57c93fa9-165e-4803-b3f9-4e3b96ec3680)

뉴스: 뉴스 피드의 ID 보관

컨텐츠: 포스팅 데이터 보관, 인기 컨텐츠는 따로 관리

소셜 그래프: 사용자 간 관계 정보를 보관

행동: 포스팅에 대한 사용자 행위에 관한 정보를 보관

횟수: 행위에 관한 횟수 등의 정보를 보관

## 마무리

---

추가적으로 고민하면 좋은 문제

- 데이터베이스 규모 확장
    - 수직적 vs 수평적
    - SQL, NoSQL
    - Master - Slave 구조
    - Replica에 대한 읽기 연산
    - 일관성 모델
    - 샤딩
- 웹 계층 무상태로 운영하기
- 많은 데이터를 캐싱할 방법
- 여러 데이터 센터를 지원할 방법
- 메시지 큐를 활용해 컴포넌트 사이의 결합성 낮추기
- 핵심 메트릭에 대한 모니터링
